LabelSubstitutionTest
 Feature: Vertexium
  Scenario: Support normalizing labels in create node
   passed - Scenario: Support normalizing labels in create node.Given an empty graph
   passed - Scenario: Support normalizing labels in create node.And having executed:
   passed - Scenario: Support normalizing labels in create node.When executing query:
   passed - Scenario: Support normalizing labels in create node.Then the result should be:
  Scenario: Support normalizing labels in create relationship
   passed - Scenario: Support normalizing labels in create relationship.Given an empty graph
   passed - Scenario: Support normalizing labels in create relationship.And having executed:
   passed - Scenario: Support normalizing labels in create relationship.When executing query:
   passed - Scenario: Support normalizing labels in create relationship.Then the result should be:
  Scenario: Support normalizing labels in node first match
   passed - Scenario: Support normalizing labels in node first match.Given an empty graph
   passed - Scenario: Support normalizing labels in node first match.And having executed:
   passed - Scenario: Support normalizing labels in node first match.When executing query:
   passed - Scenario: Support normalizing labels in node first match.Then the result should be:
   passed - Scenario: Support normalizing labels in node first match.And no side effects
  Scenario: Support normalizing labels in node second match
   passed - Scenario: Support normalizing labels in node second match.Given an empty graph
   passed - Scenario: Support normalizing labels in node second match.And having executed:
   passed - Scenario: Support normalizing labels in node second match.When executing query:
   passed - Scenario: Support normalizing labels in node second match.Then the result should be:
   passed - Scenario: Support normalizing labels in node second match.And no side effects
  Scenario: Support normalizing labels in relationship first match
   passed - Scenario: Support normalizing labels in relationship first match.Given an empty graph
   passed - Scenario: Support normalizing labels in relationship first match.And having executed:
   passed - Scenario: Support normalizing labels in relationship first match.When executing query:
   passed - Scenario: Support normalizing labels in relationship first match.Then the result should be:
   passed - Scenario: Support normalizing labels in relationship first match.And no side effects
  Scenario: Support normalizing labels in relationship second match
   passed - Scenario: Support normalizing labels in relationship second match.Given an empty graph
   passed - Scenario: Support normalizing labels in relationship second match.And having executed:
   passed - Scenario: Support normalizing labels in relationship second match.When executing query:
   passed - Scenario: Support normalizing labels in relationship second match.Then the result should be:
   passed - Scenario: Support normalizing labels in relationship second match.And no side effects
PropertySubstitutionTest
 Feature: Vertexium
  Scenario: Support normalizing properties in create node
   passed - Scenario: Support normalizing properties in create node.Given an empty graph
   passed - Scenario: Support normalizing properties in create node.And having executed:
   passed - Scenario: Support normalizing properties in create node.When executing query:
   passed - Scenario: Support normalizing properties in create node.Then the result should be:
  Scenario: Support normalizing properties in create relationship
   passed - Scenario: Support normalizing properties in create relationship.Given an empty graph
   passed - Scenario: Support normalizing properties in create relationship.And having executed:
   passed - Scenario: Support normalizing properties in create relationship.When executing query:
   passed - Scenario: Support normalizing properties in create relationship.Then the result should be:
  Scenario: Support normalizing properties in node first match
   passed - Scenario: Support normalizing properties in node first match.Given an empty graph
   passed - Scenario: Support normalizing properties in node first match.And having executed:
   passed - Scenario: Support normalizing properties in node first match.When executing query:
   passed - Scenario: Support normalizing properties in node first match.Then the result should be:
   passed - Scenario: Support normalizing properties in node first match.And no side effects
  Scenario: Support normalizing properties in node second match
   passed - Scenario: Support normalizing properties in node second match.Given an empty graph
   passed - Scenario: Support normalizing properties in node second match.And having executed:
   passed - Scenario: Support normalizing properties in node second match.When executing query:
   passed - Scenario: Support normalizing properties in node second match.Then the result should be:
   passed - Scenario: Support normalizing properties in node second match.And no side effects
  Scenario: Support normalizing properties in relationship first match
   passed - Scenario: Support normalizing properties in relationship first match.Given an empty graph
   passed - Scenario: Support normalizing properties in relationship first match.And having executed:
   passed - Scenario: Support normalizing properties in relationship first match.When executing query:
   passed - Scenario: Support normalizing properties in relationship first match.Then the result should be:
   passed - Scenario: Support normalizing properties in relationship first match.And no side effects
  Scenario: Support normalizing properties in relationship second match
   passed - Scenario: Support normalizing properties in relationship second match.Given an empty graph
   passed - Scenario: Support normalizing properties in relationship second match.And having executed:
   passed - Scenario: Support normalizing properties in relationship second match.When executing query:
   passed - Scenario: Support normalizing properties in relationship second match.Then the result should be:
   passed - Scenario: Support normalizing properties in relationship second match.And no side effects
  Scenario: Support normalizing properties in return statement
   passed - Scenario: Support normalizing properties in return statement.Given an empty graph
   passed - Scenario: Support normalizing properties in return statement.And having executed:
   passed - Scenario: Support normalizing properties in return statement.When executing query:
   passed - Scenario: Support normalizing properties in return statement.Then the result should be:
StringEscapingTest
 Feature: Vertexium
  Scenario: Support escaping labels
   passed - Scenario: Support escaping labels.Given an empty graph
   passed - Scenario: Support escaping labels.And having executed:
   passed - Scenario: Support escaping labels.When executing query:
   passed - Scenario: Support escaping labels.Then the result should be:
   passed - Scenario: Support escaping labels.And no side effects
  Scenario: Support escaping property names
   passed - Scenario: Support escaping property names.Given an empty graph
   passed - Scenario: Support escaping property names.And having executed:
   passed - Scenario: Support escaping property names.When executing query:
   passed - Scenario: Support escaping property names.Then the result should be:
   passed - Scenario: Support escaping property names.And no side effects
  Scenario: Support escaping relationship labels
   passed - Scenario: Support escaping relationship labels.Given an empty graph
   passed - Scenario: Support escaping relationship labels.And having executed:
   passed - Scenario: Support escaping relationship labels.When executing query:
   passed - Scenario: Support escaping relationship labels.Then the result should be:
   passed - Scenario: Support escaping relationship labels.And no side effects
VertexiumTest
 Feature: Vertexium
  Scenario: Support escaping labels
   passed - Scenario: Support escaping labels.Given an empty graph
   passed - Scenario: Support escaping labels.And having executed:
   passed - Scenario: Support escaping labels.When executing query:
   passed - Scenario: Support escaping labels.Then the result should be:
   passed - Scenario: Support escaping labels.And no side effects
  Scenario: Support escaping property names
   passed - Scenario: Support escaping property names.Given an empty graph
   passed - Scenario: Support escaping property names.And having executed:
   passed - Scenario: Support escaping property names.When executing query:
   passed - Scenario: Support escaping property names.Then the result should be:
   passed - Scenario: Support escaping property names.And no side effects
  Scenario: Support escaping edge labels
   passed - Scenario: Support escaping edge labels.Given an empty graph
   passed - Scenario: Support escaping edge labels.And having executed:
   passed - Scenario: Support escaping edge labels.When executing query:
   passed - Scenario: Support escaping edge labels.Then the result should be:
   passed - Scenario: Support escaping edge labels.And no side effects
AggregationAcceptanceTest
 Feature: AggregationAcceptance
  Scenario: Support multiple divisions in aggregate function
   passed - Scenario: Support multiple divisions in aggregate function.Given an empty graph
   passed - Scenario: Support multiple divisions in aggregate function.And having executed:
   passed - Scenario: Support multiple divisions in aggregate function.When executing query:
   passed - Scenario: Support multiple divisions in aggregate function.Then the result should be:
   passed - Scenario: Support multiple divisions in aggregate function.And no side effects
  Scenario: Support column renaming for aggregates as well
   passed - Scenario: Support column renaming for aggregates as well.Given an empty graph
   passed - Scenario: Support column renaming for aggregates as well.And having executed:
   passed - Scenario: Support column renaming for aggregates as well.When executing query:
   passed - Scenario: Support column renaming for aggregates as well.Then the result should be:
   passed - Scenario: Support column renaming for aggregates as well.And no side effects
  Scenario: Aggregates inside normal functions
   passed - Scenario: Aggregates inside normal functions.Given an empty graph
   passed - Scenario: Aggregates inside normal functions.And having executed:
   passed - Scenario: Aggregates inside normal functions.When executing query:
   passed - Scenario: Aggregates inside normal functions.Then the result should be:
   passed - Scenario: Aggregates inside normal functions.And no side effects
  Scenario: Count nodes
   passed - Scenario: Count nodes.Given an empty graph
   passed - Scenario: Count nodes.And having executed:
   passed - Scenario: Count nodes.When executing query:
   passed - Scenario: Count nodes.Then the result should be:
   passed - Scenario: Count nodes.And no side effects
  Scenario: Sort on aggregate function and normal property
   passed - Scenario: Sort on aggregate function and normal property.Given an empty graph
   passed - Scenario: Sort on aggregate function and normal property.And having executed:
   passed - Scenario: Sort on aggregate function and normal property.When executing query:
   failed - Scenario: Sort on aggregate function and normal property.Then the result should be, in order:
   ignored - Scenario: Sort on aggregate function and normal property.And no side effects
  Scenario: Aggregate on property
   passed - Scenario: Aggregate on property.Given an empty graph
   passed - Scenario: Aggregate on property.And having executed:
   passed - Scenario: Aggregate on property.When executing query:
   passed - Scenario: Aggregate on property.Then the result should be:
   passed - Scenario: Aggregate on property.And no side effects
  Scenario: Count non-null values
   passed - Scenario: Count non-null values.Given an empty graph
   passed - Scenario: Count non-null values.And having executed:
   passed - Scenario: Count non-null values.When executing query:
   passed - Scenario: Count non-null values.Then the result should be:
   passed - Scenario: Count non-null values.And no side effects
  Scenario: Sum non-null values
   passed - Scenario: Sum non-null values.Given an empty graph
   passed - Scenario: Sum non-null values.And having executed:
   passed - Scenario: Sum non-null values.When executing query:
   error - Scenario: Sum non-null values.Then the result should be:
   ignored - Scenario: Sum non-null values.And no side effects
  Scenario: Handle aggregation on functions
   passed - Scenario: Handle aggregation on functions.Given an empty graph
   passed - Scenario: Handle aggregation on functions.And having executed:
   passed - Scenario: Handle aggregation on functions.When executing query:
   error - Scenario: Handle aggregation on functions.Then the result should be:
   ignored - Scenario: Handle aggregation on functions.And no side effects
  Scenario: Distinct on unbound node
   passed - Scenario: Distinct on unbound node.Given an empty graph
   passed - Scenario: Distinct on unbound node.When executing query:
   passed - Scenario: Distinct on unbound node.Then the result should be:
   passed - Scenario: Distinct on unbound node.And no side effects
  Scenario: Distinct on null
   passed - Scenario: Distinct on null.Given an empty graph
   passed - Scenario: Distinct on null.And having executed:
   passed - Scenario: Distinct on null.When executing query:
   passed - Scenario: Distinct on null.Then the result should be:
   passed - Scenario: Distinct on null.And no side effects
  Scenario: Collect distinct nulls
   passed - Scenario: Collect distinct nulls.Given any graph
   passed - Scenario: Collect distinct nulls.When executing query:
   failed - Scenario: Collect distinct nulls.Then the result should be:
   ignored - Scenario: Collect distinct nulls.And no side effects
  Scenario: Collect distinct values mixed with nulls
   passed - Scenario: Collect distinct values mixed with nulls.Given any graph
   passed - Scenario: Collect distinct values mixed with nulls.When executing query:
   failed - Scenario: Collect distinct values mixed with nulls.Then the result should be:
   ignored - Scenario: Collect distinct values mixed with nulls.And no side effects
  Scenario: Aggregates in aggregates
   passed - Scenario: Aggregates in aggregates.Given any graph
   passed - Scenario: Aggregates in aggregates.When executing query:
   ignored - Scenario: Aggregates in aggregates.Then a SyntaxError should be raised at compile time: NestedAggregation
  Scenario: Aggregates with arithmetics
   passed - Scenario: Aggregates with arithmetics.Given an empty graph
   passed - Scenario: Aggregates with arithmetics.And having executed:
   passed - Scenario: Aggregates with arithmetics.When executing query:
   passed - Scenario: Aggregates with arithmetics.Then the result should be:
   passed - Scenario: Aggregates with arithmetics.And no side effects
  Scenario: Aggregates ordered by arithmetics
   passed - Scenario: Aggregates ordered by arithmetics.Given an empty graph
   passed - Scenario: Aggregates ordered by arithmetics.And having executed:
   passed - Scenario: Aggregates ordered by arithmetics.When executing query:
   error - Scenario: Aggregates ordered by arithmetics.Then the result should be, in order:
   ignored - Scenario: Aggregates ordered by arithmetics.And no side effects
  Scenario: Multiple aggregates on same variable
   passed - Scenario: Multiple aggregates on same variable.Given an empty graph
   passed - Scenario: Multiple aggregates on same variable.And having executed:
   passed - Scenario: Multiple aggregates on same variable.When executing query:
   failed - Scenario: Multiple aggregates on same variable.Then the result should be:
   ignored - Scenario: Multiple aggregates on same variable.And no side effects
  Scenario: Simple counting of nodes
   passed - Scenario: Simple counting of nodes.Given an empty graph
   passed - Scenario: Simple counting of nodes.And having executed:
   passed - Scenario: Simple counting of nodes.When executing query:
   passed - Scenario: Simple counting of nodes.Then the result should be:
   passed - Scenario: Simple counting of nodes.And no side effects
  Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map
   passed - Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map.Given an empty graph
   passed - Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map.And having executed:
   passed - Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map.When executing query:
   passed - Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map.Then the result should be:
   passed - Scenario: Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map.And no side effects
  Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate
   passed - Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate.Given an empty graph
   passed - Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate.And having executed:
   passed - Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate.When executing query:
   passed - Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate.Then the result should be:
   passed - Scenario: Projection during aggregation in WITH before MERGE and after WITH with predicate.And no side effects
  Scenario: No overflow during summation
   passed - Scenario: No overflow during summation.Given any graph
   passed - Scenario: No overflow during summation.When executing query:
   error - Scenario: No overflow during summation.Then the result should be:
   ignored - Scenario: No overflow during summation.And no side effects
  Scenario: Counting with loops
   passed - Scenario: Counting with loops.Given an empty graph
   passed - Scenario: Counting with loops.And having executed:
   passed - Scenario: Counting with loops.When executing query:
   passed - Scenario: Counting with loops.Then the result should be:
   passed - Scenario: Counting with loops.And no side effects
  Scenario: `max()` should aggregate strings
   passed - )` should aggregate strings.Given any graph(Scenario: `max
   passed - )` should aggregate strings.When executing query:(Scenario: `max
   passed - )` should aggregate strings.Then the result should be:(Scenario: `max
   passed - )` should aggregate strings.And no side effects(Scenario: `max
  Scenario: `min()` should aggregate strings
   passed - )` should aggregate strings.Given any graph(Scenario: `min
   passed - )` should aggregate strings.When executing query:(Scenario: `min
   passed - )` should aggregate strings.Then the result should be:(Scenario: `min
   passed - )` should aggregate strings.And no side effects(Scenario: `min
AggregationTest
 Feature: Aggregation
  Scenario: `max()` over strings
   passed - )` over strings.Given any graph(Scenario: `max
   passed - )` over strings.When executing query:(Scenario: `max
   passed - )` over strings.Then the result should be:(Scenario: `max
   passed - )` over strings.And no side effects(Scenario: `max
  Scenario: `min()` over strings
   passed - )` over strings.Given any graph(Scenario: `min
   passed - )` over strings.When executing query:(Scenario: `min
   passed - )` over strings.Then the result should be:(Scenario: `min
   passed - )` over strings.And no side effects(Scenario: `min
  Scenario: `max()` over integers
   passed - )` over integers.Given any graph(Scenario: `max
   passed - )` over integers.When executing query:(Scenario: `max
   passed - )` over integers.Then the result should be:(Scenario: `max
   passed - )` over integers.And no side effects(Scenario: `max
  Scenario: `min()` over integers
   passed - )` over integers.Given any graph(Scenario: `min
   passed - )` over integers.When executing query:(Scenario: `min
   passed - )` over integers.Then the result should be:(Scenario: `min
   passed - )` over integers.And no side effects(Scenario: `min
  Scenario: `max()` over floats
   passed - )` over floats.Given any graph(Scenario: `max
   passed - )` over floats.When executing query:(Scenario: `max
   passed - )` over floats.Then the result should be:(Scenario: `max
   passed - )` over floats.And no side effects(Scenario: `max
  Scenario: `min()` over floats
   passed - )` over floats.Given any graph(Scenario: `min
   passed - )` over floats.When executing query:(Scenario: `min
   passed - )` over floats.Then the result should be:(Scenario: `min
   passed - )` over floats.And no side effects(Scenario: `min
  Scenario: `max()` over mixed numeric values
   passed - )` over mixed numeric values.Given any graph(Scenario: `max
   passed - )` over mixed numeric values.When executing query:(Scenario: `max
   passed - )` over mixed numeric values.Then the result should be:(Scenario: `max
   passed - )` over mixed numeric values.And no side effects(Scenario: `max
  Scenario: `min()` over mixed numeric values
   passed - )` over mixed numeric values.Given any graph(Scenario: `min
   passed - )` over mixed numeric values.When executing query:(Scenario: `min
   passed - )` over mixed numeric values.Then the result should be:(Scenario: `min
   passed - )` over mixed numeric values.And no side effects(Scenario: `min
ColumnNameAcceptanceTest
 Feature: ColumnNameAcceptance
  Scenario: Keeping used expression 1
   passed - Scenario: Keeping used expression 1.Given an empty graph
   passed - Scenario: Keeping used expression 1.And having executed:
   passed - Scenario: Keeping used expression 1.When executing query:
   passed - Scenario: Keeping used expression 1.Then the result should be:
   passed - Scenario: Keeping used expression 1.And no side effects
  Scenario: Keeping used expression 2
   passed - Scenario: Keeping used expression 2.Given an empty graph
   passed - Scenario: Keeping used expression 2.And having executed:
   passed - Scenario: Keeping used expression 2.When executing query:
   passed - Scenario: Keeping used expression 2.Then the result should be:
   passed - Scenario: Keeping used expression 2.And no side effects
  Scenario: Keeping used expression 3
   passed - Scenario: Keeping used expression 3.Given an empty graph
   passed - Scenario: Keeping used expression 3.And having executed:
   passed - Scenario: Keeping used expression 3.When executing query:
   passed - Scenario: Keeping used expression 3.Then the result should be:
   passed - Scenario: Keeping used expression 3.And no side effects
  Scenario: Keeping used expression 4
   passed - Scenario: Keeping used expression 4.Given an empty graph
   passed - Scenario: Keeping used expression 4.And having executed:
   passed - Scenario: Keeping used expression 4.When executing query:
   passed - Scenario: Keeping used expression 4.Then the result should be:
   passed - Scenario: Keeping used expression 4.And no side effects
ComparabilityTest
 Feature: Comparability
  Scenario: Comparing strings and integers using > in an AND'd predicate
   passed - Scenario: Comparing strings and integers using > in an AND'd predicate.Given an empty graph
   passed - Scenario: Comparing strings and integers using > in an AND'd predicate.And having executed:
   passed - Scenario: Comparing strings and integers using > in an AND'd predicate.When executing query:
   passed - Scenario: Comparing strings and integers using > in an AND'd predicate.Then the result should be:
   passed - Scenario: Comparing strings and integers using > in an AND'd predicate.And no side effects
  Scenario: Comparing strings and integers using > in a OR'd predicate
   passed - Scenario: Comparing strings and integers using > in a OR'd predicate.Given an empty graph
   passed - Scenario: Comparing strings and integers using > in a OR'd predicate.And having executed:
   passed - Scenario: Comparing strings and integers using > in a OR'd predicate.When executing query:
   passed - Scenario: Comparing strings and integers using > in a OR'd predicate.Then the result should be:
   passed - Scenario: Comparing strings and integers using > in a OR'd predicate.And no side effects
ComparisonOperatorAcceptanceTest
 Feature: ComparisonOperatorAcceptance
  Scenario: Handling numerical ranges 1
   passed - Scenario: Handling numerical ranges 1.Given an empty graph
   passed - Scenario: Handling numerical ranges 1.And having executed:
   passed - Scenario: Handling numerical ranges 1.When executing query:
   passed - Scenario: Handling numerical ranges 1.Then the result should be:
   passed - Scenario: Handling numerical ranges 1.And no side effects
  Scenario: Handling numerical ranges 2
   passed - Scenario: Handling numerical ranges 2.Given an empty graph
   passed - Scenario: Handling numerical ranges 2.And having executed:
   passed - Scenario: Handling numerical ranges 2.When executing query:
   passed - Scenario: Handling numerical ranges 2.Then the result should be:
   passed - Scenario: Handling numerical ranges 2.And no side effects
  Scenario: Handling numerical ranges 3
   passed - Scenario: Handling numerical ranges 3.Given an empty graph
   passed - Scenario: Handling numerical ranges 3.And having executed:
   passed - Scenario: Handling numerical ranges 3.When executing query:
   passed - Scenario: Handling numerical ranges 3.Then the result should be:
   passed - Scenario: Handling numerical ranges 3.And no side effects
  Scenario: Handling numerical ranges 4
   passed - Scenario: Handling numerical ranges 4.Given an empty graph
   passed - Scenario: Handling numerical ranges 4.And having executed:
   passed - Scenario: Handling numerical ranges 4.When executing query:
   passed - Scenario: Handling numerical ranges 4.Then the result should be:
   passed - Scenario: Handling numerical ranges 4.And no side effects
  Scenario: Handling string ranges 1
   passed - Scenario: Handling string ranges 1.Given an empty graph
   passed - Scenario: Handling string ranges 1.And having executed:
   passed - Scenario: Handling string ranges 1.When executing query:
   passed - Scenario: Handling string ranges 1.Then the result should be:
   passed - Scenario: Handling string ranges 1.And no side effects
  Scenario: Handling string ranges 2
   passed - Scenario: Handling string ranges 2.Given an empty graph
   passed - Scenario: Handling string ranges 2.And having executed:
   passed - Scenario: Handling string ranges 2.When executing query:
   passed - Scenario: Handling string ranges 2.Then the result should be:
   passed - Scenario: Handling string ranges 2.And no side effects
  Scenario: Handling string ranges 3
   passed - Scenario: Handling string ranges 3.Given an empty graph
   passed - Scenario: Handling string ranges 3.And having executed:
   passed - Scenario: Handling string ranges 3.When executing query:
   passed - Scenario: Handling string ranges 3.Then the result should be:
   passed - Scenario: Handling string ranges 3.And no side effects
  Scenario: Handling string ranges 4
   passed - Scenario: Handling string ranges 4.Given an empty graph
   passed - Scenario: Handling string ranges 4.And having executed:
   passed - Scenario: Handling string ranges 4.When executing query:
   passed - Scenario: Handling string ranges 4.Then the result should be:
   passed - Scenario: Handling string ranges 4.And no side effects
  Scenario: Handling empty range
   passed - Scenario: Handling empty range.Given an empty graph
   passed - Scenario: Handling empty range.And having executed:
   passed - Scenario: Handling empty range.When executing query:
   passed - Scenario: Handling empty range.Then the result should be:
   passed - Scenario: Handling empty range.And no side effects
  Scenario: Handling long chains of operators
   passed - Scenario: Handling long chains of operators.Given an empty graph
   passed - Scenario: Handling long chains of operators.And having executed:
   passed - Scenario: Handling long chains of operators.When executing query:
   passed - Scenario: Handling long chains of operators.Then the result should be:
   passed - Scenario: Handling long chains of operators.And no side effects
CreateAcceptanceTest
 Feature: CreateAcceptance
  Scenario: Create a single node with multiple labels
   passed - Scenario: Create a single node with multiple labels.Given an empty graph
   passed - Scenario: Create a single node with multiple labels.When executing query:
   passed - Scenario: Create a single node with multiple labels.Then the result should be empty
   passed - Scenario: Create a single node with multiple labels.And the side effects should be:
  Scenario: Combine MATCH and CREATE
   passed - Scenario: Combine MATCH and CREATE.Given an empty graph
   passed - Scenario: Combine MATCH and CREATE.And having executed:
   passed - Scenario: Combine MATCH and CREATE.When executing query:
   passed - Scenario: Combine MATCH and CREATE.Then the result should be empty
   passed - Scenario: Combine MATCH and CREATE.And the side effects should be:
  Scenario: Combine MATCH, WITH and CREATE
   passed - Scenario: Combine MATCH, WITH and CREATE.Given an empty graph
   passed - Scenario: Combine MATCH, WITH and CREATE.And having executed:
   passed - Scenario: Combine MATCH, WITH and CREATE.When executing query:
   passed - Scenario: Combine MATCH, WITH and CREATE.Then the result should be empty
   failed - Scenario: Combine MATCH, WITH and CREATE.And the side effects should be:
  Scenario: Newly-created nodes not visible to preceding MATCH
   passed - Scenario: Newly-created nodes not visible to preceding MATCH.Given an empty graph
   passed - Scenario: Newly-created nodes not visible to preceding MATCH.And having executed:
   passed - Scenario: Newly-created nodes not visible to preceding MATCH.When executing query:
   passed - Scenario: Newly-created nodes not visible to preceding MATCH.Then the result should be empty
   passed - Scenario: Newly-created nodes not visible to preceding MATCH.And the side effects should be:
  Scenario: Create a single node with properties
   passed - Scenario: Create a single node with properties.Given any graph
   passed - Scenario: Create a single node with properties.When executing query:
   passed - Scenario: Create a single node with properties.Then the result should be:
   passed - Scenario: Create a single node with properties.And the side effects should be:
  Scenario: Creating a node with null properties should not return those properties
   passed - Scenario: Creating a node with null properties should not return those properties.Given any graph
   passed - Scenario: Creating a node with null properties should not return those properties.When executing query:
   passed - Scenario: Creating a node with null properties should not return those properties.Then the result should be:
   passed - Scenario: Creating a node with null properties should not return those properties.And the side effects should be:
  Scenario: Creating a relationship with null properties should not return those properties
   passed - Scenario: Creating a relationship with null properties should not return those properties.Given any graph
   passed - Scenario: Creating a relationship with null properties should not return those properties.When executing query:
   passed - Scenario: Creating a relationship with null properties should not return those properties.Then the result should be:
   passed - Scenario: Creating a relationship with null properties should not return those properties.And the side effects should be:
  Scenario: Create a simple pattern
   passed - Scenario: Create a simple pattern.Given any graph
   passed - Scenario: Create a simple pattern.When executing query:
   passed - Scenario: Create a simple pattern.Then the result should be empty
   passed - Scenario: Create a simple pattern.And the side effects should be:
  Scenario: Create a self loop
   passed - Scenario: Create a self loop.Given an empty graph
   passed - Scenario: Create a self loop.When executing query:
   passed - Scenario: Create a self loop.Then the result should be empty
   passed - Scenario: Create a self loop.And the side effects should be:
  Scenario: Create a self loop using MATCH
   passed - Scenario: Create a self loop using MATCH.Given an empty graph
   passed - Scenario: Create a self loop using MATCH.And having executed:
   passed - Scenario: Create a self loop using MATCH.When executing query:
   passed - Scenario: Create a self loop using MATCH.Then the result should be empty
   passed - Scenario: Create a self loop using MATCH.And the side effects should be:
  Scenario: Create nodes and relationships
   passed - Scenario: Create nodes and relationships.Given any graph
   passed - Scenario: Create nodes and relationships.When executing query:
   passed - Scenario: Create nodes and relationships.Then the result should be empty
   passed - Scenario: Create nodes and relationships.And the side effects should be:
  Scenario: Create a relationship with a property
   passed - Scenario: Create a relationship with a property.Given any graph
   passed - Scenario: Create a relationship with a property.When executing query:
   passed - Scenario: Create a relationship with a property.Then the result should be empty
   passed - Scenario: Create a relationship with a property.And the side effects should be:
  Scenario: Create a relationship with the correct direction
   passed - Scenario: Create a relationship with the correct direction.Given an empty graph
   passed - Scenario: Create a relationship with the correct direction.And having executed:
   passed - Scenario: Create a relationship with the correct direction.When executing query:
   passed - Scenario: Create a relationship with the correct direction.Then the result should be empty
   passed - Scenario: Create a relationship with the correct direction.And the side effects should be:
   passed - Scenario: Create a relationship with the correct direction.When executing control query:
   passed - Scenario: Create a relationship with the correct direction.Then the result should be:
  Scenario: Create a relationship and an end node from a matched starting node
   passed - Scenario: Create a relationship and an end node from a matched starting node.Given an empty graph
   passed - Scenario: Create a relationship and an end node from a matched starting node.And having executed:
   passed - Scenario: Create a relationship and an end node from a matched starting node.When executing query:
   passed - Scenario: Create a relationship and an end node from a matched starting node.Then the result should be empty
   passed - Scenario: Create a relationship and an end node from a matched starting node.And the side effects should be:
   passed - Scenario: Create a relationship and an end node from a matched starting node.When executing control query:
   passed - Scenario: Create a relationship and an end node from a matched starting node.Then the result should be:
  Scenario: Create a single node after a WITH
   passed - Scenario: Create a single node after a WITH.Given an empty graph
   passed - Scenario: Create a single node after a WITH.And having executed:
   passed - Scenario: Create a single node after a WITH.When executing query:
   passed - Scenario: Create a single node after a WITH.Then the result should be empty
   passed - Scenario: Create a single node after a WITH.And the side effects should be:
  Scenario: Create a relationship with a reversed direction
   passed - Scenario: Create a relationship with a reversed direction.Given an empty graph
   passed - Scenario: Create a relationship with a reversed direction.When executing query:
   passed - Scenario: Create a relationship with a reversed direction.Then the result should be empty
   passed - Scenario: Create a relationship with a reversed direction.And the side effects should be:
   passed - Scenario: Create a relationship with a reversed direction.When executing control query:
   passed - Scenario: Create a relationship with a reversed direction.Then the result should be:
  Scenario: Create a pattern with multiple hops
   passed - Scenario: Create a pattern with multiple hops.Given an empty graph
   passed - Scenario: Create a pattern with multiple hops.When executing query:
   passed - Scenario: Create a pattern with multiple hops.Then the result should be empty
   passed - Scenario: Create a pattern with multiple hops.And the side effects should be:
   passed - Scenario: Create a pattern with multiple hops.When executing control query:
   passed - Scenario: Create a pattern with multiple hops.Then the result should be:
  Scenario: Create a pattern with multiple hops in the reverse direction
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.Given an empty graph
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.When executing query:
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.Then the result should be empty
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.And the side effects should be:
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.When executing control query:
   passed - Scenario: Create a pattern with multiple hops in the reverse direction.Then the result should be:
  Scenario: Create a pattern with multiple hops in varying directions
   passed - Scenario: Create a pattern with multiple hops in varying directions.Given an empty graph
   passed - Scenario: Create a pattern with multiple hops in varying directions.When executing query:
   passed - Scenario: Create a pattern with multiple hops in varying directions.Then the result should be empty
   passed - Scenario: Create a pattern with multiple hops in varying directions.And the side effects should be:
   passed - Scenario: Create a pattern with multiple hops in varying directions.When executing control query:
   failed - Scenario: Create a pattern with multiple hops in varying directions.Then the result should be:
  Scenario: Create a pattern with multiple hops with multiple types and varying directions
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.Given any graph
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.When executing query:
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.Then the result should be empty
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.And the side effects should be:
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.When executing query:
   passed - Scenario: Create a pattern with multiple hops with multiple types and varying directions.Then the result should be:
  Scenario: Nodes are not created when aliases are applied to variable names
   passed - Scenario: Nodes are not created when aliases are applied to variable names.Given an empty graph
   passed - Scenario: Nodes are not created when aliases are applied to variable names.And having executed:
   passed - Scenario: Nodes are not created when aliases are applied to variable names.When executing query:
   passed - Scenario: Nodes are not created when aliases are applied to variable names.Then the result should be:
   passed - Scenario: Nodes are not created when aliases are applied to variable names.And the side effects should be:
  Scenario: Only a single node is created when an alias is applied to a variable name
   passed - Scenario: Only a single node is created when an alias is applied to a variable name.Given an empty graph
   passed - Scenario: Only a single node is created when an alias is applied to a variable name.And having executed:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name.When executing query:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name.Then the result should be:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name.And the side effects should be:
  Scenario: Nodes are not created when aliases are applied to variable names multiple times
   passed - Scenario: Nodes are not created when aliases are applied to variable names multiple times.Given an empty graph
   passed - Scenario: Nodes are not created when aliases are applied to variable names multiple times.And having executed:
   passed - Scenario: Nodes are not created when aliases are applied to variable names multiple times.When executing query:
   passed - Scenario: Nodes are not created when aliases are applied to variable names multiple times.Then the result should be:
   passed - Scenario: Nodes are not created when aliases are applied to variable names multiple times.And the side effects should be:
  Scenario: Only a single node is created when an alias is applied to a variable name multiple times
   passed - Scenario: Only a single node is created when an alias is applied to a variable name multiple times.Given an empty graph
   passed - Scenario: Only a single node is created when an alias is applied to a variable name multiple times.And having executed:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name multiple times.When executing query:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name multiple times.Then the result should be:
   passed - Scenario: Only a single node is created when an alias is applied to a variable name multiple times.And the side effects should be:
  Scenario: A bound node should be recognized after projection with WITH + WITH
   passed - Scenario: A bound node should be recognized after projection with WITH + WITH.Given any graph
   passed - Scenario: A bound node should be recognized after projection with WITH + WITH.When executing query:
   passed - Scenario: A bound node should be recognized after projection with WITH + WITH.Then the result should be empty
   passed - Scenario: A bound node should be recognized after projection with WITH + WITH.And the side effects should be:
  Scenario: A bound node should be recognized after projection with WITH + UNWIND
   passed - Scenario: A bound node should be recognized after projection with WITH + UNWIND.Given any graph
   passed - Scenario: A bound node should be recognized after projection with WITH + UNWIND.When executing query:
   passed - Scenario: A bound node should be recognized after projection with WITH + UNWIND.Then the result should be empty
   passed - Scenario: A bound node should be recognized after projection with WITH + UNWIND.And the side effects should be:
  Scenario: A bound node should be recognized after projection with WITH + MERGE node
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE node.Given an empty graph
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE node.When executing query:
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE node.Then the result should be empty
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE node.And the side effects should be:
  Scenario: A bound node should be recognized after projection with WITH + MERGE pattern
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE pattern.Given an empty graph
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE pattern.When executing query:
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE pattern.Then the result should be empty
   passed - Scenario: A bound node should be recognized after projection with WITH + MERGE pattern.And the side effects should be:
  Scenario: Fail when trying to create using an undirected relationship pattern
   passed - Scenario: Fail when trying to create using an undirected relationship pattern.Given any graph
   passed - Scenario: Fail when trying to create using an undirected relationship pattern.When executing query:
   passed - Scenario: Fail when trying to create using an undirected relationship pattern.Then a SyntaxError should be raised at compile time: RequiresDirectedRelationship
  Scenario: Creating a pattern with multiple hops and changing directions
   passed - Scenario: Creating a pattern with multiple hops and changing directions.Given an empty graph
   passed - Scenario: Creating a pattern with multiple hops and changing directions.When executing query:
   passed - Scenario: Creating a pattern with multiple hops and changing directions.Then the result should be empty
   passed - Scenario: Creating a pattern with multiple hops and changing directions.And the side effects should be:
   passed - Scenario: Creating a pattern with multiple hops and changing directions.When executing control query:
   failed - Scenario: Creating a pattern with multiple hops and changing directions.Then the result should be:
CreateTest
 Feature: Create
  Scenario: Creating a node
   passed - Scenario: Creating a node.Given any graph
   passed - Scenario: Creating a node.When executing query:
   passed - Scenario: Creating a node.Then the result should be empty
   passed - Scenario: Creating a node.And the side effects should be:
  Scenario: Creating two nodes
   passed - Scenario: Creating two nodes.Given any graph
   passed - Scenario: Creating two nodes.When executing query:
   passed - Scenario: Creating two nodes.Then the result should be empty
   passed - Scenario: Creating two nodes.And the side effects should be:
  Scenario: Creating two nodes and a relationship
   passed - Scenario: Creating two nodes and a relationship.Given any graph
   passed - Scenario: Creating two nodes and a relationship.When executing query:
   passed - Scenario: Creating two nodes and a relationship.Then the result should be empty
   passed - Scenario: Creating two nodes and a relationship.And the side effects should be:
  Scenario: Creating a node with a label
   passed - Scenario: Creating a node with a label.Given an empty graph
   passed - Scenario: Creating a node with a label.When executing query:
   passed - Scenario: Creating a node with a label.Then the result should be empty
   passed - Scenario: Creating a node with a label.And the side effects should be:
  Scenario: Creating a node with a property
   passed - Scenario: Creating a node with a property.Given any graph
   passed - Scenario: Creating a node with a property.When executing query:
   passed - Scenario: Creating a node with a property.Then the result should be empty
   passed - Scenario: Creating a node with a property.And the side effects should be:
DeleteAcceptanceTest
 Feature: DeleteAcceptance
  Scenario: Delete nodes
   passed - Scenario: Delete nodes.Given an empty graph
   passed - Scenario: Delete nodes.And having executed:
   passed - Scenario: Delete nodes.When executing query:
   passed - Scenario: Delete nodes.Then the result should be empty
   passed - Scenario: Delete nodes.And the side effects should be:
  Scenario: Detach delete node
   passed - Scenario: Detach delete node.Given an empty graph
   passed - Scenario: Detach delete node.And having executed:
   passed - Scenario: Detach delete node.When executing query:
   passed - Scenario: Detach delete node.Then the result should be empty
   passed - Scenario: Detach delete node.And the side effects should be:
  Scenario: Delete relationships
   passed - Scenario: Delete relationships.Given an empty graph
   passed - Scenario: Delete relationships.And having executed:
   passed - Scenario: Delete relationships.When executing query:
   passed - Scenario: Delete relationships.Then the result should be empty
   passed - Scenario: Delete relationships.And the side effects should be:
  Scenario: Deleting connected nodes
   passed - Scenario: Deleting connected nodes.Given an empty graph
   passed - Scenario: Deleting connected nodes.And having executed:
   passed - Scenario: Deleting connected nodes.When executing query:
   passed - Scenario: Deleting connected nodes.Then a ConstraintVerificationFailed should be raised at runtime: DeleteConnectedNode
  Scenario: Detach deleting connected nodes and relationships
   passed - Scenario: Detach deleting connected nodes and relationships.Given an empty graph
   passed - Scenario: Detach deleting connected nodes and relationships.And having executed:
   passed - Scenario: Detach deleting connected nodes and relationships.When executing query:
   passed - Scenario: Detach deleting connected nodes and relationships.Then the result should be empty
   passed - Scenario: Detach deleting connected nodes and relationships.And the side effects should be:
  Scenario: Detach deleting paths
   passed - Scenario: Detach deleting paths.Given an empty graph
   passed - Scenario: Detach deleting paths.And having executed:
   passed - Scenario: Detach deleting paths.When executing query:
   passed - Scenario: Detach deleting paths.Then the result should be empty
   passed - Scenario: Detach deleting paths.And the side effects should be:
  Scenario: Undirected expand followed by delete and count
   passed - Scenario: Undirected expand followed by delete and count.Given an empty graph
   passed - Scenario: Undirected expand followed by delete and count.And having executed:
   passed - Scenario: Undirected expand followed by delete and count.When executing query:
   failed - Scenario: Undirected expand followed by delete and count.Then the result should be:
   ignored - Scenario: Undirected expand followed by delete and count.And the side effects should be:
  Scenario: Undirected variable length expand followed by delete and count
   passed - Scenario: Undirected variable length expand followed by delete and count.Given an empty graph
   passed - Scenario: Undirected variable length expand followed by delete and count.And having executed:
   passed - Scenario: Undirected variable length expand followed by delete and count.When executing query:
   error - Scenario: Undirected variable length expand followed by delete and count.Then the result should be:
   ignored - Scenario: Undirected variable length expand followed by delete and count.And the side effects should be:
  Scenario: Delete optionally matched relationship
   passed - Scenario: Delete optionally matched relationship.Given an empty graph
   passed - Scenario: Delete optionally matched relationship.And having executed:
   passed - Scenario: Delete optionally matched relationship.When executing query:
   passed - Scenario: Delete optionally matched relationship.Then the result should be empty
   passed - Scenario: Delete optionally matched relationship.And the side effects should be:
  Scenario: Delete on null node
   passed - Scenario: Delete on null node.Given an empty graph
   passed - Scenario: Delete on null node.When executing query:
   passed - Scenario: Delete on null node.Then the result should be empty
   passed - Scenario: Delete on null node.And no side effects
  Scenario: Detach delete on null node
   passed - Scenario: Detach delete on null node.Given an empty graph
   passed - Scenario: Detach delete on null node.When executing query:
   passed - Scenario: Detach delete on null node.Then the result should be empty
   passed - Scenario: Detach delete on null node.And no side effects
  Scenario: Delete on null path
   passed - Scenario: Delete on null path.Given an empty graph
   passed - Scenario: Delete on null path.When executing query:
   error - Scenario: Delete on null path.Then the result should be empty
   ignored - Scenario: Delete on null path.And no side effects
  Scenario: Delete node from a list
   passed - Scenario: Delete node from a list.Given an empty graph
   passed - Scenario: Delete node from a list.And having executed:
   passed - Scenario: Delete node from a list.And parameters are:
   passed - Scenario: Delete node from a list.When executing query:
   passed - Scenario: Delete node from a list.Then the result should be empty
   passed - Scenario: Delete node from a list.And the side effects should be:
  Scenario: Delete relationship from a list
   passed - Scenario: Delete relationship from a list.Given an empty graph
   passed - Scenario: Delete relationship from a list.And having executed:
   passed - Scenario: Delete relationship from a list.And parameters are:
   passed - Scenario: Delete relationship from a list.When executing query:
   passed - Scenario: Delete relationship from a list.Then the result should be empty
   passed - Scenario: Delete relationship from a list.And the side effects should be:
  Scenario: Delete nodes from a map
   passed - Scenario: Delete nodes from a map.Given an empty graph
   passed - Scenario: Delete nodes from a map.And having executed:
   passed - Scenario: Delete nodes from a map.When executing query:
   passed - Scenario: Delete nodes from a map.Then the result should be empty
   passed - Scenario: Delete nodes from a map.And the side effects should be:
  Scenario: Delete relationships from a map
   passed - Scenario: Delete relationships from a map.Given an empty graph
   passed - Scenario: Delete relationships from a map.And having executed:
   passed - Scenario: Delete relationships from a map.When executing query:
   passed - Scenario: Delete relationships from a map.Then the result should be empty
   passed - Scenario: Delete relationships from a map.And the side effects should be:
  Scenario: Detach delete nodes from nested map/list
   passed - Scenario: Detach delete nodes from nested map.list/Given an empty graph
   passed - Scenario: Detach delete nodes from nested map.list/And having executed:
   passed - Scenario: Detach delete nodes from nested map.list/When executing query:
   passed - Scenario: Detach delete nodes from nested map.list/Then the result should be empty
   passed - Scenario: Detach delete nodes from nested map.list/And the side effects should be:
  Scenario: Delete relationships from nested map/list
   passed - Scenario: Delete relationships from nested map.list/Given an empty graph
   passed - Scenario: Delete relationships from nested map.list/And having executed:
   passed - Scenario: Delete relationships from nested map.list/When executing query:
   passed - Scenario: Delete relationships from nested map.list/Then the result should be empty
   passed - Scenario: Delete relationships from nested map.list/And the side effects should be:
  Scenario: Delete paths from nested map/list
   passed - Scenario: Delete paths from nested map.list/Given an empty graph
   passed - Scenario: Delete paths from nested map.list/And having executed:
   passed - Scenario: Delete paths from nested map.list/When executing query:
   passed - Scenario: Delete paths from nested map.list/Then the result should be empty
   passed - Scenario: Delete paths from nested map.list/And the side effects should be:
  Scenario: Delete relationship with bidirectional matching
   passed - Scenario: Delete relationship with bidirectional matching.Given an empty graph
   passed - Scenario: Delete relationship with bidirectional matching.And having executed:
   passed - Scenario: Delete relationship with bidirectional matching.When executing query:
   passed - Scenario: Delete relationship with bidirectional matching.Then the result should be empty
   passed - Scenario: Delete relationship with bidirectional matching.And the side effects should be:
EqualsAcceptanceTest
 Feature: EqualsAcceptance
  Scenario: Number-typed integer comparison
   passed - Scenario: Number-typed integer comparison.Given an empty graph
   passed - Scenario: Number-typed integer comparison.And having executed:
   passed - Scenario: Number-typed integer comparison.When executing query:
   passed - Scenario: Number-typed integer comparison.Then the result should be:
   passed - Scenario: Number-typed integer comparison.And no side effects
  Scenario: Number-typed float comparison
   passed - Scenario: Number-typed float comparison.Given an empty graph
   passed - Scenario: Number-typed float comparison.And having executed:
   passed - Scenario: Number-typed float comparison.When executing query:
   passed - Scenario: Number-typed float comparison.Then the result should be:
   passed - Scenario: Number-typed float comparison.And no side effects
  Scenario: Any-typed string comparison
   passed - Scenario: Any-typed string comparison.Given an empty graph
   passed - Scenario: Any-typed string comparison.And having executed:
   passed - Scenario: Any-typed string comparison.When executing query:
   passed - Scenario: Any-typed string comparison.Then the result should be:
   passed - Scenario: Any-typed string comparison.And no side effects
  Scenario: Comparing nodes to nodes
   passed - Scenario: Comparing nodes to nodes.Given an empty graph
   passed - Scenario: Comparing nodes to nodes.And having executed:
   passed - Scenario: Comparing nodes to nodes.When executing query:
   passed - Scenario: Comparing nodes to nodes.Then the result should be:
   passed - Scenario: Comparing nodes to nodes.And no side effects
  Scenario: Comparing relationships to relationships
   passed - Scenario: Comparing relationships to relationships.Given an empty graph
   passed - Scenario: Comparing relationships to relationships.And having executed:
   passed - Scenario: Comparing relationships to relationships.When executing query:
   error - Scenario: Comparing relationships to relationships.Then the result should be:
   ignored - Scenario: Comparing relationships to relationships.And no side effects
ExpressionAcceptanceTest
 Feature: ExpressionAcceptance
  Scenario: Execute n['name'] in read queries
   passed - Scenario: Execute n['name'] in read queries.Given any graph
   passed - Scenario: Execute n['name'] in read queries.And having executed:
   passed - Scenario: Execute n['name'] in read queries.When executing query:
   passed - Scenario: Execute n['name'] in read queries.Then the result should be:
   passed - Scenario: Execute n['name'] in read queries.And no side effects
  Scenario: Execute n['name'] in update queries
   passed - Scenario: Execute n['name'] in update queries.Given any graph
   passed - Scenario: Execute n['name'] in update queries.When executing query:
   passed - Scenario: Execute n['name'] in update queries.Then the result should be:
   passed - Scenario: Execute n['name'] in update queries.And the side effects should be:
  Scenario: Use dynamic property lookup based on parameters when there is no type information
   passed - Scenario: Use dynamic property lookup based on parameters when there is no type information.Given any graph
   passed - Scenario: Use dynamic property lookup based on parameters when there is no type information.And parameters are:
   passed - Scenario: Use dynamic property lookup based on parameters when there is no type information.When executing query:
   passed - Scenario: Use dynamic property lookup based on parameters when there is no type information.Then the result should be:
   passed - Scenario: Use dynamic property lookup based on parameters when there is no type information.And no side effects
  Scenario: Use dynamic property lookup based on parameters when there is lhs type information
   passed - Scenario: Use dynamic property lookup based on parameters when there is lhs type information.Given any graph
   passed - Scenario: Use dynamic property lookup based on parameters when there is lhs type information.And parameters are:
   passed - Scenario: Use dynamic property lookup based on parameters when there is lhs type information.When executing query:
   passed - Scenario: Use dynamic property lookup based on parameters when there is lhs type information.Then the result should be:
   passed - Scenario: Use dynamic property lookup based on parameters when there is lhs type information.And the side effects should be:
  Scenario: Use dynamic property lookup based on parameters when there is rhs type information
   passed - Scenario: Use dynamic property lookup based on parameters when there is rhs type information.Given any graph
   passed - Scenario: Use dynamic property lookup based on parameters when there is rhs type information.And parameters are:
   passed - Scenario: Use dynamic property lookup based on parameters when there is rhs type information.When executing query:
   passed - Scenario: Use dynamic property lookup based on parameters when there is rhs type information.Then the result should be:
   passed - Scenario: Use dynamic property lookup based on parameters when there is rhs type information.And no side effects
  Scenario: Fail at runtime when attempting to index with an Int into a Map
   passed - Scenario: Fail at runtime when attempting to index with an Int into a Map.Given any graph
   passed - Scenario: Fail at runtime when attempting to index with an Int into a Map.And parameters are:
   passed - Scenario: Fail at runtime when attempting to index with an Int into a Map.When executing query:
   passed - Scenario: Fail at runtime when attempting to index with an Int into a Map.Then a TypeError should be raised at runtime: MapElementAccessByNonString
  Scenario: Fail at runtime when trying to index into a map with a non-string
   passed - Scenario: Fail at runtime when trying to index into a map with a non-string.Given any graph
   passed - Scenario: Fail at runtime when trying to index into a map with a non-string.And parameters are:
   passed - Scenario: Fail at runtime when trying to index into a map with a non-string.When executing query:
   passed - Scenario: Fail at runtime when trying to index into a map with a non-string.Then a TypeError should be raised at runtime: MapElementAccessByNonString
  Scenario: Fail at runtime when trying to index something which is not a map or list
   passed - Scenario: Fail at runtime when trying to index something which is not a map or list.Given any graph
   passed - Scenario: Fail at runtime when trying to index something which is not a map or list.And parameters are:
   passed - Scenario: Fail at runtime when trying to index something which is not a map or list.When executing query:
   passed - Scenario: Fail at runtime when trying to index something which is not a map or list.Then a TypeError should be raised at runtime: InvalidElementAccess
FunctionsAcceptanceTest
 Feature: FunctionsAcceptance
  Scenario: Run coalesce
   passed - Scenario: Run coalesce.Given an empty graph
   passed - Scenario: Run coalesce.And having executed:
   passed - Scenario: Run coalesce.When executing query:
   passed - Scenario: Run coalesce.Then the result should be:
   passed - Scenario: Run coalesce.And no side effects
  Scenario: Functions should return null if they get path containing unbound
   passed - Scenario: Functions should return null if they get path containing unbound.Given any graph
   passed - Scenario: Functions should return null if they get path containing unbound.When executing query:
   error - Scenario: Functions should return null if they get path containing unbound.Then the result should be:
   ignored - Scenario: Functions should return null if they get path containing unbound.And no side effects
  Scenario: `split()`
   passed - )`.Given any graph(Scenario: `split
   passed - )`.When executing query:(Scenario: `split
   passed - )`.Then the result should be:(Scenario: `split
   passed - )`.And no side effects(Scenario: `split
  Scenario: `properties()` on a node
   passed - )` on a node.Given an empty graph(Scenario: `properties
   passed - )` on a node.And having executed:(Scenario: `properties
   passed - )` on a node.When executing query:(Scenario: `properties
   passed - )` on a node.Then the result should be:(Scenario: `properties
   passed - )` on a node.And no side effects(Scenario: `properties
  Scenario: `properties()` on a relationship
   passed - )` on a relationship.Given an empty graph(Scenario: `properties
   passed - )` on a relationship.And having executed:(Scenario: `properties
   passed - )` on a relationship.When executing query:(Scenario: `properties
   passed - )` on a relationship.Then the result should be:(Scenario: `properties
   passed - )` on a relationship.And no side effects(Scenario: `properties
  Scenario: `properties()` on a map
   passed - )` on a map.Given any graph(Scenario: `properties
   passed - )` on a map.When executing query:(Scenario: `properties
   passed - )` on a map.Then the result should be:(Scenario: `properties
   passed - )` on a map.And no side effects(Scenario: `properties
  Scenario: `properties()` failing on an integer literal
   passed - )` failing on an integer literal.Given any graph(Scenario: `properties
   passed - )` failing on an integer literal.When executing query:(Scenario: `properties
   passed - )` failing on an integer literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: `properties
  Scenario: `properties()` failing on a string literal
   passed - )` failing on a string literal.Given any graph(Scenario: `properties
   passed - )` failing on a string literal.When executing query:(Scenario: `properties
   passed - )` failing on a string literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: `properties
  Scenario: `properties()` failing on a list of booleans
   passed - )` failing on a list of booleans.Given any graph(Scenario: `properties
   passed - )` failing on a list of booleans.When executing query:(Scenario: `properties
   passed - )` failing on a list of booleans.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: `properties
  Scenario: `properties()` on null
   passed - )` on null.Given any graph(Scenario: `properties
   passed - )` on null.When executing query:(Scenario: `properties
   passed - )` on null.Then the result should be:(Scenario: `properties
   passed - )` on null.And no side effects(Scenario: `properties
  Scenario: `reverse()`
   passed - )`.Given any graph(Scenario: `reverse
   passed - )`.When executing query:(Scenario: `reverse
   passed - )`.Then the result should be:(Scenario: `reverse
   passed - )`.And no side effects(Scenario: `reverse
  Scenario: `exists()` with dynamic property lookup
   passed - )` with dynamic property lookup.Given an empty graph(Scenario: `exists
   passed - )` with dynamic property lookup.And having executed:(Scenario: `exists
   passed - )` with dynamic property lookup.When executing query:(Scenario: `exists
   passed - )` with dynamic property lookup.Then the result should be:(Scenario: `exists
   passed - )` with dynamic property lookup.And no side effects(Scenario: `exists
  Scenario Outline: `exists()` with literal maps
   Examples: 
    | {name: 'Mats', name2: 'Pontus'} | true |
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.Given any graph
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.When executing query:
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.Then the result should be:
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.And no side effects
    | {name: null} | false |
   passed - | {name: null} | false |.Given any graph
   passed - | {name: null} | false |.When executing query:
   passed - | {name: null} | false |.Then the result should be:
   passed - | {name: null} | false |.And no side effects
    | {notName: 0, notName2: null} | false |
   passed - | {notName: 0, notName2: null} | false |.Given any graph
   passed - | {notName: 0, notName2: null} | false |.When executing query:
   passed - | {notName: 0, notName2: null} | false |.Then the result should be:
   passed - | {notName: 0, notName2: null} | false |.And no side effects
  Scenario Outline: IS NOT NULL with literal maps
   Examples: 
    | {name: 'Mats', name2: 'Pontus'} | true |
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.Given any graph
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.When executing query:
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.Then the result should be:
   passed - | {name: 'Mats', name2: 'Pontus'} | true |.And no side effects
    | {name: null} | false |
   passed - | {name: null} | false |.Given any graph
   passed - | {name: null} | false |.When executing query:
   passed - | {name: null} | false |.Then the result should be:
   passed - | {name: null} | false |.And no side effects
    | {notName: 0, notName2: null} | false |
   passed - | {notName: 0, notName2: null} | false |.Given any graph
   passed - | {notName: 0, notName2: null} | false |.When executing query:
   passed - | {notName: 0, notName2: null} | false |.Then the result should be:
   passed - | {notName: 0, notName2: null} | false |.And no side effects
  Scenario Outline: `percentileDisc()`
   Examples: 
    0 |
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
    0 |
   skipped - 0 |.Given an empty graph
   skipped - 0 |.And having executed:
   skipped - 0 |.And parameters are:
   skipped - 0 |.When executing query:
   skipped - 0 |.Then the result should be:
   skipped - 0 |.And no side effects
    0 |
   skipped - 0 |.Given an empty graph
   skipped - 0 |.And having executed:
   skipped - 0 |.And parameters are:
   skipped - 0 |.When executing query:
   skipped - 0 |.Then the result should be:
   skipped - 0 |.And no side effects
  Scenario Outline: `percentileCont()`
   Examples: 
    0 |
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.And parameters are:
   passed - 0 |.When executing query:
   passed - 0 |.Then the result should be:
   passed - 0 |.And no side effects
    0 |
   skipped - 0 |.Given an empty graph
   skipped - 0 |.And having executed:
   skipped - 0 |.And parameters are:
   skipped - 0 |.When executing query:
   skipped - 0 |.Then the result should be:
   skipped - 0 |.And no side effects
    0 |
   skipped - 0 |.Given an empty graph
   skipped - 0 |.And having executed:
   skipped - 0 |.And parameters are:
   skipped - 0 |.When executing query:
   skipped - 0 |.Then the result should be:
   skipped - 0 |.And no side effects
  Scenario Outline: `percentileCont()` failing on bad arguments
   Examples: 
    | 1000 |
   passed - | 1000 |.Given an empty graph
   passed - | 1000 |.And having executed:
   passed - | 1000 |.And parameters are:
   passed - | 1000 |.When executing query:
   passed - | 1000 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
    | -1 |
   passed - | -1 |.Given an empty graph
   passed - | -1 |.And having executed:
   passed - | -1 |.And parameters are:
   passed - | -1 |.When executing query:
   passed - | -1 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
    1 |
   passed - 1 |.Given an empty graph
   passed - 1 |.And having executed:
   passed - 1 |.And parameters are:
   passed - 1 |.When executing query:
   passed - 1 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
  Scenario Outline: `percentileDisc()` failing on bad arguments
   Examples: 
    | 1000 |
   passed - | 1000 |.Given an empty graph
   passed - | 1000 |.And having executed:
   passed - | 1000 |.And parameters are:
   passed - | 1000 |.When executing query:
   passed - | 1000 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
    | -1 |
   passed - | -1 |.Given an empty graph
   passed - | -1 |.And having executed:
   passed - | -1 |.And parameters are:
   passed - | -1 |.When executing query:
   passed - | -1 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
    1 |
   passed - 1 |.Given an empty graph
   passed - 1 |.And having executed:
   passed - 1 |.And parameters are:
   passed - 1 |.When executing query:
   passed - 1 |.Then a ArgumentError should be raised at runtime: NumberOutOfRange
  Scenario: `percentileDisc()` failing in more involved query
   passed - )` failing in more involved query.Given an empty graph(Scenario: `percentileDisc
   passed - )` failing in more involved query.And having executed:(Scenario: `percentileDisc
   passed - )` failing in more involved query.When executing query:(Scenario: `percentileDisc
   passed - )` failing in more involved query.Then a ArgumentError should be raised at runtime: NumberOutOfRange(Scenario: `percentileDisc
  Scenario: `type()`
   passed - )`.Given an empty graph(Scenario: `type
   passed - )`.And having executed:(Scenario: `type
   passed - )`.When executing query:(Scenario: `type
   passed - )`.Then the result should be:(Scenario: `type
   passed - )`.And no side effects(Scenario: `type
  Scenario: `type()` on two relationships
   passed - )` on two relationships.Given an empty graph(Scenario: `type
   passed - )` on two relationships.And having executed:(Scenario: `type
   passed - )` on two relationships.When executing query:(Scenario: `type
   passed - )` on two relationships.Then the result should be:(Scenario: `type
   passed - )` on two relationships.And no side effects(Scenario: `type
  Scenario: `type()` on null relationship
   passed - )` on null relationship.Given an empty graph(Scenario: `type
   passed - )` on null relationship.And having executed:(Scenario: `type
   passed - )` on null relationship.When executing query:(Scenario: `type
   passed - )` on null relationship.Then the result should be:(Scenario: `type
   passed - )` on null relationship.And no side effects(Scenario: `type
  Scenario: `type()` on mixed null and non-null relationships
   passed - )` on mixed null and non-null relationships.Given an empty graph(Scenario: `type
   passed - )` on mixed null and non-null relationships.And having executed:(Scenario: `type
   passed - )` on mixed null and non-null relationships.When executing query:(Scenario: `type
   passed - )` on mixed null and non-null relationships.Then the result should be:(Scenario: `type
   passed - )` on mixed null and non-null relationships.And no side effects(Scenario: `type
  Scenario: `type()` handling Any type
   passed - )` handling Any type.Given an empty graph(Scenario: `type
   passed - )` handling Any type.And having executed:(Scenario: `type
   passed - )` handling Any type.When executing query:(Scenario: `type
   passed - )` handling Any type.Then the result should be:(Scenario: `type
   passed - )` handling Any type.And no side effects(Scenario: `type
  Scenario Outline: `type()` failing on invalid arguments
   Examples: 
    | 0 |
   passed - | 0 |.Given an empty graph
   passed - | 0 |.And having executed:
   passed - | 0 |.When executing query:
   passed - | 0 |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    0 |
   passed - 0 |.Given an empty graph
   passed - 0 |.And having executed:
   passed - 0 |.When executing query:
   passed - 0 |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | true |
   passed - | true |.Given an empty graph
   passed - | true |.And having executed:
   passed - | true |.When executing query:
   passed - | true |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | '' |
   passed - | '' |.Given an empty graph
   passed - | '' |.And having executed:
   passed - | '' |.When executing query:
   passed - | '' |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | [] |
   passed - | [] |.Given an empty graph
   passed - | [] |.And having executed:
   passed - | [] |.When executing query:
   passed - | [] |.Then a TypeError should be raised at runtime: InvalidArgumentValue
  Scenario: `labels()` should accept type Any
   passed - )` should accept type Any.Given an empty graph(Scenario: `labels
   passed - )` should accept type Any.And having executed:(Scenario: `labels
   passed - )` should accept type Any.When executing query:(Scenario: `labels
   passed - )` should accept type Any.Then the result should be (ignoring element order for lists):(Scenario: `labels
   passed - )` should accept type Any.And no side effects(Scenario: `labels
  Scenario: `labels()` failing on a path
   passed - )` failing on a path.Given an empty graph(Scenario: `labels
   passed - )` failing on a path.And having executed:(Scenario: `labels
   passed - )` failing on a path.When executing query:(Scenario: `labels
   passed - )` failing on a path.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: `labels
  Scenario: `labels()` failing on invalid arguments
   passed - )` failing on invalid arguments.Given an empty graph(Scenario: `labels
   passed - )` failing on invalid arguments.And having executed:(Scenario: `labels
   passed - )` failing on invalid arguments.When executing query:(Scenario: `labels
   passed - )` failing on invalid arguments.Then a TypeError should be raised at runtime: InvalidArgumentValue(Scenario: `labels
  Scenario: `exists()` is case insensitive
   passed - )` is case insensitive.Given an empty graph(Scenario: `exists
   passed - )` is case insensitive.And having executed:(Scenario: `exists
   passed - )` is case insensitive.When executing query:(Scenario: `exists
   passed - )` is case insensitive.Then the result should be:(Scenario: `exists
   passed - )` is case insensitive.And no side effects(Scenario: `exists
JoinAcceptanceTest
 Feature: ValueHashJoinAcceptance
  Scenario: Find friends of others
   passed - Scenario: Find friends of others.Given an empty graph
   passed - Scenario: Find friends of others.And having executed:
   passed - Scenario: Find friends of others.When executing query:
   passed - Scenario: Find friends of others.Then the result should be:
   passed - Scenario: Find friends of others.And no side effects
  Scenario: Should only join when matching
   passed - Scenario: Should only join when matching.Given an empty graph
   error - Scenario: Should only join when matching.And having executed:
   ignored - Scenario: Should only join when matching.When executing query:
   ignored - Scenario: Should only join when matching.Then the result should be:
   ignored - Scenario: Should only join when matching.And no side effects
KeysAcceptanceTest
 Feature: KeysAcceptance
  Scenario: Using `keys()` on a single node, non-empty result
   passed - )` on a single node, non-empty result.Given an empty graph(Scenario: Using `keys
   passed - )` on a single node, non-empty result.And having executed:(Scenario: Using `keys
   passed - )` on a single node, non-empty result.When executing query:(Scenario: Using `keys
   passed - )` on a single node, non-empty result.Then the result should be:(Scenario: Using `keys
   passed - )` on a single node, non-empty result.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on multiple nodes, non-empty result
   passed - )` on multiple nodes, non-empty result.Given an empty graph(Scenario: Using `keys
   passed - )` on multiple nodes, non-empty result.And having executed:(Scenario: Using `keys
   passed - )` on multiple nodes, non-empty result.When executing query:(Scenario: Using `keys
   passed - )` on multiple nodes, non-empty result.Then the result should be:(Scenario: Using `keys
   passed - )` on multiple nodes, non-empty result.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on a single node, empty result
   passed - )` on a single node, empty result.Given an empty graph(Scenario: Using `keys
   passed - )` on a single node, empty result.And having executed:(Scenario: Using `keys
   passed - )` on a single node, empty result.When executing query:(Scenario: Using `keys
   passed - )` on a single node, empty result.Then the result should be:(Scenario: Using `keys
   passed - )` on a single node, empty result.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on an optionally matched node
   passed - )` on an optionally matched node.Given an empty graph(Scenario: Using `keys
   passed - )` on an optionally matched node.And having executed:(Scenario: Using `keys
   passed - )` on an optionally matched node.When executing query:(Scenario: Using `keys
   passed - )` on an optionally matched node.Then the result should be:(Scenario: Using `keys
   passed - )` on an optionally matched node.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on a relationship, non-empty result
   passed - )` on a relationship, non-empty result.Given an empty graph(Scenario: Using `keys
   passed - )` on a relationship, non-empty result.And having executed:(Scenario: Using `keys
   passed - )` on a relationship, non-empty result.When executing query:(Scenario: Using `keys
   passed - )` on a relationship, non-empty result.Then the result should be:(Scenario: Using `keys
   passed - )` on a relationship, non-empty result.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on a relationship, empty result
   passed - )` on a relationship, empty result.Given an empty graph(Scenario: Using `keys
   passed - )` on a relationship, empty result.And having executed:(Scenario: Using `keys
   passed - )` on a relationship, empty result.When executing query:(Scenario: Using `keys
   passed - )` on a relationship, empty result.Then the result should be:(Scenario: Using `keys
   passed - )` on a relationship, empty result.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on an optionally matched relationship
   passed - )` on an optionally matched relationship.Given an empty graph(Scenario: Using `keys
   passed - )` on an optionally matched relationship.And having executed:(Scenario: Using `keys
   passed - )` on an optionally matched relationship.When executing query:(Scenario: Using `keys
   passed - )` on an optionally matched relationship.Then the result should be:(Scenario: Using `keys
   passed - )` on an optionally matched relationship.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on a literal map
   passed - )` on a literal map.Given any graph(Scenario: Using `keys
   passed - )` on a literal map.When executing query:(Scenario: Using `keys
   passed - )` on a literal map.Then the result should be (ignoring element order for lists):(Scenario: Using `keys
   passed - )` on a literal map.And no side effects(Scenario: Using `keys
  Scenario: Using `keys()` on a parameter map
   passed - )` on a parameter map.Given any graph(Scenario: Using `keys
   passed - )` on a parameter map.And parameters are:(Scenario: Using `keys
   passed - )` on a parameter map.When executing query:(Scenario: Using `keys
   passed - )` on a parameter map.Then the result should be (ignoring element order for lists):(Scenario: Using `keys
   passed - )` on a parameter map.And no side effects(Scenario: Using `keys
LabelsAcceptanceTest
 Feature: LabelsAcceptance
  Scenario: Adding a single label
   passed - Scenario: Adding a single label.Given an empty graph
   passed - Scenario: Adding a single label.And having executed:
   passed - Scenario: Adding a single label.When executing query:
   passed - Scenario: Adding a single label.Then the result should be:
   passed - Scenario: Adding a single label.And the side effects should be:
  Scenario: Ignore space before colon
   passed - Scenario: Ignore space before colon.Given an empty graph
   passed - Scenario: Ignore space before colon.And having executed:
   passed - Scenario: Ignore space before colon.When executing query:
   passed - Scenario: Ignore space before colon.Then the result should be:
   passed - Scenario: Ignore space before colon.And the side effects should be:
  Scenario: Adding multiple labels
   passed - Scenario: Adding multiple labels.Given an empty graph
   passed - Scenario: Adding multiple labels.And having executed:
   passed - Scenario: Adding multiple labels.When executing query:
   passed - Scenario: Adding multiple labels.Then the result should be:
   passed - Scenario: Adding multiple labels.And the side effects should be:
  Scenario: Ignoring intermediate whitespace 1
   passed - Scenario: Ignoring intermediate whitespace 1.Given an empty graph
   passed - Scenario: Ignoring intermediate whitespace 1.And having executed:
   passed - Scenario: Ignoring intermediate whitespace 1.When executing query:
   passed - Scenario: Ignoring intermediate whitespace 1.Then the result should be:
   passed - Scenario: Ignoring intermediate whitespace 1.And the side effects should be:
  Scenario: Ignoring intermediate whitespace 2
   passed - Scenario: Ignoring intermediate whitespace 2.Given an empty graph
   passed - Scenario: Ignoring intermediate whitespace 2.And having executed:
   passed - Scenario: Ignoring intermediate whitespace 2.When executing query:
   passed - Scenario: Ignoring intermediate whitespace 2.Then the result should be:
   passed - Scenario: Ignoring intermediate whitespace 2.And the side effects should be:
  Scenario: Creating node without label
   passed - Scenario: Creating node without label.Given an empty graph
   passed - Scenario: Creating node without label.When executing query:
   passed - Scenario: Creating node without label.Then the result should be:
   passed - Scenario: Creating node without label.And the side effects should be:
  Scenario: Creating node with two labels
   passed - Scenario: Creating node with two labels.Given an empty graph
   passed - Scenario: Creating node with two labels.When executing query:
   passed - Scenario: Creating node with two labels.Then the result should be:
   passed - Scenario: Creating node with two labels.And the side effects should be:
  Scenario: Ignore space when creating node with labels
   passed - Scenario: Ignore space when creating node with labels.Given an empty graph
   passed - Scenario: Ignore space when creating node with labels.When executing query:
   passed - Scenario: Ignore space when creating node with labels.Then the result should be:
   passed - Scenario: Ignore space when creating node with labels.And the side effects should be:
  Scenario: Create node with label in pattern
   passed - Scenario: Create node with label in pattern.Given an empty graph
   passed - Scenario: Create node with label in pattern.When executing query:
   passed - Scenario: Create node with label in pattern.Then the result should be:
   passed - Scenario: Create node with label in pattern.And the side effects should be:
  Scenario: Fail when adding a new label predicate on a node that is already bound 1
   passed - Scenario: Fail when adding a new label predicate on a node that is already bound 1.Given an empty graph
   passed - Scenario: Fail when adding a new label predicate on a node that is already bound 1.When executing query:
   ignored - Scenario: Fail when adding a new label predicate on a node that is already bound 1.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Fail when adding new label predicate on a node that is already bound 2
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 2.Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 2.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 2.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Fail when adding new label predicate on a node that is already bound 3
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 3.Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 3.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 3.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Fail when adding new label predicate on a node that is already bound 4
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 4.Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 4.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 4.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Fail when adding new label predicate on a node that is already bound 5
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 5.Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 5.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 5.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Using `labels()` in return clauses
   passed - )` in return clauses.Given an empty graph(Scenario: Using `labels
   passed - )` in return clauses.And having executed:(Scenario: Using `labels
   passed - )` in return clauses.When executing query:(Scenario: Using `labels
   passed - )` in return clauses.Then the result should be:(Scenario: Using `labels
   passed - )` in return clauses.And no side effects(Scenario: Using `labels
  Scenario: Removing a label
   passed - Scenario: Removing a label.Given an empty graph
   passed - Scenario: Removing a label.And having executed:
   passed - Scenario: Removing a label.When executing query:
   passed - Scenario: Removing a label.Then the result should be:
   passed - Scenario: Removing a label.And the side effects should be:
  Scenario: Removing a non-existent label
   passed - Scenario: Removing a non-existent label.Given an empty graph
   passed - Scenario: Removing a non-existent label.And having executed:
   passed - Scenario: Removing a non-existent label.When executing query:
   passed - Scenario: Removing a non-existent label.Then the result should be:
   passed - Scenario: Removing a non-existent label.And no side effects
LargeCreateQueryTest
 Feature: LargeCreateQuery
  Scenario: Generate the movie graph correctly
   passed - Scenario: Generate the movie graph correctly.Given an empty graph
   passed - Scenario: Generate the movie graph correctly.When executing query:
   passed - Scenario: Generate the movie graph correctly.Then the result should be empty
   passed - Scenario: Generate the movie graph correctly.And the side effects should be:
  Scenario: Many CREATE clauses
   passed - Scenario: Many CREATE clauses.Given an empty graph
   passed - Scenario: Many CREATE clauses.When executing query:
   passed - Scenario: Many CREATE clauses.Then the result should be empty
   passed - Scenario: Many CREATE clauses.And the side effects should be:
LargeIntegerEqualityTest
 Feature: LargeIntegerEquality
  Scenario: Does not lose precision
   passed - Scenario: Does not lose precision.Given an empty graph
   passed - Scenario: Does not lose precision.And having executed:
   passed - Scenario: Does not lose precision.When executing query:
   passed - Scenario: Does not lose precision.Then the result should be:
   passed - Scenario: Does not lose precision.And no side effects
  Scenario: Handling inlined equality of large integer
   passed - Scenario: Handling inlined equality of large integer.Given an empty graph
   passed - Scenario: Handling inlined equality of large integer.And having executed:
   passed - Scenario: Handling inlined equality of large integer.When executing query:
   passed - Scenario: Handling inlined equality of large integer.Then the result should be:
   passed - Scenario: Handling inlined equality of large integer.And no side effects
  Scenario: Handling explicit equality of large integer
   passed - Scenario: Handling explicit equality of large integer.Given an empty graph
   passed - Scenario: Handling explicit equality of large integer.And having executed:
   passed - Scenario: Handling explicit equality of large integer.When executing query:
   passed - Scenario: Handling explicit equality of large integer.Then the result should be:
   passed - Scenario: Handling explicit equality of large integer.And no side effects
  Scenario: Handling inlined equality of large integer, non-equal values
   passed - Scenario: Handling inlined equality of large integer, non-equal values.Given an empty graph
   passed - Scenario: Handling inlined equality of large integer, non-equal values.And having executed:
   passed - Scenario: Handling inlined equality of large integer, non-equal values.When executing query:
   passed - Scenario: Handling inlined equality of large integer, non-equal values.Then the result should be:
   passed - Scenario: Handling inlined equality of large integer, non-equal values.And no side effects
  Scenario: Handling explicit equality of large integer, non-equal values
   passed - Scenario: Handling explicit equality of large integer, non-equal values.Given an empty graph
   passed - Scenario: Handling explicit equality of large integer, non-equal values.And having executed:
   passed - Scenario: Handling explicit equality of large integer, non-equal values.When executing query:
   passed - Scenario: Handling explicit equality of large integer, non-equal values.Then the result should be:
   passed - Scenario: Handling explicit equality of large integer, non-equal values.And no side effects
ListComprehensionTest
 Feature: ListComprehension
  Scenario: Returning a list comprehension
   passed - Scenario: Returning a list comprehension.Given an empty graph
   passed - Scenario: Returning a list comprehension.And having executed:
   passed - Scenario: Returning a list comprehension.When executing query:
   passed - Scenario: Returning a list comprehension.Then the result should be:
   passed - Scenario: Returning a list comprehension.And no side effects
  Scenario: Using a list comprehension in a WITH
   passed - Scenario: Using a list comprehension in a WITH.Given an empty graph
   passed - Scenario: Using a list comprehension in a WITH.And having executed:
   passed - Scenario: Using a list comprehension in a WITH.When executing query:
   failed - Scenario: Using a list comprehension in a WITH.Then the result should be:
   ignored - Scenario: Using a list comprehension in a WITH.And no side effects
  Scenario: Using a list comprehension in a WHERE
   passed - Scenario: Using a list comprehension in a WHERE.Given an empty graph
   passed - Scenario: Using a list comprehension in a WHERE.And having executed:
   passed - Scenario: Using a list comprehension in a WHERE.When executing query:
   passed - Scenario: Using a list comprehension in a WHERE.Then the result should be:
   passed - Scenario: Using a list comprehension in a WHERE.And no side effects
LiteralsTest
 Feature: Literals
  Scenario: Return an integer
   passed - Scenario: Return an integer.Given any graph
   passed - Scenario: Return an integer.When executing query:
   passed - Scenario: Return an integer.Then the result should be:
   passed - Scenario: Return an integer.And no side effects
  Scenario: Return a float
   passed - Scenario: Return a float.Given any graph
   passed - Scenario: Return a float.When executing query:
   passed - Scenario: Return a float.Then the result should be:
   passed - Scenario: Return a float.And no side effects
  Scenario: Return a float in exponent form
   passed - Scenario: Return a float in exponent form.Given any graph
   passed - Scenario: Return a float in exponent form.When executing query:
   passed - Scenario: Return a float in exponent form.Then the result should be:
   passed - Scenario: Return a float in exponent form.And no side effects
  Scenario: Return a boolean
   passed - Scenario: Return a boolean.Given any graph
   passed - Scenario: Return a boolean.When executing query:
   passed - Scenario: Return a boolean.Then the result should be:
   passed - Scenario: Return a boolean.And no side effects
  Scenario: Return a single-quoted string
   passed - Scenario: Return a single-quoted string.Given any graph
   passed - Scenario: Return a single-quoted string.When executing query:
   passed - Scenario: Return a single-quoted string.Then the result should be:
   passed - Scenario: Return a single-quoted string.And no side effects
  Scenario: Return a double-quoted string
   passed - Scenario: Return a double-quoted string.Given any graph
   passed - Scenario: Return a double-quoted string.When executing query:
   passed - Scenario: Return a double-quoted string.Then the result should be:
   passed - Scenario: Return a double-quoted string.And no side effects
  Scenario: Return null
   passed - Scenario: Return null.Given any graph
   passed - Scenario: Return null.When executing query:
   passed - Scenario: Return null.Then the result should be:
   passed - Scenario: Return null.And no side effects
  Scenario: Return an empty list
   passed - Scenario: Return an empty list.Given any graph
   passed - Scenario: Return an empty list.When executing query:
   passed - Scenario: Return an empty list.Then the result should be:
   passed - Scenario: Return an empty list.And no side effects
  Scenario: Return a nonempty list
   passed - Scenario: Return a nonempty list.Given any graph
   passed - Scenario: Return a nonempty list.When executing query:
   passed - Scenario: Return a nonempty list.Then the result should be:
   passed - Scenario: Return a nonempty list.And no side effects
  Scenario: Return an empty map
   passed - Scenario: Return an empty map.Given any graph
   passed - Scenario: Return an empty map.When executing query:
   passed - Scenario: Return an empty map.Then the result should be:
   passed - Scenario: Return an empty map.And no side effects
  Scenario: Return a nonempty map
   passed - Scenario: Return a nonempty map.Given any graph
   passed - Scenario: Return a nonempty map.When executing query:
   passed - Scenario: Return a nonempty map.Then the result should be:
   passed - Scenario: Return a nonempty map.And no side effects
MatchAcceptance2Test
 Feature: MatchAcceptance2
  Scenario: Do not return non-existent nodes
   passed - Scenario: Do not return non-existent nodes.Given an empty graph
   passed - Scenario: Do not return non-existent nodes.When executing query:
   passed - Scenario: Do not return non-existent nodes.Then the result should be:
   passed - Scenario: Do not return non-existent nodes.And no side effects
  Scenario: Do not return non-existent relationships
   passed - Scenario: Do not return non-existent relationships.Given an empty graph
   passed - Scenario: Do not return non-existent relationships.When executing query:
   passed - Scenario: Do not return non-existent relationships.Then the result should be:
   passed - Scenario: Do not return non-existent relationships.And no side effects
  Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false.Given an empty graph
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false.And having executed:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false.When executing query:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false.Then the result should be:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false.And no side effects
  Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true.Given an empty graph
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true.And having executed:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true.When executing query:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true.Then the result should be:
   passed - Scenario: Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true.And no side effects
  Scenario: Aggregation with named paths
   passed - Scenario: Aggregation with named paths.Given an empty graph
   passed - Scenario: Aggregation with named paths.And having executed:
   passed - Scenario: Aggregation with named paths.When executing query:
   error - Scenario: Aggregation with named paths.Then the result should be:
   ignored - Scenario: Aggregation with named paths.And no side effects
  Scenario: Zero-length variable length pattern in the middle of the pattern
   passed - Scenario: Zero-length variable length pattern in the middle of the pattern.Given an empty graph
   passed - Scenario: Zero-length variable length pattern in the middle of the pattern.And having executed:
   passed - Scenario: Zero-length variable length pattern in the middle of the pattern.When executing query:
   error - Scenario: Zero-length variable length pattern in the middle of the pattern.Then the result should be:
   ignored - Scenario: Zero-length variable length pattern in the middle of the pattern.And no side effects
  Scenario: Simple variable length pattern
   passed - Scenario: Simple variable length pattern.Given an empty graph
   passed - Scenario: Simple variable length pattern.And having executed:
   passed - Scenario: Simple variable length pattern.When executing query:
   error - Scenario: Simple variable length pattern.Then the result should be:
   ignored - Scenario: Simple variable length pattern.And no side effects
  Scenario: Variable length relationship without lower bound
   passed - Scenario: Variable length relationship without lower bound.Given an empty graph
   passed - Scenario: Variable length relationship without lower bound.And having executed:
   passed - Scenario: Variable length relationship without lower bound.When executing query:
   error - Scenario: Variable length relationship without lower bound.Then the result should be:
   ignored - Scenario: Variable length relationship without lower bound.And no side effects
  Scenario: Variable length relationship without bounds
   passed - Scenario: Variable length relationship without bounds.Given an empty graph
   passed - Scenario: Variable length relationship without bounds.And having executed:
   passed - Scenario: Variable length relationship without bounds.When executing query:
   error - Scenario: Variable length relationship without bounds.Then the result should be:
   ignored - Scenario: Variable length relationship without bounds.And no side effects
  Scenario: Returning bound nodes that are not part of the pattern
   passed - Scenario: Returning bound nodes that are not part of the pattern.Given an empty graph
   passed - Scenario: Returning bound nodes that are not part of the pattern.And having executed:
   passed - Scenario: Returning bound nodes that are not part of the pattern.When executing query:
   passed - Scenario: Returning bound nodes that are not part of the pattern.Then the result should be:
   passed - Scenario: Returning bound nodes that are not part of the pattern.And no side effects
  Scenario: Two bound nodes pointing to the same node
   passed - Scenario: Two bound nodes pointing to the same node.Given an empty graph
   passed - Scenario: Two bound nodes pointing to the same node.And having executed:
   passed - Scenario: Two bound nodes pointing to the same node.When executing query:
   error - Scenario: Two bound nodes pointing to the same node.Then the result should be:
   ignored - Scenario: Two bound nodes pointing to the same node.And no side effects
  Scenario: Three bound nodes pointing to the same node
   passed - Scenario: Three bound nodes pointing to the same node.Given an empty graph
   passed - Scenario: Three bound nodes pointing to the same node.And having executed:
   passed - Scenario: Three bound nodes pointing to the same node.When executing query:
   failed - Scenario: Three bound nodes pointing to the same node.Then the result should be:
   ignored - Scenario: Three bound nodes pointing to the same node.And no side effects
  Scenario: Three bound nodes pointing to the same node with extra connections
   passed - Scenario: Three bound nodes pointing to the same node with extra connections.Given an empty graph
   passed - Scenario: Three bound nodes pointing to the same node with extra connections.And having executed:
   passed - Scenario: Three bound nodes pointing to the same node with extra connections.When executing query:
   failed - Scenario: Three bound nodes pointing to the same node with extra connections.Then the result should be:
   ignored - Scenario: Three bound nodes pointing to the same node with extra connections.And no side effects
  Scenario: MATCH with OPTIONAL MATCH in longer pattern
   passed - Scenario: MATCH with OPTIONAL MATCH in longer pattern.Given an empty graph
   passed - Scenario: MATCH with OPTIONAL MATCH in longer pattern.And having executed:
   passed - Scenario: MATCH with OPTIONAL MATCH in longer pattern.When executing query:
   passed - Scenario: MATCH with OPTIONAL MATCH in longer pattern.Then the result should be:
   passed - Scenario: MATCH with OPTIONAL MATCH in longer pattern.And no side effects
  Scenario: Optionally matching named paths with single and variable length patterns
   passed - Scenario: Optionally matching named paths with single and variable length patterns.Given an empty graph
   passed - Scenario: Optionally matching named paths with single and variable length patterns.And having executed:
   passed - Scenario: Optionally matching named paths with single and variable length patterns.When executing query:
   failed - Scenario: Optionally matching named paths with single and variable length patterns.Then the result should be:
   ignored - Scenario: Optionally matching named paths with single and variable length patterns.And no side effects
  Scenario: Matching variable length patterns from a bound node
   passed - Scenario: Matching variable length patterns from a bound node.Given an empty graph
   passed - Scenario: Matching variable length patterns from a bound node.And having executed:
   passed - Scenario: Matching variable length patterns from a bound node.When executing query:
   error - Scenario: Matching variable length patterns from a bound node.Then the result should be (ignoring element order for lists):
   ignored - Scenario: Matching variable length patterns from a bound node.And no side effects
  Scenario: MATCH and OPTIONAL MATCH on same pattern
   passed - Scenario: MATCH and OPTIONAL MATCH on same pattern.Given an empty graph
   passed - Scenario: MATCH and OPTIONAL MATCH on same pattern.And having executed:
   passed - Scenario: MATCH and OPTIONAL MATCH on same pattern.When executing query:
   error - Scenario: MATCH and OPTIONAL MATCH on same pattern.Then the result should be:
   ignored - Scenario: MATCH and OPTIONAL MATCH on same pattern.And no side effects
  Scenario: Matching using an undirected pattern
   passed - Scenario: Matching using an undirected pattern.Given an empty graph
   passed - Scenario: Matching using an undirected pattern.And having executed:
   passed - Scenario: Matching using an undirected pattern.When executing query:
   error - Scenario: Matching using an undirected pattern.Then the result should be:
   ignored - Scenario: Matching using an undirected pattern.And no side effects
  Scenario: Matching all nodes
   passed - Scenario: Matching all nodes.Given an empty graph
   passed - Scenario: Matching all nodes.And having executed:
   passed - Scenario: Matching all nodes.When executing query:
   passed - Scenario: Matching all nodes.Then the result should be:
   passed - Scenario: Matching all nodes.And no side effects
  Scenario: Comparing nodes for equality
   passed - Scenario: Comparing nodes for equality.Given an empty graph
   passed - Scenario: Comparing nodes for equality.And having executed:
   passed - Scenario: Comparing nodes for equality.When executing query:
   passed - Scenario: Comparing nodes for equality.Then the result should be:
   passed - Scenario: Comparing nodes for equality.And no side effects
  Scenario: Matching using self-referencing pattern returns no result
   passed - Scenario: Matching using self-referencing pattern returns no result.Given an empty graph
   passed - Scenario: Matching using self-referencing pattern returns no result.And having executed:
   passed - Scenario: Matching using self-referencing pattern returns no result.When executing query:
   failed - Scenario: Matching using self-referencing pattern returns no result.Then the result should be:
   ignored - Scenario: Matching using self-referencing pattern returns no result.And no side effects
  Scenario: Matching using relationship predicate with multiples of the same type
   passed - Scenario: Matching using relationship predicate with multiples of the same type.Given an empty graph
   passed - Scenario: Matching using relationship predicate with multiples of the same type.And having executed:
   passed - Scenario: Matching using relationship predicate with multiples of the same type.When executing query:
   passed - Scenario: Matching using relationship predicate with multiples of the same type.Then the result should be:
   passed - Scenario: Matching using relationship predicate with multiples of the same type.And no side effects
  Scenario: ORDER BY with LIMIT
   passed - Scenario: ORDER BY with LIMIT.Given an empty graph
   passed - Scenario: ORDER BY with LIMIT.And having executed:
   passed - Scenario: ORDER BY with LIMIT.When executing query:
   passed - Scenario: ORDER BY with LIMIT.Then the result should be, in order:
   passed - Scenario: ORDER BY with LIMIT.And no side effects
  Scenario: Simple node property predicate
   passed - Scenario: Simple node property predicate.Given an empty graph
   passed - Scenario: Simple node property predicate.And having executed:
   passed - Scenario: Simple node property predicate.When executing query:
   passed - Scenario: Simple node property predicate.Then the result should be:
   passed - Scenario: Simple node property predicate.And no side effects
  Scenario: Handling direction of named paths
   passed - Scenario: Handling direction of named paths.Given an empty graph
   passed - Scenario: Handling direction of named paths.And having executed:
   passed - Scenario: Handling direction of named paths.When executing query:
   passed - Scenario: Handling direction of named paths.Then the result should be:
   passed - Scenario: Handling direction of named paths.And no side effects
  Scenario: Simple OPTIONAL MATCH on empty graph
   passed - Scenario: Simple OPTIONAL MATCH on empty graph.Given an empty graph
   passed - Scenario: Simple OPTIONAL MATCH on empty graph.When executing query:
   passed - Scenario: Simple OPTIONAL MATCH on empty graph.Then the result should be:
   passed - Scenario: Simple OPTIONAL MATCH on empty graph.And no side effects
  Scenario: OPTIONAL MATCH with previously bound nodes
   passed - Scenario: OPTIONAL MATCH with previously bound nodes.Given an empty graph
   passed - Scenario: OPTIONAL MATCH with previously bound nodes.And having executed:
   passed - Scenario: OPTIONAL MATCH with previously bound nodes.When executing query:
   passed - Scenario: OPTIONAL MATCH with previously bound nodes.Then the result should be:
   passed - Scenario: OPTIONAL MATCH with previously bound nodes.And no side effects
  Scenario: `collect()` filtering nulls
   passed - )` filtering nulls.Given an empty graph(Scenario: `collect
   passed - )` filtering nulls.And having executed:(Scenario: `collect
   passed - )` filtering nulls.When executing query:(Scenario: `collect
   failed - )` filtering nulls.Then the result should be:(Scenario: `collect
   ignored - )` filtering nulls.And no side effects(Scenario: `collect
  Scenario: Multiple anonymous nodes in a pattern
   passed - Scenario: Multiple anonymous nodes in a pattern.Given an empty graph
   passed - Scenario: Multiple anonymous nodes in a pattern.And having executed:
   passed - Scenario: Multiple anonymous nodes in a pattern.When executing query:
   passed - Scenario: Multiple anonymous nodes in a pattern.Then the result should be:
   passed - Scenario: Multiple anonymous nodes in a pattern.And no side effects
  Scenario: Matching a relationship pattern using a label predicate
   passed - Scenario: Matching a relationship pattern using a label predicate.Given an empty graph
   passed - Scenario: Matching a relationship pattern using a label predicate.And having executed:
   passed - Scenario: Matching a relationship pattern using a label predicate.When executing query:
   failed - Scenario: Matching a relationship pattern using a label predicate.Then the result should be:
   ignored - Scenario: Matching a relationship pattern using a label predicate.And no side effects
  Scenario: Matching a relationship pattern using a label predicate on both sides
   passed - Scenario: Matching a relationship pattern using a label predicate on both sides.Given an empty graph
   passed - Scenario: Matching a relationship pattern using a label predicate on both sides.And having executed:
   passed - Scenario: Matching a relationship pattern using a label predicate on both sides.When executing query:
   failed - Scenario: Matching a relationship pattern using a label predicate on both sides.Then the result should be:
   ignored - Scenario: Matching a relationship pattern using a label predicate on both sides.And no side effects
  Scenario: Matching nodes using multiple labels
   passed - Scenario: Matching nodes using multiple labels.Given an empty graph
   passed - Scenario: Matching nodes using multiple labels.And having executed:
   passed - Scenario: Matching nodes using multiple labels.When executing query:
   passed - Scenario: Matching nodes using multiple labels.Then the result should be:
   passed - Scenario: Matching nodes using multiple labels.And no side effects
  Scenario: Returning label predicate expression
   passed - Scenario: Returning label predicate expression.Given an empty graph
   passed - Scenario: Returning label predicate expression.And having executed:
   passed - Scenario: Returning label predicate expression.When executing query:
   error - Scenario: Returning label predicate expression.Then the result should be:
   ignored - Scenario: Returning label predicate expression.And no side effects
  Scenario: Matching with many predicates and larger pattern
   passed - Scenario: Matching with many predicates and larger pattern.Given an empty graph
   passed - Scenario: Matching with many predicates and larger pattern.And having executed:
   passed - Scenario: Matching with many predicates and larger pattern.And parameters are:
   passed - Scenario: Matching with many predicates and larger pattern.When executing query:
   error - Scenario: Matching with many predicates and larger pattern.Then the result should be:
   ignored - Scenario: Matching with many predicates and larger pattern.And no side effects
  Scenario: Matching using a simple pattern with label predicate
   passed - Scenario: Matching using a simple pattern with label predicate.Given an empty graph
   passed - Scenario: Matching using a simple pattern with label predicate.And having executed:
   passed - Scenario: Matching using a simple pattern with label predicate.When executing query:
   passed - Scenario: Matching using a simple pattern with label predicate.Then the result should be:
   passed - Scenario: Matching using a simple pattern with label predicate.And no side effects
  Scenario: Matching disconnected patterns
   passed - Scenario: Matching disconnected patterns.Given an empty graph
   passed - Scenario: Matching disconnected patterns.And having executed:
   passed - Scenario: Matching disconnected patterns.When executing query:
   error - Scenario: Matching disconnected patterns.Then the result should be:
   ignored - Scenario: Matching disconnected patterns.And no side effects
  Scenario: Non-optional matches should not return nulls
   passed - Scenario: Non-optional matches should not return nulls.Given an empty graph
   passed - Scenario: Non-optional matches should not return nulls.And having executed:
   passed - Scenario: Non-optional matches should not return nulls.When executing query:
   error - Scenario: Non-optional matches should not return nulls.Then the result should be:
   ignored - Scenario: Non-optional matches should not return nulls.And no side effects
  Scenario: Handling cyclic patterns
   passed - Scenario: Handling cyclic patterns.Given an empty graph
   passed - Scenario: Handling cyclic patterns.And having executed:
   passed - Scenario: Handling cyclic patterns.When executing query:
   error - Scenario: Handling cyclic patterns.Then the result should be:
   ignored - Scenario: Handling cyclic patterns.And no side effects
  Scenario: Handling cyclic patterns when separated into two parts
   passed - Scenario: Handling cyclic patterns when separated into two parts.Given an empty graph
   passed - Scenario: Handling cyclic patterns when separated into two parts.And having executed:
   passed - Scenario: Handling cyclic patterns when separated into two parts.When executing query:
   failed - Scenario: Handling cyclic patterns when separated into two parts.Then the result should be:
   ignored - Scenario: Handling cyclic patterns when separated into two parts.And no side effects
  Scenario: Matching from null nodes should return no results owing to finding no matches
   passed - Scenario: Matching from null nodes should return no results owing to finding no matches.Given an empty graph
   passed - Scenario: Matching from null nodes should return no results owing to finding no matches.When executing query:
   error - Scenario: Matching from null nodes should return no results owing to finding no matches.Then the result should be:
   ignored - Scenario: Matching from null nodes should return no results owing to finding no matches.And no side effects
  Scenario: Matching from null nodes should return no results owing to matches being filtered out
   passed - Scenario: Matching from null nodes should return no results owing to matches being filtered out.Given an empty graph
   passed - Scenario: Matching from null nodes should return no results owing to matches being filtered out.And having executed:
   passed - Scenario: Matching from null nodes should return no results owing to matches being filtered out.When executing query:
   error - Scenario: Matching from null nodes should return no results owing to matches being filtered out.Then the result should be:
   ignored - Scenario: Matching from null nodes should return no results owing to matches being filtered out.And no side effects
  Scenario: Optionally matching from null nodes should return null
   passed - Scenario: Optionally matching from null nodes should return null.Given an empty graph
   passed - Scenario: Optionally matching from null nodes should return null.When executing query:
   passed - Scenario: Optionally matching from null nodes should return null.Then the result should be:
   passed - Scenario: Optionally matching from null nodes should return null.And no side effects
  Scenario: OPTIONAL MATCH returns null
   passed - Scenario: OPTIONAL MATCH returns null.Given an empty graph
   passed - Scenario: OPTIONAL MATCH returns null.When executing query:
   passed - Scenario: OPTIONAL MATCH returns null.Then the result should be:
   passed - Scenario: OPTIONAL MATCH returns null.And no side effects
  Scenario: Zero-length named path
   passed - Scenario: Zero-length named path.Given an empty graph
   passed - Scenario: Zero-length named path.And having executed:
   passed - Scenario: Zero-length named path.When executing query:
   passed - Scenario: Zero-length named path.Then the result should be:
   passed - Scenario: Zero-length named path.And no side effects
  Scenario: Variable-length named path
   passed - Scenario: Variable-length named path.Given an empty graph
   passed - Scenario: Variable-length named path.And having executed:
   passed - Scenario: Variable-length named path.When executing query:
   failed - Scenario: Variable-length named path.Then the result should be:
   ignored - Scenario: Variable-length named path.And no side effects
  Scenario: Matching with aggregation
   passed - Scenario: Matching with aggregation.Given an empty graph
   passed - Scenario: Matching with aggregation.And having executed:
   passed - Scenario: Matching with aggregation.When executing query:
   passed - Scenario: Matching with aggregation.Then the result should be:
   passed - Scenario: Matching with aggregation.And no side effects
  Scenario: Matching using a relationship that is already bound
   passed - Scenario: Matching using a relationship that is already bound.Given an empty graph
   passed - Scenario: Matching using a relationship that is already bound.And having executed:
   passed - Scenario: Matching using a relationship that is already bound.When executing query:
   error - Scenario: Matching using a relationship that is already bound.Then the result should be:
   ignored - Scenario: Matching using a relationship that is already bound.And no side effects
  Scenario: Matching using a relationship that is already bound, in conjunction with aggregation
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation.Given an empty graph
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation.And having executed:
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation.When executing query:
   error - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation.Then the result should be:
   ignored - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation.And no side effects
  Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY.Given an empty graph
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY.And having executed:
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY.When executing query:
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY.Then the result should be, in order:
   passed - Scenario: Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY.And no side effects
  Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound.Given an empty graph
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound.And having executed:
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound.When executing query:
   error - Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound.Then the result should be:
   ignored - Scenario: Matching with LIMIT and optionally matching using a relationship that is already bound.And no side effects
  Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound.Given an empty graph
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound.And having executed:
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound.When executing query:
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound.Then the result should be:
   passed - Scenario: Matching with LIMIT and optionally matching using a relationship and node that are both already bound.And no side effects
  Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate
   passed - Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate.Given an empty graph
   passed - Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate.And having executed:
   passed - Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate.When executing query:
   passed - Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate.Then the result should be:
   passed - Scenario: Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate.And no side effects
  Scenario: Matching twice with duplicate relationship types on same relationship
   passed - Scenario: Matching twice with duplicate relationship types on same relationship.Given an empty graph
   passed - Scenario: Matching twice with duplicate relationship types on same relationship.And having executed:
   passed - Scenario: Matching twice with duplicate relationship types on same relationship.When executing query:
   passed - Scenario: Matching twice with duplicate relationship types on same relationship.Then the result should be:
   passed - Scenario: Matching twice with duplicate relationship types on same relationship.And no side effects
  Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes
   passed - Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes.Given an empty graph
   passed - Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes.And having executed:
   passed - Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes.When executing query:
   passed - Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes.Then the result should be:
   passed - Scenario: Matching relationships into a list and matching variable length using the list, with bound nodes.And no side effects
  Scenario: Fail when using property access on primitive type
   passed - Scenario: Fail when using property access on primitive type.Given an empty graph
   passed - Scenario: Fail when using property access on primitive type.And having executed:
   passed - Scenario: Fail when using property access on primitive type.When executing query:
   passed - Scenario: Fail when using property access on primitive type.Then a TypeError should be raised at runtime: PropertyAccessOnNonMap
  Scenario: Matching and returning ordered results, with LIMIT
   passed - Scenario: Matching and returning ordered results, with LIMIT.Given an empty graph
   passed - Scenario: Matching and returning ordered results, with LIMIT.And having executed:
   passed - Scenario: Matching and returning ordered results, with LIMIT.When executing query:
   passed - Scenario: Matching and returning ordered results, with LIMIT.Then the result should be, in order:
   passed - Scenario: Matching and returning ordered results, with LIMIT.And no side effects
  Scenario: Counting an empty graph
   passed - Scenario: Counting an empty graph.Given an empty graph
   passed - Scenario: Counting an empty graph.When executing query:
   passed - Scenario: Counting an empty graph.Then the result should be:
   passed - Scenario: Counting an empty graph.And no side effects
  Scenario: Matching variable length pattern with property predicate
   passed - Scenario: Matching variable length pattern with property predicate.Given an empty graph
   passed - Scenario: Matching variable length pattern with property predicate.And having executed:
   passed - Scenario: Matching variable length pattern with property predicate.When executing query:
   error - Scenario: Matching variable length pattern with property predicate.Then the result should be:
   ignored - Scenario: Matching variable length pattern with property predicate.And no side effects
  Scenario: Variable length pattern with label predicate on both sides
   passed - Scenario: Variable length pattern with label predicate on both sides.Given an empty graph
   passed - Scenario: Variable length pattern with label predicate on both sides.And having executed:
   passed - Scenario: Variable length pattern with label predicate on both sides.When executing query:
   error - Scenario: Variable length pattern with label predicate on both sides.Then the result should be:
   ignored - Scenario: Variable length pattern with label predicate on both sides.And no side effects
  Scenario: Undirected named path
   passed - Scenario: Undirected named path.Given an empty graph
   passed - Scenario: Undirected named path.And having executed:
   passed - Scenario: Undirected named path.When executing query:
   passed - Scenario: Undirected named path.Then the result should be:
   passed - Scenario: Undirected named path.And no side effects
  Scenario: Named path with WITH
   passed - Scenario: Named path with WITH.Given an empty graph
   passed - Scenario: Named path with WITH.And having executed:
   passed - Scenario: Named path with WITH.When executing query:
   passed - Scenario: Named path with WITH.Then the result should be:
   passed - Scenario: Named path with WITH.And no side effects
  Scenario: Named path with alternating directed/undirected relationships
   passed - Scenario: Named path with alternating directed.undirected relationships/Given an empty graph
   passed - Scenario: Named path with alternating directed.undirected relationships/And having executed:
   passed - Scenario: Named path with alternating directed.undirected relationships/When executing query:
   failed - Scenario: Named path with alternating directed.undirected relationships/Then the result should be:
   ignored - Scenario: Named path with alternating directed.undirected relationships/And no side effects
  Scenario: Named path with multiple alternating directed/undirected relationships
   passed - Scenario: Named path with multiple alternating directed.undirected relationships/Given an empty graph
   passed - Scenario: Named path with multiple alternating directed.undirected relationships/And having executed:
   passed - Scenario: Named path with multiple alternating directed.undirected relationships/When executing query:
   failed - Scenario: Named path with multiple alternating directed.undirected relationships/Then the result should be:
   ignored - Scenario: Named path with multiple alternating directed.undirected relationships/And no side effects
  Scenario: Named path with undirected fixed variable length pattern
   passed - Scenario: Named path with undirected fixed variable length pattern.Given an empty graph
   passed - Scenario: Named path with undirected fixed variable length pattern.And having executed:
   passed - Scenario: Named path with undirected fixed variable length pattern.When executing query:
   error - Scenario: Named path with undirected fixed variable length pattern.Then the result should be:
   ignored - Scenario: Named path with undirected fixed variable length pattern.And no side effects
  Scenario: Returning a node property value
   passed - Scenario: Returning a node property value.Given an empty graph
   passed - Scenario: Returning a node property value.And having executed:
   passed - Scenario: Returning a node property value.When executing query:
   passed - Scenario: Returning a node property value.Then the result should be:
   passed - Scenario: Returning a node property value.And no side effects
  Scenario: Returning a relationship property value
   passed - Scenario: Returning a relationship property value.Given an empty graph
   passed - Scenario: Returning a relationship property value.And having executed:
   passed - Scenario: Returning a relationship property value.When executing query:
   passed - Scenario: Returning a relationship property value.Then the result should be:
   passed - Scenario: Returning a relationship property value.And no side effects
  Scenario: Projecting nodes and relationships
   passed - Scenario: Projecting nodes and relationships.Given an empty graph
   passed - Scenario: Projecting nodes and relationships.And having executed:
   passed - Scenario: Projecting nodes and relationships.When executing query:
   passed - Scenario: Projecting nodes and relationships.Then the result should be:
   passed - Scenario: Projecting nodes and relationships.And no side effects
  Scenario: Missing node property should become null
   passed - Scenario: Missing node property should become null.Given an empty graph
   passed - Scenario: Missing node property should become null.And having executed:
   passed - Scenario: Missing node property should become null.When executing query:
   passed - Scenario: Missing node property should become null.Then the result should be:
   passed - Scenario: Missing node property should become null.And no side effects
  Scenario: Missing relationship property should become null
   passed - Scenario: Missing relationship property should become null.Given an empty graph
   passed - Scenario: Missing relationship property should become null.And having executed:
   passed - Scenario: Missing relationship property should become null.When executing query:
   passed - Scenario: Missing relationship property should become null.Then the result should be:
   passed - Scenario: Missing relationship property should become null.And no side effects
  Scenario: Returning multiple node property values
   passed - Scenario: Returning multiple node property values.Given an empty graph
   passed - Scenario: Returning multiple node property values.And having executed:
   passed - Scenario: Returning multiple node property values.When executing query:
   passed - Scenario: Returning multiple node property values.Then the result should be:
   passed - Scenario: Returning multiple node property values.And no side effects
  Scenario: Adding a property and a literal in projection
   passed - Scenario: Adding a property and a literal in projection.Given an empty graph
   passed - Scenario: Adding a property and a literal in projection.And having executed:
   passed - Scenario: Adding a property and a literal in projection.When executing query:
   passed - Scenario: Adding a property and a literal in projection.Then the result should be:
   passed - Scenario: Adding a property and a literal in projection.And no side effects
  Scenario: Adding list properties in projection
   passed - Scenario: Adding list properties in projection.Given an empty graph
   passed - Scenario: Adding list properties in projection.And having executed:
   passed - Scenario: Adding list properties in projection.When executing query:
   passed - Scenario: Adding list properties in projection.Then the result should be:
   passed - Scenario: Adding list properties in projection.And no side effects
  Scenario: Variable length relationship variables are lists of relationships
   passed - Scenario: Variable length relationship variables are lists of relationships.Given an empty graph
   passed - Scenario: Variable length relationship variables are lists of relationships.And having executed:
   passed - Scenario: Variable length relationship variables are lists of relationships.When executing query:
   error - Scenario: Variable length relationship variables are lists of relationships.Then the result should be:
   ignored - Scenario: Variable length relationship variables are lists of relationships.And no side effects
  Scenario: Variable length patterns and nulls
   passed - Scenario: Variable length patterns and nulls.Given an empty graph
   passed - Scenario: Variable length patterns and nulls.And having executed:
   passed - Scenario: Variable length patterns and nulls.When executing query:
   passed - Scenario: Variable length patterns and nulls.Then the result should be:
   passed - Scenario: Variable length patterns and nulls.And no side effects
  Scenario: Projecting a list of nodes and relationships
   passed - Scenario: Projecting a list of nodes and relationships.Given an empty graph
   passed - Scenario: Projecting a list of nodes and relationships.And having executed:
   passed - Scenario: Projecting a list of nodes and relationships.When executing query:
   passed - Scenario: Projecting a list of nodes and relationships.Then the result should be:
   passed - Scenario: Projecting a list of nodes and relationships.And no side effects
  Scenario: Respecting direction when matching existing path
   passed - Scenario: Respecting direction when matching existing path.Given an empty graph
   passed - Scenario: Respecting direction when matching existing path.And having executed:
   passed - Scenario: Respecting direction when matching existing path.When executing query:
   passed - Scenario: Respecting direction when matching existing path.Then the result should be:
   passed - Scenario: Respecting direction when matching existing path.And no side effects
  Scenario: Respecting direction when matching non-existent path
   passed - Scenario: Respecting direction when matching non-existent path.Given an empty graph
   passed - Scenario: Respecting direction when matching non-existent path.And having executed:
   passed - Scenario: Respecting direction when matching non-existent path.When executing query:
   passed - Scenario: Respecting direction when matching non-existent path.Then the result should be:
   passed - Scenario: Respecting direction when matching non-existent path.And no side effects
  Scenario: Respecting direction when matching non-existent path with multiple directions
   passed - Scenario: Respecting direction when matching non-existent path with multiple directions.Given an empty graph
   passed - Scenario: Respecting direction when matching non-existent path with multiple directions.And having executed:
   passed - Scenario: Respecting direction when matching non-existent path with multiple directions.When executing query:
   error - Scenario: Respecting direction when matching non-existent path with multiple directions.Then the result should be:
   ignored - Scenario: Respecting direction when matching non-existent path with multiple directions.And no side effects
  Scenario: Matching nodes with many labels
   passed - Scenario: Matching nodes with many labels.Given an empty graph
   passed - Scenario: Matching nodes with many labels.And having executed:
   passed - Scenario: Matching nodes with many labels.When executing query:
   passed - Scenario: Matching nodes with many labels.Then the result should be:
   passed - Scenario: Matching nodes with many labels.And no side effects
  Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH
   passed - Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH.Given an empty graph
   passed - Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH.And having executed:
   passed - Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH.When executing query:
   failed - Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH.Then the result should be:
   ignored - Scenario: Counting rows after MATCH, MERGE, OPTIONAL MATCH.And no side effects
  Scenario: Matching a self-loop
   passed - Scenario: Matching a self-loop.Given an empty graph
   passed - Scenario: Matching a self-loop.And having executed:
   passed - Scenario: Matching a self-loop.When executing query:
   passed - Scenario: Matching a self-loop.Then the result should be:
   passed - Scenario: Matching a self-loop.And no side effects
MatchAcceptanceTest
 Feature: MatchAcceptance
  Scenario: Path query should return results in written order
   passed - Scenario: Path query should return results in written order.Given an empty graph
   passed - Scenario: Path query should return results in written order.And having executed:
   passed - Scenario: Path query should return results in written order.When executing query:
   passed - Scenario: Path query should return results in written order.Then the result should be:
   passed - Scenario: Path query should return results in written order.And no side effects
  Scenario: Longer path query should return results in written order
   passed - Scenario: Longer path query should return results in written order.Given an empty graph
   passed - Scenario: Longer path query should return results in written order.And having executed:
   passed - Scenario: Longer path query should return results in written order.When executing query:
   failed - Scenario: Longer path query should return results in written order.Then the result should be:
   ignored - Scenario: Longer path query should return results in written order.And no side effects
  Scenario: Use multiple MATCH clauses to do a Cartesian product
   passed - Scenario: Use multiple MATCH clauses to do a Cartesian product.Given an empty graph
   passed - Scenario: Use multiple MATCH clauses to do a Cartesian product.And having executed:
   passed - Scenario: Use multiple MATCH clauses to do a Cartesian product.When executing query:
   passed - Scenario: Use multiple MATCH clauses to do a Cartesian product.Then the result should be:
   passed - Scenario: Use multiple MATCH clauses to do a Cartesian product.And no side effects
  Scenario: Use params in pattern matching predicates
   passed - Scenario: Use params in pattern matching predicates.Given an empty graph
   passed - Scenario: Use params in pattern matching predicates.And having executed:
   passed - Scenario: Use params in pattern matching predicates.And parameters are:
   passed - Scenario: Use params in pattern matching predicates.When executing query:
   passed - Scenario: Use params in pattern matching predicates.Then the result should be:
   passed - Scenario: Use params in pattern matching predicates.And no side effects
  Scenario: Filter out based on node prop name
   passed - Scenario: Filter out based on node prop name.Given an empty graph
   passed - Scenario: Filter out based on node prop name.And having executed:
   passed - Scenario: Filter out based on node prop name.When executing query:
   passed - Scenario: Filter out based on node prop name.Then the result should be:
   passed - Scenario: Filter out based on node prop name.And no side effects
  Scenario: Honour the column name for RETURN items
   passed - Scenario: Honour the column name for RETURN items.Given an empty graph
   passed - Scenario: Honour the column name for RETURN items.And having executed:
   passed - Scenario: Honour the column name for RETURN items.When executing query:
   passed - Scenario: Honour the column name for RETURN items.Then the result should be:
   passed - Scenario: Honour the column name for RETURN items.And no side effects
  Scenario: Filter based on rel prop name
   passed - Scenario: Filter based on rel prop name.Given an empty graph
   passed - Scenario: Filter based on rel prop name.And having executed:
   passed - Scenario: Filter based on rel prop name.When executing query:
   passed - Scenario: Filter based on rel prop name.Then the result should be:
   passed - Scenario: Filter based on rel prop name.And no side effects
  Scenario: Cope with shadowed variables
   passed - Scenario: Cope with shadowed variables.Given an empty graph
   passed - Scenario: Cope with shadowed variables.And having executed:
   passed - Scenario: Cope with shadowed variables.When executing query:
   passed - Scenario: Cope with shadowed variables.Then the result should be:
   passed - Scenario: Cope with shadowed variables.And no side effects
  Scenario: Get neighbours
   passed - Scenario: Get neighbours.Given an empty graph
   passed - Scenario: Get neighbours.And having executed:
   passed - Scenario: Get neighbours.When executing query:
   passed - Scenario: Get neighbours.Then the result should be:
   passed - Scenario: Get neighbours.And no side effects
  Scenario: Get two related nodes
   passed - Scenario: Get two related nodes.Given an empty graph
   passed - Scenario: Get two related nodes.And having executed:
   passed - Scenario: Get two related nodes.When executing query:
   passed - Scenario: Get two related nodes.Then the result should be:
   passed - Scenario: Get two related nodes.And no side effects
  Scenario: Get related to related to
   passed - Scenario: Get related to related to.Given an empty graph
   passed - Scenario: Get related to related to.And having executed:
   passed - Scenario: Get related to related to.When executing query:
   passed - Scenario: Get related to related to.Then the result should be:
   passed - Scenario: Get related to related to.And no side effects
  Scenario: Handle comparison between node properties
   passed - Scenario: Handle comparison between node properties.Given an empty graph
   passed - Scenario: Handle comparison between node properties.And having executed:
   passed - Scenario: Handle comparison between node properties.When executing query:
   passed - Scenario: Handle comparison between node properties.Then the result should be:
   passed - Scenario: Handle comparison between node properties.And no side effects
  Scenario: Return two subgraphs with bound undirected relationship
   passed - Scenario: Return two subgraphs with bound undirected relationship.Given an empty graph
   passed - Scenario: Return two subgraphs with bound undirected relationship.And having executed:
   passed - Scenario: Return two subgraphs with bound undirected relationship.When executing query:
   passed - Scenario: Return two subgraphs with bound undirected relationship.Then the result should be:
   passed - Scenario: Return two subgraphs with bound undirected relationship.And no side effects
  Scenario: Return two subgraphs with bound undirected relationship and optional relationship
   passed - Scenario: Return two subgraphs with bound undirected relationship and optional relationship.Given an empty graph
   passed - Scenario: Return two subgraphs with bound undirected relationship and optional relationship.And having executed:
   passed - Scenario: Return two subgraphs with bound undirected relationship and optional relationship.When executing query:
   failed - Scenario: Return two subgraphs with bound undirected relationship and optional relationship.Then the result should be:
   ignored - Scenario: Return two subgraphs with bound undirected relationship and optional relationship.And no side effects
  Scenario: Rel type function works as expected
   passed - Scenario: Rel type function works as expected.Given an empty graph
   passed - Scenario: Rel type function works as expected.And having executed:
   passed - Scenario: Rel type function works as expected.When executing query:
   passed - Scenario: Rel type function works as expected.Then the result should be:
   passed - Scenario: Rel type function works as expected.And no side effects
  Scenario: Walk alternative relationships
   passed - Scenario: Walk alternative relationships.Given an empty graph
   passed - Scenario: Walk alternative relationships.And having executed:
   passed - Scenario: Walk alternative relationships.When executing query:
   passed - Scenario: Walk alternative relationships.Then the result should be:
   passed - Scenario: Walk alternative relationships.And no side effects
  Scenario: Handle OR in the WHERE clause
   passed - Scenario: Handle OR in the WHERE clause.Given an empty graph
   passed - Scenario: Handle OR in the WHERE clause.And having executed:
   passed - Scenario: Handle OR in the WHERE clause.When executing query:
   passed - Scenario: Handle OR in the WHERE clause.Then the result should be:
   passed - Scenario: Handle OR in the WHERE clause.And no side effects
  Scenario: Return a simple path
   passed - Scenario: Return a simple path.Given an empty graph
   passed - Scenario: Return a simple path.And having executed:
   passed - Scenario: Return a simple path.When executing query:
   passed - Scenario: Return a simple path.Then the result should be:
   passed - Scenario: Return a simple path.And no side effects
  Scenario: Return a three node path
   passed - Scenario: Return a three node path.Given an empty graph
   passed - Scenario: Return a three node path.And having executed:
   passed - Scenario: Return a three node path.When executing query:
   passed - Scenario: Return a three node path.Then the result should be:
   passed - Scenario: Return a three node path.And no side effects
  Scenario: Do not return anything because path length does not match
   passed - Scenario: Do not return anything because path length does not match.Given an empty graph
   passed - Scenario: Do not return anything because path length does not match.And having executed:
   passed - Scenario: Do not return anything because path length does not match.When executing query:
   passed - Scenario: Do not return anything because path length does not match.Then the result should be:
   passed - Scenario: Do not return anything because path length does not match.And no side effects
  Scenario: Pass the path length test
   passed - Scenario: Pass the path length test.Given an empty graph
   passed - Scenario: Pass the path length test.And having executed:
   passed - Scenario: Pass the path length test.When executing query:
   passed - Scenario: Pass the path length test.Then the result should be:
   passed - Scenario: Pass the path length test.And no side effects
  Scenario: Return relationships by fetching them from the path - starting from the end
   passed - Scenario: Return relationships by fetching them from the path - starting from the end.Given an empty graph
   passed - Scenario: Return relationships by fetching them from the path - starting from the end.And having executed:
   passed - Scenario: Return relationships by fetching them from the path - starting from the end.When executing query:
   error - Scenario: Return relationships by fetching them from the path - starting from the end.Then the result should be:
   ignored - Scenario: Return relationships by fetching them from the path - starting from the end.And no side effects
  Scenario: Return relationships by fetching them from the path
   passed - Scenario: Return relationships by fetching them from the path.Given an empty graph
   passed - Scenario: Return relationships by fetching them from the path.And having executed:
   passed - Scenario: Return relationships by fetching them from the path.When executing query:
   error - Scenario: Return relationships by fetching them from the path.Then the result should be:
   ignored - Scenario: Return relationships by fetching them from the path.And no side effects
  Scenario: Return relationships by collecting them as a list - directed, one way
   passed - Scenario: Return relationships by collecting them as a list - directed, one way.Given an empty graph
   passed - Scenario: Return relationships by collecting them as a list - directed, one way.And having executed:
   passed - Scenario: Return relationships by collecting them as a list - directed, one way.When executing query:
   error - Scenario: Return relationships by collecting them as a list - directed, one way.Then the result should be:
   ignored - Scenario: Return relationships by collecting them as a list - directed, one way.And no side effects
  Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes.Given an empty graph
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes.And having executed:
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes.When executing query:
   error - Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes.Then the result should be:
   ignored - Scenario: Return relationships by collecting them as a list - undirected, starting from two extremes.And no side effects
  Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme.Given an empty graph
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme.And having executed:
   passed - Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme.When executing query:
   error - Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme.Then the result should be:
   ignored - Scenario: Return relationships by collecting them as a list - undirected, starting from one extreme.And no side effects
  Scenario: Return a var length path
   passed - Scenario: Return a var length path.Given an empty graph
   passed - Scenario: Return a var length path.And having executed:
   passed - Scenario: Return a var length path.When executing query:
   error - Scenario: Return a var length path.Then the result should be:
   ignored - Scenario: Return a var length path.And no side effects
  Scenario: Return a var length path of length zero
   passed - Scenario: Return a var length path of length zero.Given an empty graph
   passed - Scenario: Return a var length path of length zero.And having executed:
   passed - Scenario: Return a var length path of length zero.When executing query:
   error - Scenario: Return a var length path of length zero.Then the result should be:
   ignored - Scenario: Return a var length path of length zero.And no side effects
  Scenario: Return a named var length path of length zero
   passed - Scenario: Return a named var length path of length zero.Given an empty graph
   passed - Scenario: Return a named var length path of length zero.And having executed:
   passed - Scenario: Return a named var length path of length zero.When executing query:
   error - Scenario: Return a named var length path of length zero.Then the result should be:
   ignored - Scenario: Return a named var length path of length zero.And no side effects
  Scenario: Accept skip zero
   passed - Scenario: Accept skip zero.Given any graph
   passed - Scenario: Accept skip zero.When executing query:
   passed - Scenario: Accept skip zero.Then the result should be:
   passed - Scenario: Accept skip zero.And no side effects
MatchingSelfRelationshipsTest
 Feature: MatchingSelfRelationships
  Scenario: Undirected match in self-relationship graph
   passed - Scenario: Undirected match in self-relationship graph.Given an empty graph
   passed - Scenario: Undirected match in self-relationship graph.And having executed:
   passed - Scenario: Undirected match in self-relationship graph.When executing query:
   passed - Scenario: Undirected match in self-relationship graph.Then the result should be:
   passed - Scenario: Undirected match in self-relationship graph.And no side effects
  Scenario: Undirected match in self-relationship graph, count
   passed - Scenario: Undirected match in self-relationship graph, count.Given an empty graph
   passed - Scenario: Undirected match in self-relationship graph, count.And having executed:
   passed - Scenario: Undirected match in self-relationship graph, count.When executing query:
   passed - Scenario: Undirected match in self-relationship graph, count.Then the result should be:
   passed - Scenario: Undirected match in self-relationship graph, count.And no side effects
  Scenario: Undirected match of self-relationship in self-relationship graph
   passed - Scenario: Undirected match of self-relationship in self-relationship graph.Given an empty graph
   passed - Scenario: Undirected match of self-relationship in self-relationship graph.And having executed:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph.When executing query:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph.Then the result should be:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph.And no side effects
  Scenario: Undirected match of self-relationship in self-relationship graph, count
   passed - Scenario: Undirected match of self-relationship in self-relationship graph, count.Given an empty graph
   passed - Scenario: Undirected match of self-relationship in self-relationship graph, count.And having executed:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph, count.When executing query:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph, count.Then the result should be:
   passed - Scenario: Undirected match of self-relationship in self-relationship graph, count.And no side effects
  Scenario: Undirected match on simple relationship graph
   passed - Scenario: Undirected match on simple relationship graph.Given an empty graph
   passed - Scenario: Undirected match on simple relationship graph.And having executed:
   passed - Scenario: Undirected match on simple relationship graph.When executing query:
   passed - Scenario: Undirected match on simple relationship graph.Then the result should be:
   passed - Scenario: Undirected match on simple relationship graph.And no side effects
  Scenario: Undirected match on simple relationship graph, count
   passed - Scenario: Undirected match on simple relationship graph, count.Given an empty graph
   passed - Scenario: Undirected match on simple relationship graph, count.And having executed:
   passed - Scenario: Undirected match on simple relationship graph, count.When executing query:
   passed - Scenario: Undirected match on simple relationship graph, count.Then the result should be:
   passed - Scenario: Undirected match on simple relationship graph, count.And no side effects
  Scenario: Directed match on self-relationship graph
   passed - Scenario: Directed match on self-relationship graph.Given an empty graph
   passed - Scenario: Directed match on self-relationship graph.And having executed:
   passed - Scenario: Directed match on self-relationship graph.When executing query:
   passed - Scenario: Directed match on self-relationship graph.Then the result should be:
   passed - Scenario: Directed match on self-relationship graph.And no side effects
  Scenario: Directed match on self-relationship graph, count
   passed - Scenario: Directed match on self-relationship graph, count.Given an empty graph
   passed - Scenario: Directed match on self-relationship graph, count.And having executed:
   passed - Scenario: Directed match on self-relationship graph, count.When executing query:
   passed - Scenario: Directed match on self-relationship graph, count.Then the result should be:
   passed - Scenario: Directed match on self-relationship graph, count.And no side effects
  Scenario: Directed match of self-relationship on self-relationship graph
   passed - Scenario: Directed match of self-relationship on self-relationship graph.Given an empty graph
   passed - Scenario: Directed match of self-relationship on self-relationship graph.And having executed:
   passed - Scenario: Directed match of self-relationship on self-relationship graph.When executing query:
   passed - Scenario: Directed match of self-relationship on self-relationship graph.Then the result should be:
   passed - Scenario: Directed match of self-relationship on self-relationship graph.And no side effects
  Scenario: Directed match of self-relationship on self-relationship graph, count
   passed - Scenario: Directed match of self-relationship on self-relationship graph, count.Given an empty graph
   passed - Scenario: Directed match of self-relationship on self-relationship graph, count.And having executed:
   passed - Scenario: Directed match of self-relationship on self-relationship graph, count.When executing query:
   passed - Scenario: Directed match of self-relationship on self-relationship graph, count.Then the result should be:
   passed - Scenario: Directed match of self-relationship on self-relationship graph, count.And no side effects
  Scenario: Counting undirected self-relationships in self-relationship graph
   passed - Scenario: Counting undirected self-relationships in self-relationship graph.Given an empty graph
   passed - Scenario: Counting undirected self-relationships in self-relationship graph.And having executed:
   passed - Scenario: Counting undirected self-relationships in self-relationship graph.When executing query:
   passed - Scenario: Counting undirected self-relationships in self-relationship graph.Then the result should be:
   passed - Scenario: Counting undirected self-relationships in self-relationship graph.And no side effects
  Scenario: Counting distinct undirected self-relationships in self-relationship graph
   passed - Scenario: Counting distinct undirected self-relationships in self-relationship graph.Given an empty graph
   passed - Scenario: Counting distinct undirected self-relationships in self-relationship graph.And having executed:
   passed - Scenario: Counting distinct undirected self-relationships in self-relationship graph.When executing query:
   passed - Scenario: Counting distinct undirected self-relationships in self-relationship graph.Then the result should be:
   passed - Scenario: Counting distinct undirected self-relationships in self-relationship graph.And no side effects
  Scenario: Directed match of a simple relationship
   passed - Scenario: Directed match of a simple relationship.Given an empty graph
   passed - Scenario: Directed match of a simple relationship.And having executed:
   passed - Scenario: Directed match of a simple relationship.When executing query:
   passed - Scenario: Directed match of a simple relationship.Then the result should be:
   passed - Scenario: Directed match of a simple relationship.And no side effects
  Scenario: Directed match of a simple relationship, count
   passed - Scenario: Directed match of a simple relationship, count.Given an empty graph
   passed - Scenario: Directed match of a simple relationship, count.And having executed:
   passed - Scenario: Directed match of a simple relationship, count.When executing query:
   passed - Scenario: Directed match of a simple relationship, count.Then the result should be:
   passed - Scenario: Directed match of a simple relationship, count.And no side effects
  Scenario: Mixing directed and undirected pattern parts with self-relationship, simple
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, simple.Given an empty graph
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, simple.And having executed:
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, simple.When executing query:
   failed - Scenario: Mixing directed and undirected pattern parts with self-relationship, simple.Then the result should be:
   ignored - Scenario: Mixing directed and undirected pattern parts with self-relationship, simple.And no side effects
  Scenario: Mixing directed and undirected pattern parts with self-relationship, count
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, count.Given an empty graph
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, count.And having executed:
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, count.When executing query:
   failed - Scenario: Mixing directed and undirected pattern parts with self-relationship, count.Then the result should be:
   ignored - Scenario: Mixing directed and undirected pattern parts with self-relationship, count.And no side effects
  Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected.Given an empty graph
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected.And having executed:
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected.When executing query:
   failed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected.Then the result should be:
   ignored - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected.And no side effects
  Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count.Given an empty graph
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count.And having executed:
   passed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count.When executing query:
   failed - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count.Then the result should be:
   ignored - Scenario: Mixing directed and undirected pattern parts with self-relationship, undirected count.And no side effects
MergeIntoAcceptanceTest
 Feature: MergeIntoAcceptance
  Scenario: Updating one property with ON CREATE
   passed - Scenario: Updating one property with ON CREATE.Given an empty graph
   passed - Scenario: Updating one property with ON CREATE.And having executed:
   passed - Scenario: Updating one property with ON CREATE.When executing query:
   passed - Scenario: Updating one property with ON CREATE.Then the result should be empty
   passed - Scenario: Updating one property with ON CREATE.And the side effects should be:
   passed - Scenario: Updating one property with ON CREATE.When executing control query:
   passed - Scenario: Updating one property with ON CREATE.Then the result should be:
  Scenario: Null-setting one property with ON CREATE
   passed - Scenario: Null-setting one property with ON CREATE.Given an empty graph
   passed - Scenario: Null-setting one property with ON CREATE.And having executed:
   passed - Scenario: Null-setting one property with ON CREATE.When executing query:
   passed - Scenario: Null-setting one property with ON CREATE.Then the result should be empty
   passed - Scenario: Null-setting one property with ON CREATE.And the side effects should be:
   passed - Scenario: Null-setting one property with ON CREATE.When executing control query:
   passed - Scenario: Null-setting one property with ON CREATE.Then the result should be:
  Scenario: Copying properties from node with ON CREATE
   passed - Scenario: Copying properties from node with ON CREATE.Given an empty graph
   passed - Scenario: Copying properties from node with ON CREATE.And having executed:
   passed - Scenario: Copying properties from node with ON CREATE.When executing query:
   error - Scenario: Copying properties from node with ON CREATE.Then the result should be empty
   ignored - Scenario: Copying properties from node with ON CREATE.And the side effects should be:
   ignored - Scenario: Copying properties from node with ON CREATE.When executing control query:
   ignored - Scenario: Copying properties from node with ON CREATE.Then the result should be:
  Scenario: Copying properties from node with ON MATCH
   passed - Scenario: Copying properties from node with ON MATCH.Given an empty graph
   passed - Scenario: Copying properties from node with ON MATCH.And having executed:
   passed - Scenario: Copying properties from node with ON MATCH.And having executed:
   passed - Scenario: Copying properties from node with ON MATCH.When executing query:
   error - Scenario: Copying properties from node with ON MATCH.Then the result should be empty
   ignored - Scenario: Copying properties from node with ON MATCH.And the side effects should be:
   ignored - Scenario: Copying properties from node with ON MATCH.When executing control query:
   ignored - Scenario: Copying properties from node with ON MATCH.Then the result should be:
  Scenario: Copying properties from literal map with ON CREATE
   passed - Scenario: Copying properties from literal map with ON CREATE.Given an empty graph
   passed - Scenario: Copying properties from literal map with ON CREATE.And having executed:
   passed - Scenario: Copying properties from literal map with ON CREATE.When executing query:
   passed - Scenario: Copying properties from literal map with ON CREATE.Then the result should be empty
   passed - Scenario: Copying properties from literal map with ON CREATE.And the side effects should be:
   passed - Scenario: Copying properties from literal map with ON CREATE.When executing control query:
   passed - Scenario: Copying properties from literal map with ON CREATE.Then the result should be (ignoring element order for lists):
MergeNodeAcceptanceTest
 Feature: MergeNodeAcceptance
  Scenario: Merge node when no nodes exist
   passed - Scenario: Merge node when no nodes exist.Given an empty graph
   passed - Scenario: Merge node when no nodes exist.When executing query:
   passed - Scenario: Merge node when no nodes exist.Then the result should be:
   passed - Scenario: Merge node when no nodes exist.And the side effects should be:
  Scenario: Merge node with label
   passed - Scenario: Merge node with label.Given an empty graph
   passed - Scenario: Merge node with label.When executing query:
   passed - Scenario: Merge node with label.Then the result should be:
   passed - Scenario: Merge node with label.And the side effects should be:
  Scenario: Merge node with label add label on create
   passed - Scenario: Merge node with label add label on create.Given an empty graph
   passed - Scenario: Merge node with label add label on create.When executing query:
   passed - Scenario: Merge node with label add label on create.Then the result should be:
   passed - Scenario: Merge node with label add label on create.And the side effects should be:
  Scenario: Merge node with label add property on create
   passed - Scenario: Merge node with label add property on create.Given an empty graph
   passed - Scenario: Merge node with label add property on create.When executing query:
   passed - Scenario: Merge node with label add property on create.Then the result should be:
   passed - Scenario: Merge node with label add property on create.And the side effects should be:
  Scenario: Merge node with label when it exists
   passed - Scenario: Merge node with label when it exists.Given an empty graph
   passed - Scenario: Merge node with label when it exists.And having executed:
   passed - Scenario: Merge node with label when it exists.When executing query:
   passed - Scenario: Merge node with label when it exists.Then the result should be:
   passed - Scenario: Merge node with label when it exists.And no side effects
  Scenario: Merge node should create when it doesn't match, properties
   passed - Scenario: Merge node should create when it doesn't match, properties.Given an empty graph
   passed - Scenario: Merge node should create when it doesn't match, properties.And having executed:
   passed - Scenario: Merge node should create when it doesn't match, properties.When executing query:
   passed - Scenario: Merge node should create when it doesn't match, properties.Then the result should be:
   passed - Scenario: Merge node should create when it doesn't match, properties.And the side effects should be:
  Scenario: Merge node should create when it doesn't match, properties and label
   passed - Scenario: Merge node should create when it doesn't match, properties and label.Given an empty graph
   passed - Scenario: Merge node should create when it doesn't match, properties and label.And having executed:
   passed - Scenario: Merge node should create when it doesn't match, properties and label.When executing query:
   passed - Scenario: Merge node should create when it doesn't match, properties and label.Then the result should be:
   passed - Scenario: Merge node should create when it doesn't match, properties and label.And the side effects should be:
  Scenario: Merge node with prop and label
   passed - Scenario: Merge node with prop and label.Given an empty graph
   passed - Scenario: Merge node with prop and label.And having executed:
   passed - Scenario: Merge node with prop and label.When executing query:
   passed - Scenario: Merge node with prop and label.Then the result should be:
   passed - Scenario: Merge node with prop and label.And no side effects
  Scenario: Merge node with label add label on match when it exists
   passed - Scenario: Merge node with label add label on match when it exists.Given an empty graph
   passed - Scenario: Merge node with label add label on match when it exists.And having executed:
   passed - Scenario: Merge node with label add label on match when it exists.When executing query:
   passed - Scenario: Merge node with label add label on match when it exists.Then the result should be:
   passed - Scenario: Merge node with label add label on match when it exists.And the side effects should be:
  Scenario: Merge node with label add property on update when it exists
   passed - Scenario: Merge node with label add property on update when it exists.Given an empty graph
   passed - Scenario: Merge node with label add property on update when it exists.And having executed:
   passed - Scenario: Merge node with label add property on update when it exists.When executing query:
   passed - Scenario: Merge node with label add property on update when it exists.Then the result should be:
   passed - Scenario: Merge node with label add property on update when it exists.And no side effects
  Scenario: Merge node and set property on match
   passed - Scenario: Merge node and set property on match.Given an empty graph
   passed - Scenario: Merge node and set property on match.And having executed:
   passed - Scenario: Merge node and set property on match.When executing query:
   passed - Scenario: Merge node and set property on match.Then the result should be:
   passed - Scenario: Merge node and set property on match.And the side effects should be:
  Scenario: Should work when finding multiple elements
   passed - Scenario: Should work when finding multiple elements.Given an empty graph
   passed - Scenario: Should work when finding multiple elements.When executing query:
   passed - Scenario: Should work when finding multiple elements.Then the result should be empty
   passed - Scenario: Should work when finding multiple elements.And the side effects should be:
  Scenario: Should handle argument properly
   passed - Scenario: Should handle argument properly.Given an empty graph
   passed - Scenario: Should handle argument properly.And having executed:
   passed - Scenario: Should handle argument properly.When executing query:
   passed - Scenario: Should handle argument properly.Then the result should be empty
   passed - Scenario: Should handle argument properly.And the side effects should be:
  Scenario: Should handle arguments properly with only write clauses
   passed - Scenario: Should handle arguments properly with only write clauses.Given an empty graph
   passed - Scenario: Should handle arguments properly with only write clauses.When executing query:
   passed - Scenario: Should handle arguments properly with only write clauses.Then the result should be empty
   passed - Scenario: Should handle arguments properly with only write clauses.And the side effects should be:
  Scenario: Should be able to merge using property from match
   passed - Scenario: Should be able to merge using property from match.Given an empty graph
   passed - Scenario: Should be able to merge using property from match.And having executed:
   passed - Scenario: Should be able to merge using property from match.When executing query:
   passed - Scenario: Should be able to merge using property from match.Then the result should be empty
   passed - Scenario: Should be able to merge using property from match.And the side effects should be:
  Scenario: Should be able to use properties from match in ON CREATE
   passed - Scenario: Should be able to use properties from match in ON CREATE.Given an empty graph
   passed - Scenario: Should be able to use properties from match in ON CREATE.And having executed:
   passed - Scenario: Should be able to use properties from match in ON CREATE.When executing query:
   passed - Scenario: Should be able to use properties from match in ON CREATE.Then the result should be:
   passed - Scenario: Should be able to use properties from match in ON CREATE.And the side effects should be:
  Scenario: Should be able to use properties from match in ON MATCH
   passed - Scenario: Should be able to use properties from match in ON MATCH.Given an empty graph
   passed - Scenario: Should be able to use properties from match in ON MATCH.And having executed:
   passed - Scenario: Should be able to use properties from match in ON MATCH.When executing query:
   passed - Scenario: Should be able to use properties from match in ON MATCH.Then the result should be:
   passed - Scenario: Should be able to use properties from match in ON MATCH.And the side effects should be:
  Scenario: Should be able to set labels on match
   passed - Scenario: Should be able to set labels on match.Given an empty graph
   passed - Scenario: Should be able to set labels on match.And having executed:
   passed - Scenario: Should be able to set labels on match.When executing query:
   passed - Scenario: Should be able to set labels on match.Then the result should be empty
   passed - Scenario: Should be able to set labels on match.And the side effects should be:
  Scenario: Should be able to set labels on match and on create
   passed - Scenario: Should be able to set labels on match and on create.Given an empty graph
   passed - Scenario: Should be able to set labels on match and on create.And having executed:
   passed - Scenario: Should be able to set labels on match and on create.When executing query:
   passed - Scenario: Should be able to set labels on match and on create.Then the result should be empty
   passed - Scenario: Should be able to set labels on match and on create.And the side effects should be:
  Scenario: Should support updates while merging
   passed - Scenario: Should support updates while merging.Given an empty graph
   passed - Scenario: Should support updates while merging.And having executed:
   passed - Scenario: Should support updates while merging.When executing query:
   failed - Scenario: Should support updates while merging.Then the result should be:
   ignored - Scenario: Should support updates while merging.And the side effects should be:
  Scenario: Merge must properly handle multiple labels
   passed - Scenario: Merge must properly handle multiple labels.Given an empty graph
   passed - Scenario: Merge must properly handle multiple labels.And having executed:
   passed - Scenario: Merge must properly handle multiple labels.When executing query:
   passed - Scenario: Merge must properly handle multiple labels.Then the result should be:
   passed - Scenario: Merge must properly handle multiple labels.And the side effects should be:
  Scenario: Merge followed by multiple creates
   passed - Scenario: Merge followed by multiple creates.Given an empty graph
   passed - Scenario: Merge followed by multiple creates.When executing query:
   passed - Scenario: Merge followed by multiple creates.Then the result should be empty
   passed - Scenario: Merge followed by multiple creates.And the side effects should be:
  Scenario: Unwind combined with merge
   passed - Scenario: Unwind combined with merge.Given an empty graph
   passed - Scenario: Unwind combined with merge.When executing query:
   passed - Scenario: Unwind combined with merge.Then the result should be:
   passed - Scenario: Unwind combined with merge.And the side effects should be:
  Scenario: Merges should not be able to match on deleted nodes
   passed - Scenario: Merges should not be able to match on deleted nodes.Given an empty graph
   passed - Scenario: Merges should not be able to match on deleted nodes.And having executed:
   passed - Scenario: Merges should not be able to match on deleted nodes.When executing query:
   failed - Scenario: Merges should not be able to match on deleted nodes.Then the result should be:
   ignored - Scenario: Merges should not be able to match on deleted nodes.And the side effects should be:
  Scenario: ON CREATE on created nodes
   passed - Scenario: ON CREATE on created nodes.Given an empty graph
   passed - Scenario: ON CREATE on created nodes.When executing query:
   passed - Scenario: ON CREATE on created nodes.Then the result should be empty
   passed - Scenario: ON CREATE on created nodes.And the side effects should be:
MergeRelationshipAcceptanceTest
 Feature: MergeRelationshipAcceptance
  Scenario: Creating a relationship
   passed - Scenario: Creating a relationship.Given an empty graph
   passed - Scenario: Creating a relationship.And having executed:
   passed - Scenario: Creating a relationship.When executing query:
   passed - Scenario: Creating a relationship.Then the result should be:
   passed - Scenario: Creating a relationship.And the side effects should be:
  Scenario: Matching a relationship
   passed - Scenario: Matching a relationship.Given an empty graph
   passed - Scenario: Matching a relationship.And having executed:
   passed - Scenario: Matching a relationship.When executing query:
   passed - Scenario: Matching a relationship.Then the result should be:
   passed - Scenario: Matching a relationship.And no side effects
  Scenario: Matching two relationships
   passed - Scenario: Matching two relationships.Given an empty graph
   passed - Scenario: Matching two relationships.And having executed:
   passed - Scenario: Matching two relationships.When executing query:
   passed - Scenario: Matching two relationships.Then the result should be:
   passed - Scenario: Matching two relationships.And no side effects
  Scenario: Filtering relationships
   passed - Scenario: Filtering relationships.Given an empty graph
   passed - Scenario: Filtering relationships.And having executed:
   passed - Scenario: Filtering relationships.When executing query:
   passed - Scenario: Filtering relationships.Then the result should be:
   passed - Scenario: Filtering relationships.And no side effects
  Scenario: Creating relationship when all matches filtered out
   passed - Scenario: Creating relationship when all matches filtered out.Given an empty graph
   passed - Scenario: Creating relationship when all matches filtered out.And having executed:
   passed - Scenario: Creating relationship when all matches filtered out.When executing query:
   passed - Scenario: Creating relationship when all matches filtered out.Then the result should be:
   passed - Scenario: Creating relationship when all matches filtered out.And the side effects should be:
  Scenario: Matching incoming relationship
   passed - Scenario: Matching incoming relationship.Given an empty graph
   passed - Scenario: Matching incoming relationship.And having executed:
   passed - Scenario: Matching incoming relationship.When executing query:
   passed - Scenario: Matching incoming relationship.Then the result should be:
   passed - Scenario: Matching incoming relationship.And no side effects
  Scenario: Creating relationship with property
   passed - Scenario: Creating relationship with property.Given an empty graph
   passed - Scenario: Creating relationship with property.And having executed:
   passed - Scenario: Creating relationship with property.When executing query:
   passed - Scenario: Creating relationship with property.Then the result should be:
   passed - Scenario: Creating relationship with property.And the side effects should be:
  Scenario: Using ON CREATE on a node
   passed - Scenario: Using ON CREATE on a node.Given an empty graph
   passed - Scenario: Using ON CREATE on a node.And having executed:
   passed - Scenario: Using ON CREATE on a node.When executing query:
   passed - Scenario: Using ON CREATE on a node.Then the result should be empty
   passed - Scenario: Using ON CREATE on a node.And the side effects should be:
  Scenario: Using ON CREATE on a relationship
   passed - Scenario: Using ON CREATE on a relationship.Given an empty graph
   passed - Scenario: Using ON CREATE on a relationship.And having executed:
   passed - Scenario: Using ON CREATE on a relationship.When executing query:
   passed - Scenario: Using ON CREATE on a relationship.Then the result should be:
   passed - Scenario: Using ON CREATE on a relationship.And the side effects should be:
  Scenario: Using ON MATCH on created node
   passed - Scenario: Using ON MATCH on created node.Given an empty graph
   passed - Scenario: Using ON MATCH on created node.And having executed:
   passed - Scenario: Using ON MATCH on created node.When executing query:
   passed - Scenario: Using ON MATCH on created node.Then the result should be empty
   passed - Scenario: Using ON MATCH on created node.And the side effects should be:
  Scenario: Using ON MATCH on created relationship
   passed - Scenario: Using ON MATCH on created relationship.Given an empty graph
   passed - Scenario: Using ON MATCH on created relationship.And having executed:
   passed - Scenario: Using ON MATCH on created relationship.When executing query:
   passed - Scenario: Using ON MATCH on created relationship.Then the result should be empty
   passed - Scenario: Using ON MATCH on created relationship.And the side effects should be:
  Scenario: Using ON MATCH on a relationship
   passed - Scenario: Using ON MATCH on a relationship.Given an empty graph
   passed - Scenario: Using ON MATCH on a relationship.And having executed:
   passed - Scenario: Using ON MATCH on a relationship.When executing query:
   passed - Scenario: Using ON MATCH on a relationship.Then the result should be:
   failed - Scenario: Using ON MATCH on a relationship.And the side effects should be:
  Scenario: Using ON CREATE and ON MATCH
   passed - Scenario: Using ON CREATE and ON MATCH.Given an empty graph
   passed - Scenario: Using ON CREATE and ON MATCH.And having executed:
   passed - Scenario: Using ON CREATE and ON MATCH.When executing query:
   passed - Scenario: Using ON CREATE and ON MATCH.Then the result should be:
   failed - Scenario: Using ON CREATE and ON MATCH.And the side effects should be:
  Scenario: Creating relationship using merged nodes
   passed - Scenario: Creating relationship using merged nodes.Given an empty graph
   passed - Scenario: Creating relationship using merged nodes.And having executed:
   passed - Scenario: Creating relationship using merged nodes.When executing query:
   passed - Scenario: Creating relationship using merged nodes.Then the result should be empty
   passed - Scenario: Creating relationship using merged nodes.And the side effects should be:
  Scenario: Mixing MERGE with CREATE
   passed - Scenario: Mixing MERGE with CREATE.Given an empty graph
   passed - Scenario: Mixing MERGE with CREATE.When executing query:
   passed - Scenario: Mixing MERGE with CREATE.Then the result should be:
   passed - Scenario: Mixing MERGE with CREATE.And the side effects should be:
  Scenario: Introduce named paths 1
   passed - Scenario: Introduce named paths 1.Given an empty graph
   passed - Scenario: Introduce named paths 1.When executing query:
   error - Scenario: Introduce named paths 1.Then the result should be:
   ignored - Scenario: Introduce named paths 1.And the side effects should be:
  Scenario: Introduce named paths 2
   passed - Scenario: Introduce named paths 2.Given an empty graph
   passed - Scenario: Introduce named paths 2.When executing query:
   error - Scenario: Introduce named paths 2.Then the result should be:
   ignored - Scenario: Introduce named paths 2.And the side effects should be:
  Scenario: Match outgoing relationship when direction unspecified
   passed - Scenario: Match outgoing relationship when direction unspecified.Given an empty graph
   passed - Scenario: Match outgoing relationship when direction unspecified.And having executed:
   passed - Scenario: Match outgoing relationship when direction unspecified.When executing query:
   passed - Scenario: Match outgoing relationship when direction unspecified.Then the result should be:
   passed - Scenario: Match outgoing relationship when direction unspecified.And no side effects
  Scenario: Match both incoming and outgoing relationships when direction unspecified
   passed - Scenario: Match both incoming and outgoing relationships when direction unspecified.Given an empty graph
   passed - Scenario: Match both incoming and outgoing relationships when direction unspecified.And having executed:
   passed - Scenario: Match both incoming and outgoing relationships when direction unspecified.When executing query:
   passed - Scenario: Match both incoming and outgoing relationships when direction unspecified.Then the result should be:
   passed - Scenario: Match both incoming and outgoing relationships when direction unspecified.And no side effects
  Scenario: Fail when imposing new predicates on a variable that is already bound
   passed - Scenario: Fail when imposing new predicates on a variable that is already bound.Given any graph
   passed - Scenario: Fail when imposing new predicates on a variable that is already bound.When executing query:
   ignored - Scenario: Fail when imposing new predicates on a variable that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Using list properties via variable
   passed - Scenario: Using list properties via variable.Given an empty graph
   passed - Scenario: Using list properties via variable.When executing query:
   passed - Scenario: Using list properties via variable.Then the result should be:
   passed - Scenario: Using list properties via variable.And the side effects should be:
  Scenario: Matching using list property
   passed - Scenario: Matching using list property.Given an empty graph
   passed - Scenario: Matching using list property.And having executed:
   passed - Scenario: Matching using list property.When executing query:
   passed - Scenario: Matching using list property.Then the result should be:
   failed - Scenario: Matching using list property.And no side effects
  Scenario: Using bound variables from other updating clause
   passed - Scenario: Using bound variables from other updating clause.Given an empty graph
   passed - Scenario: Using bound variables from other updating clause.When executing query:
   passed - Scenario: Using bound variables from other updating clause.Then the result should be:
   passed - Scenario: Using bound variables from other updating clause.And the side effects should be:
  Scenario: UNWIND with multiple merges
   passed - Scenario: UNWIND with multiple merges.Given an empty graph
   passed - Scenario: UNWIND with multiple merges.When executing query:
   passed - Scenario: UNWIND with multiple merges.Then the result should be empty
   failed - Scenario: UNWIND with multiple merges.And the side effects should be:
  Scenario: Do not match on deleted entities
   passed - Scenario: Do not match on deleted entities.Given an empty graph
   passed - Scenario: Do not match on deleted entities.And having executed:
   passed - Scenario: Do not match on deleted entities.When executing query:
   passed - Scenario: Do not match on deleted entities.Then the result should be empty
   passed - Scenario: Do not match on deleted entities.And the side effects should be:
  Scenario: Do not match on deleted relationships
   passed - Scenario: Do not match on deleted relationships.Given an empty graph
   passed - Scenario: Do not match on deleted relationships.And having executed:
   passed - Scenario: Do not match on deleted relationships.When executing query:
   passed - Scenario: Do not match on deleted relationships.Then the result should be:
   passed - Scenario: Do not match on deleted relationships.And the side effects should be:
  Scenario: Aliasing of existing nodes 1
   passed - Scenario: Aliasing of existing nodes 1.Given an empty graph
   passed - Scenario: Aliasing of existing nodes 1.And having executed:
   passed - Scenario: Aliasing of existing nodes 1.When executing query:
   passed - Scenario: Aliasing of existing nodes 1.Then the result should be:
   passed - Scenario: Aliasing of existing nodes 1.And the side effects should be:
  Scenario: Aliasing of existing nodes 2
   passed - Scenario: Aliasing of existing nodes 2.Given an empty graph
   passed - Scenario: Aliasing of existing nodes 2.And having executed:
   passed - Scenario: Aliasing of existing nodes 2.When executing query:
   passed - Scenario: Aliasing of existing nodes 2.Then the result should be:
   passed - Scenario: Aliasing of existing nodes 2.And the side effects should be:
  Scenario: Double aliasing of existing nodes 1
   passed - Scenario: Double aliasing of existing nodes 1.Given an empty graph
   passed - Scenario: Double aliasing of existing nodes 1.And having executed:
   passed - Scenario: Double aliasing of existing nodes 1.When executing query:
   passed - Scenario: Double aliasing of existing nodes 1.Then the result should be:
   passed - Scenario: Double aliasing of existing nodes 1.And the side effects should be:
  Scenario: Double aliasing of existing nodes 2
   passed - Scenario: Double aliasing of existing nodes 2.Given an empty graph
   passed - Scenario: Double aliasing of existing nodes 2.And having executed:
   passed - Scenario: Double aliasing of existing nodes 2.When executing query:
   passed - Scenario: Double aliasing of existing nodes 2.Then the result should be:
   passed - Scenario: Double aliasing of existing nodes 2.And the side effects should be:
MiscellaneousErrorAcceptanceTest
 Feature: MiscellaneousErrorAcceptance
  Scenario: Failing on incorrect unicode literal
   passed - Scenario: Failing on incorrect unicode literal.Given any graph
   passed - Scenario: Failing on incorrect unicode literal.When executing query:
   passed - Scenario: Failing on incorrect unicode literal.Then a SyntaxError should be raised at compile time: InvalidUnicodeLiteral
  Scenario: Failing on merging relationship with null property
   passed - Scenario: Failing on merging relationship with null property.Given any graph
   passed - Scenario: Failing on merging relationship with null property.When executing query:
   ignored - Scenario: Failing on merging relationship with null property.Then a SemanticError should be raised at compile time: MergeReadOwnWrites
  Scenario: Failing on merging node with null property
   passed - Scenario: Failing on merging node with null property.Given any graph
   passed - Scenario: Failing on merging node with null property.When executing query:
   passed - Scenario: Failing on merging node with null property.Then a SemanticError should be raised at compile time: MergeReadOwnWrites
  Scenario: Failing on aggregation in WHERE
   passed - Scenario: Failing on aggregation in WHERE.Given any graph
   passed - Scenario: Failing on aggregation in WHERE.When executing query:
   ignored - Scenario: Failing on aggregation in WHERE.Then a SyntaxError should be raised at compile time: InvalidAggregation
  Scenario: Failing on aggregation in ORDER BY after RETURN
   passed - Scenario: Failing on aggregation in ORDER BY after RETURN.Given any graph
   passed - Scenario: Failing on aggregation in ORDER BY after RETURN.When executing query:
   ignored - Scenario: Failing on aggregation in ORDER BY after RETURN.Then a SyntaxError should be raised at compile time: InvalidAggregation
  Scenario: Failing on aggregation in ORDER BY after WITH
   passed - Scenario: Failing on aggregation in ORDER BY after WITH.Given any graph
   passed - Scenario: Failing on aggregation in ORDER BY after WITH.When executing query:
   ignored - Scenario: Failing on aggregation in ORDER BY after WITH.Then a SyntaxError should be raised at compile time: InvalidAggregation
  Scenario: Failing when not aliasing expressions in WITH
   passed - Scenario: Failing when not aliasing expressions in WITH.Given any graph
   passed - Scenario: Failing when not aliasing expressions in WITH.When executing query:
   ignored - Scenario: Failing when not aliasing expressions in WITH.Then a SyntaxError should be raised at compile time: NoExpressionAlias
  Scenario: Failing when using undefined variable in pattern
   passed - Scenario: Failing when using undefined variable in pattern.Given any graph
   passed - Scenario: Failing when using undefined variable in pattern.When executing query:
   ignored - Scenario: Failing when using undefined variable in pattern.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using undefined variable in SET
   passed - Scenario: Failing when using undefined variable in SET.Given any graph
   passed - Scenario: Failing when using undefined variable in SET.When executing query:
   ignored - Scenario: Failing when using undefined variable in SET.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using undefined variable in DELETE
   passed - Scenario: Failing when using undefined variable in DELETE.Given any graph
   passed - Scenario: Failing when using undefined variable in DELETE.When executing query:
   ignored - Scenario: Failing when using undefined variable in DELETE.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using a variable that is already bound in CREATE
   passed - Scenario: Failing when using a variable that is already bound in CREATE.Given any graph
   passed - Scenario: Failing when using a variable that is already bound in CREATE.When executing query:
   ignored - Scenario: Failing when using a variable that is already bound in CREATE.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using a path variable that is already bound
   passed - Scenario: Failing when using a path variable that is already bound.Given any graph
   passed - Scenario: Failing when using a path variable that is already bound.When executing query:
   ignored - Scenario: Failing when using a path variable that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using a list as a node
   passed - Scenario: Failing when using a list as a node.Given any graph
   passed - Scenario: Failing when using a list as a node.When executing query:
   ignored - Scenario: Failing when using a list as a node.Then a SyntaxError should be raised at compile time: VariableTypeConflict
  Scenario: Failing when using a variable length relationship as a single relationship
   passed - Scenario: Failing when using a variable length relationship as a single relationship.Given any graph
   passed - Scenario: Failing when using a variable length relationship as a single relationship.When executing query:
   ignored - Scenario: Failing when using a variable length relationship as a single relationship.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when UNION has different columns
   passed - Scenario: Failing when UNION has different columns.Given any graph
   passed - Scenario: Failing when UNION has different columns.When executing query:
   ignored - Scenario: Failing when UNION has different columns.Then a SyntaxError should be raised at compile time: DifferentColumnsInUnion
  Scenario: Failing when mixing UNION and UNION ALL
   passed - Scenario: Failing when mixing UNION and UNION ALL.Given any graph
   passed - Scenario: Failing when mixing UNION and UNION ALL.When executing query:
   ignored - Scenario: Failing when mixing UNION and UNION ALL.Then a SyntaxError should be raised at compile time: InvalidClauseComposition
  Scenario: Failing when creating without direction
   passed - Scenario: Failing when creating without direction.Given any graph
   passed - Scenario: Failing when creating without direction.When executing query:
   passed - Scenario: Failing when creating without direction.Then a SyntaxError should be raised at compile time: RequiresDirectedRelationship
  Scenario: Failing when creating with two directions
   passed - Scenario: Failing when creating with two directions.Given any graph
   passed - Scenario: Failing when creating with two directions.When executing query:
   passed - Scenario: Failing when creating with two directions.Then a SyntaxError should be raised at compile time: RequiresDirectedRelationship
  Scenario: Failing when deleting a label
   passed - Scenario: Failing when deleting a label.Given any graph
   passed - Scenario: Failing when deleting a label.When executing query:
   ignored - Scenario: Failing when deleting a label.Then a SyntaxError should be raised at compile time: InvalidDelete
  Scenario: Failing when setting a list of maps as a property
   passed - Scenario: Failing when setting a list of maps as a property.Given any graph
   passed - Scenario: Failing when setting a list of maps as a property.When executing query:
   ignored - Scenario: Failing when setting a list of maps as a property.Then a TypeError should be raised at compile time: InvalidPropertyType
  Scenario: Failing when multiple columns have the same name
   passed - Scenario: Failing when multiple columns have the same name.Given any graph
   passed - Scenario: Failing when multiple columns have the same name.When executing query:
   ignored - Scenario: Failing when multiple columns have the same name.Then a SyntaxError should be raised at compile time: ColumnNameConflict
  Scenario: Failing when using RETURN * without variables in scope
   passed - Scenario: Failing when using RETURN * without variables in scope.Given any graph
   passed - Scenario: Failing when using RETURN * without variables in scope.When executing query:
   ignored - Scenario: Failing when using RETURN * without variables in scope.Then a SyntaxError should be raised at compile time: NoVariablesInScope
NullAcceptanceTest
 Feature: NullAcceptance
  Scenario: Property existence check on non-null node
   passed - Scenario: Property existence check on non-null node.Given an empty graph
   passed - Scenario: Property existence check on non-null node.And having executed:
   passed - Scenario: Property existence check on non-null node.When executing query:
   passed - Scenario: Property existence check on non-null node.Then the result should be:
   passed - Scenario: Property existence check on non-null node.And no side effects
  Scenario: Property existence check on optional non-null node
   passed - Scenario: Property existence check on optional non-null node.Given an empty graph
   passed - Scenario: Property existence check on optional non-null node.And having executed:
   passed - Scenario: Property existence check on optional non-null node.When executing query:
   passed - Scenario: Property existence check on optional non-null node.Then the result should be:
   passed - Scenario: Property existence check on optional non-null node.And no side effects
  Scenario: Ignore null when setting property
   passed - Scenario: Ignore null when setting property.Given an empty graph
   passed - Scenario: Ignore null when setting property.When executing query:
   passed - Scenario: Ignore null when setting property.Then the result should be:
   passed - Scenario: Ignore null when setting property.And no side effects
  Scenario: Ignore null when removing property
   passed - Scenario: Ignore null when removing property.Given an empty graph
   passed - Scenario: Ignore null when removing property.When executing query:
   error - Scenario: Ignore null when removing property.Then the result should be:
   ignored - Scenario: Ignore null when removing property.And no side effects
  Scenario: Ignore null when setting properties using an appending map
   passed - Scenario: Ignore null when setting properties using an appending map.Given an empty graph
   passed - Scenario: Ignore null when setting properties using an appending map.When executing query:
   error - Scenario: Ignore null when setting properties using an appending map.Then the result should be:
   ignored - Scenario: Ignore null when setting properties using an appending map.And no side effects
  Scenario: Ignore null when setting properties using an overriding map
   passed - Scenario: Ignore null when setting properties using an overriding map.Given an empty graph
   passed - Scenario: Ignore null when setting properties using an overriding map.When executing query:
   passed - Scenario: Ignore null when setting properties using an overriding map.Then the result should be:
   passed - Scenario: Ignore null when setting properties using an overriding map.And no side effects
  Scenario: Ignore null when setting label
   passed - Scenario: Ignore null when setting label.Given an empty graph
   passed - Scenario: Ignore null when setting label.When executing query:
   error - Scenario: Ignore null when setting label.Then the result should be:
   ignored - Scenario: Ignore null when setting label.And no side effects
  Scenario: Ignore null when removing label
   passed - Scenario: Ignore null when removing label.Given an empty graph
   passed - Scenario: Ignore null when removing label.When executing query:
   error - Scenario: Ignore null when removing label.Then the result should be:
   ignored - Scenario: Ignore null when removing label.And no side effects
  Scenario: Ignore null when deleting node
   passed - Scenario: Ignore null when deleting node.Given an empty graph
   passed - Scenario: Ignore null when deleting node.When executing query:
   passed - Scenario: Ignore null when deleting node.Then the result should be:
   passed - Scenario: Ignore null when deleting node.And no side effects
  Scenario: Ignore null when deleting relationship
   passed - Scenario: Ignore null when deleting relationship.Given an empty graph
   passed - Scenario: Ignore null when deleting relationship.When executing query:
   passed - Scenario: Ignore null when deleting relationship.Then the result should be:
   passed - Scenario: Ignore null when deleting relationship.And no side effects
NullOperatorTest
 Feature: NullOperator
  Scenario: Property null check on non-null node
   passed - Scenario: Property null check on non-null node.Given an empty graph
   passed - Scenario: Property null check on non-null node.And having executed:
   passed - Scenario: Property null check on non-null node.When executing query:
   passed - Scenario: Property null check on non-null node.Then the result should be:
   passed - Scenario: Property null check on non-null node.And no side effects
  Scenario: Property not null check on non-null node
   passed - Scenario: Property not null check on non-null node.Given an empty graph
   passed - Scenario: Property not null check on non-null node.And having executed:
   passed - Scenario: Property not null check on non-null node.When executing query:
   passed - Scenario: Property not null check on non-null node.Then the result should be:
   passed - Scenario: Property not null check on non-null node.And no side effects
  Scenario: Property null check on optional non-null node
   passed - Scenario: Property null check on optional non-null node.Given an empty graph
   passed - Scenario: Property null check on optional non-null node.And having executed:
   passed - Scenario: Property null check on optional non-null node.When executing query:
   passed - Scenario: Property null check on optional non-null node.Then the result should be:
   passed - Scenario: Property null check on optional non-null node.And no side effects
  Scenario: Property not null check on optional non-null node
   passed - Scenario: Property not null check on optional non-null node.Given an empty graph
   passed - Scenario: Property not null check on optional non-null node.And having executed:
   passed - Scenario: Property not null check on optional non-null node.When executing query:
   passed - Scenario: Property not null check on optional non-null node.Then the result should be:
   passed - Scenario: Property not null check on optional non-null node.And no side effects
  Scenario: Property null check on null node
   passed - Scenario: Property null check on null node.Given an empty graph
   passed - Scenario: Property null check on null node.When executing query:
   passed - Scenario: Property null check on null node.Then the result should be:
   passed - Scenario: Property null check on null node.And no side effects
  Scenario: Property not null check on null node
   passed - Scenario: Property not null check on null node.Given an empty graph
   passed - Scenario: Property not null check on null node.When executing query:
   passed - Scenario: Property not null check on null node.Then the result should be:
   passed - Scenario: Property not null check on null node.And no side effects
OptionalMatchAcceptanceTest
 Feature: OptionalMatchAcceptance
  Scenario: Respect predicates on the OPTIONAL MATCH
   passed - Scenario: Respect predicates on the OPTIONAL MATCH.Given an empty graph
   passed - Scenario: Respect predicates on the OPTIONAL MATCH.And having executed:
   passed - Scenario: Respect predicates on the OPTIONAL MATCH.When executing query:
   passed - Scenario: Respect predicates on the OPTIONAL MATCH.Then the result should be:
   passed - Scenario: Respect predicates on the OPTIONAL MATCH.And no side effects
  Scenario: Returning label predicate on null node
   passed - Scenario: Returning label predicate on null node.Given an empty graph
   passed - Scenario: Returning label predicate on null node.And having executed:
   passed - Scenario: Returning label predicate on null node.When executing query:
   error - Scenario: Returning label predicate on null node.Then the result should be:
   ignored - Scenario: Returning label predicate on null node.And no side effects
  Scenario: MATCH after OPTIONAL MATCH
   passed - Scenario: MATCH after OPTIONAL MATCH.Given an empty graph
   passed - Scenario: MATCH after OPTIONAL MATCH.And having executed:
   passed - Scenario: MATCH after OPTIONAL MATCH.When executing query:
   failed - Scenario: MATCH after OPTIONAL MATCH.Then the result should be:
   ignored - Scenario: MATCH after OPTIONAL MATCH.And no side effects
  Scenario: WITH after OPTIONAL MATCH
   passed - Scenario: WITH after OPTIONAL MATCH.Given an empty graph
   passed - Scenario: WITH after OPTIONAL MATCH.And having executed:
   passed - Scenario: WITH after OPTIONAL MATCH.When executing query:
   passed - Scenario: WITH after OPTIONAL MATCH.Then the result should be:
   passed - Scenario: WITH after OPTIONAL MATCH.And no side effects
  Scenario: Named paths in optional matches
   passed - Scenario: Named paths in optional matches.Given an empty graph
   passed - Scenario: Named paths in optional matches.And having executed:
   passed - Scenario: Named paths in optional matches.When executing query:
   failed - Scenario: Named paths in optional matches.Then the result should be:
   ignored - Scenario: Named paths in optional matches.And no side effects
  Scenario: OPTIONAL MATCH and bound nodes
   passed - Scenario: OPTIONAL MATCH and bound nodes.Given an empty graph
   passed - Scenario: OPTIONAL MATCH and bound nodes.And having executed:
   passed - Scenario: OPTIONAL MATCH and bound nodes.When executing query:
   failed - Scenario: OPTIONAL MATCH and bound nodes.Then the result should be:
   ignored - Scenario: OPTIONAL MATCH and bound nodes.And no side effects
  Scenario: OPTIONAL MATCH with labels on the optional end node
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.Given an empty graph
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.And having executed:
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.And having executed:
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.When executing query:
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.Then the result should be:
   passed - Scenario: OPTIONAL MATCH with labels on the optional end node.And no side effects
  Scenario: Optionally matching self-loops
   passed - Scenario: Optionally matching self-loops.Given an empty graph
   passed - Scenario: Optionally matching self-loops.And having executed:
   passed - Scenario: Optionally matching self-loops.When executing query:
   failed - Scenario: Optionally matching self-loops.Then the result should be:
   ignored - Scenario: Optionally matching self-loops.And no side effects
  Scenario: Optionally matching self-loops without matches
   passed - Scenario: Optionally matching self-loops without matches.Given an empty graph
   passed - Scenario: Optionally matching self-loops without matches.And having executed:
   passed - Scenario: Optionally matching self-loops without matches.When executing query:
   error - Scenario: Optionally matching self-loops without matches.Then the result should be:
   ignored - Scenario: Optionally matching self-loops without matches.And no side effects
  Scenario: Variable length optional relationships with bound nodes
   passed - Scenario: Variable length optional relationships with bound nodes.Given an empty graph
   passed - Scenario: Variable length optional relationships with bound nodes.And having executed:
   passed - Scenario: Variable length optional relationships with bound nodes.When executing query:
   error - Scenario: Variable length optional relationships with bound nodes.Then the result should be:
   ignored - Scenario: Variable length optional relationships with bound nodes.And no side effects
  Scenario: Longer pattern with bound nodes
   passed - Scenario: Longer pattern with bound nodes.Given an empty graph
   passed - Scenario: Longer pattern with bound nodes.And having executed:
   passed - Scenario: Longer pattern with bound nodes.When executing query:
   error - Scenario: Longer pattern with bound nodes.Then the result should be:
   ignored - Scenario: Longer pattern with bound nodes.And no side effects
  Scenario: Handling optional matches between optionally matched entities
   passed - Scenario: Handling optional matches between optionally matched entities.Given an empty graph
   passed - Scenario: Handling optional matches between optionally matched entities.And having executed:
   passed - Scenario: Handling optional matches between optionally matched entities.When executing query:
   passed - Scenario: Handling optional matches between optionally matched entities.Then the result should be:
   passed - Scenario: Handling optional matches between optionally matched entities.And no side effects
  Scenario: Handling optional matches between nulls
   passed - Scenario: Handling optional matches between nulls.Given an empty graph
   passed - Scenario: Handling optional matches between nulls.And having executed:
   passed - Scenario: Handling optional matches between nulls.When executing query:
   passed - Scenario: Handling optional matches between nulls.Then the result should be:
   passed - Scenario: Handling optional matches between nulls.And no side effects
  Scenario: OPTIONAL MATCH and `collect()`
   passed - )`.Given an empty graph(Scenario: OPTIONAL MATCH and `collect
   passed - )`.And having executed:(Scenario: OPTIONAL MATCH and `collect
   passed - )`.And having executed:(Scenario: OPTIONAL MATCH and `collect
   passed - )`.When executing query:(Scenario: OPTIONAL MATCH and `collect
   failed - )`.Then the result should be:(Scenario: OPTIONAL MATCH and `collect
   ignored - )`.And no side effects(Scenario: OPTIONAL MATCH and `collect
OptionalMatchTest
 Feature: OptionalMatch
  Scenario: Satisfies the open world assumption, relationships between same nodes
   passed - Scenario: Satisfies the open world assumption, relationships between same nodes.Given an empty graph
   passed - Scenario: Satisfies the open world assumption, relationships between same nodes.And having executed:
   passed - Scenario: Satisfies the open world assumption, relationships between same nodes.When executing query:
   failed - Scenario: Satisfies the open world assumption, relationships between same nodes.Then the result should be:
   ignored - Scenario: Satisfies the open world assumption, relationships between same nodes.And no side effects
  Scenario: Satisfies the open world assumption, single relationship
   passed - Scenario: Satisfies the open world assumption, single relationship.Given an empty graph
   passed - Scenario: Satisfies the open world assumption, single relationship.And having executed:
   passed - Scenario: Satisfies the open world assumption, single relationship.When executing query:
   passed - Scenario: Satisfies the open world assumption, single relationship.Then the result should be:
   passed - Scenario: Satisfies the open world assumption, single relationship.And no side effects
  Scenario: Satisfies the open world assumption, relationships between different nodes
   passed - Scenario: Satisfies the open world assumption, relationships between different nodes.Given an empty graph
   passed - Scenario: Satisfies the open world assumption, relationships between different nodes.And having executed:
   passed - Scenario: Satisfies the open world assumption, relationships between different nodes.When executing query:
   passed - Scenario: Satisfies the open world assumption, relationships between different nodes.Then the result should be:
   passed - Scenario: Satisfies the open world assumption, relationships between different nodes.And no side effects
OrderByAcceptanceTest
 Feature: OrderByAcceptance
  Scenario: ORDER BY should return results in ascending order
   passed - Scenario: ORDER BY should return results in ascending order.Given an empty graph
   passed - Scenario: ORDER BY should return results in ascending order.And having executed:
   passed - Scenario: ORDER BY should return results in ascending order.When executing query:
   passed - Scenario: ORDER BY should return results in ascending order.Then the result should be, in order:
   passed - Scenario: ORDER BY should return results in ascending order.And no side effects
  Scenario: ORDER BY DESC should return results in descending order
   passed - Scenario: ORDER BY DESC should return results in descending order.Given an empty graph
   passed - Scenario: ORDER BY DESC should return results in descending order.And having executed:
   passed - Scenario: ORDER BY DESC should return results in descending order.When executing query:
   passed - Scenario: ORDER BY DESC should return results in descending order.Then the result should be, in order:
   passed - Scenario: ORDER BY DESC should return results in descending order.And no side effects
  Scenario: ORDER BY of a column introduced in RETURN should return salient results in ascending order
   passed - Scenario: ORDER BY of a column introduced in RETURN should return salient results in ascending order.Given an empty graph
   passed - Scenario: ORDER BY of a column introduced in RETURN should return salient results in ascending order.When executing query:
   passed - Scenario: ORDER BY of a column introduced in RETURN should return salient results in ascending order.Then the result should be, in order:
   passed - Scenario: ORDER BY of a column introduced in RETURN should return salient results in ascending order.And no side effects
  Scenario: Renaming columns before ORDER BY should return results in ascending order
   passed - Scenario: Renaming columns before ORDER BY should return results in ascending order.Given an empty graph
   passed - Scenario: Renaming columns before ORDER BY should return results in ascending order.And having executed:
   passed - Scenario: Renaming columns before ORDER BY should return results in ascending order.When executing query:
   passed - Scenario: Renaming columns before ORDER BY should return results in ascending order.Then the result should be, in order:
   passed - Scenario: Renaming columns before ORDER BY should return results in ascending order.And no side effects
  Scenario: Handle projections with ORDER BY - GH#4937
   passed - Scenario: Handle projections with ORDER BY - GH#4937.Given an empty graph
   passed - Scenario: Handle projections with ORDER BY - GH#4937.And having executed:
   passed - Scenario: Handle projections with ORDER BY - GH#4937.When executing query:
   passed - Scenario: Handle projections with ORDER BY - GH#4937.Then the result should be, in order:
   passed - Scenario: Handle projections with ORDER BY - GH#4937.And no side effects
  Scenario: ORDER BY should order booleans in the expected order
   passed - Scenario: ORDER BY should order booleans in the expected order.Given an empty graph
   passed - Scenario: ORDER BY should order booleans in the expected order.When executing query:
   passed - Scenario: ORDER BY should order booleans in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY should order booleans in the expected order.And no side effects
  Scenario: ORDER BY DESC should order booleans in the expected order
   passed - Scenario: ORDER BY DESC should order booleans in the expected order.Given an empty graph
   passed - Scenario: ORDER BY DESC should order booleans in the expected order.When executing query:
   passed - Scenario: ORDER BY DESC should order booleans in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY DESC should order booleans in the expected order.And no side effects
  Scenario: ORDER BY should order strings in the expected order
   passed - Scenario: ORDER BY should order strings in the expected order.Given an empty graph
   passed - Scenario: ORDER BY should order strings in the expected order.When executing query:
   passed - Scenario: ORDER BY should order strings in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY should order strings in the expected order.And no side effects
  Scenario: ORDER BY DESC should order strings in the expected order
   passed - Scenario: ORDER BY DESC should order strings in the expected order.Given an empty graph
   passed - Scenario: ORDER BY DESC should order strings in the expected order.When executing query:
   passed - Scenario: ORDER BY DESC should order strings in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY DESC should order strings in the expected order.And no side effects
  Scenario: ORDER BY should order ints in the expected order
   passed - Scenario: ORDER BY should order ints in the expected order.Given an empty graph
   passed - Scenario: ORDER BY should order ints in the expected order.When executing query:
   passed - Scenario: ORDER BY should order ints in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY should order ints in the expected order.And no side effects
  Scenario: ORDER BY DESC should order ints in the expected order
   passed - Scenario: ORDER BY DESC should order ints in the expected order.Given an empty graph
   passed - Scenario: ORDER BY DESC should order ints in the expected order.When executing query:
   passed - Scenario: ORDER BY DESC should order ints in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY DESC should order ints in the expected order.And no side effects
  Scenario: ORDER BY should order floats in the expected order
   passed - Scenario: ORDER BY should order floats in the expected order.Given an empty graph
   passed - Scenario: ORDER BY should order floats in the expected order.When executing query:
   passed - Scenario: ORDER BY should order floats in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY should order floats in the expected order.And no side effects
  Scenario: ORDER BY DESC should order floats in the expected order
   passed - Scenario: ORDER BY DESC should order floats in the expected order.Given an empty graph
   passed - Scenario: ORDER BY DESC should order floats in the expected order.When executing query:
   passed - Scenario: ORDER BY DESC should order floats in the expected order.Then the result should be, in order:
   passed - Scenario: ORDER BY DESC should order floats in the expected order.And no side effects
  Scenario: Handle ORDER BY with LIMIT 1
   passed - Scenario: Handle ORDER BY with LIMIT 1.Given an empty graph
   passed - Scenario: Handle ORDER BY with LIMIT 1.And having executed:
   passed - Scenario: Handle ORDER BY with LIMIT 1.When executing query:
   passed - Scenario: Handle ORDER BY with LIMIT 1.Then the result should be, in order:
   passed - Scenario: Handle ORDER BY with LIMIT 1.And no side effects
  Scenario: ORDER BY with LIMIT 0 should not generate errors
   passed - Scenario: ORDER BY with LIMIT 0 should not generate errors.Given an empty graph
   passed - Scenario: ORDER BY with LIMIT 0 should not generate errors.When executing query:
   passed - Scenario: ORDER BY with LIMIT 0 should not generate errors.Then the result should be, in order:
   passed - Scenario: ORDER BY with LIMIT 0 should not generate errors.And no side effects
  Scenario: ORDER BY with negative parameter for LIMIT should not generate errors
   passed - Scenario: ORDER BY with negative parameter for LIMIT should not generate errors.Given an empty graph
   passed - Scenario: ORDER BY with negative parameter for LIMIT should not generate errors.And parameters are:
   passed - Scenario: ORDER BY with negative parameter for LIMIT should not generate errors.When executing query:
   passed - Scenario: ORDER BY with negative parameter for LIMIT should not generate errors.Then the result should be, in order:
   passed - Scenario: ORDER BY with negative parameter for LIMIT should not generate errors.And no side effects
  Scenario: ORDER BY with a negative LIMIT should fail with a syntax exception
   passed - Scenario: ORDER BY with a negative LIMIT should fail with a syntax exception.Given an empty graph
   passed - Scenario: ORDER BY with a negative LIMIT should fail with a syntax exception.And having executed:
   passed - Scenario: ORDER BY with a negative LIMIT should fail with a syntax exception.When executing query:
   passed - Scenario: ORDER BY with a negative LIMIT should fail with a syntax exception.Then a SyntaxError should be raised at compile time: NegativeIntegerArgument
PatternComprehensionTest
 Feature: PatternComprehension
  Scenario: Pattern comprehension and ORDER BY
   passed - Scenario: Pattern comprehension and ORDER BY.Given an empty graph
   passed - Scenario: Pattern comprehension and ORDER BY.And having executed:
   passed - Scenario: Pattern comprehension and ORDER BY.When executing query:
   error - Scenario: Pattern comprehension and ORDER BY.Then the result should be:
   ignored - Scenario: Pattern comprehension and ORDER BY.And no side effects
  Scenario: Returning a pattern comprehension
   passed - Scenario: Returning a pattern comprehension.Given an empty graph
   passed - Scenario: Returning a pattern comprehension.And having executed:
   passed - Scenario: Returning a pattern comprehension.When executing query:
   error - Scenario: Returning a pattern comprehension.Then the result should be:
   ignored - Scenario: Returning a pattern comprehension.And no side effects
  Scenario: Returning a pattern comprehension with label predicate
   passed - Scenario: Returning a pattern comprehension with label predicate.Given an empty graph
   passed - Scenario: Returning a pattern comprehension with label predicate.And having executed:
   passed - Scenario: Returning a pattern comprehension with label predicate.When executing query:
   error - Scenario: Returning a pattern comprehension with label predicate.Then the result should be:
   ignored - Scenario: Returning a pattern comprehension with label predicate.And no side effects
  Scenario: Returning a pattern comprehension with bound nodes
   passed - Scenario: Returning a pattern comprehension with bound nodes.Given an empty graph
   passed - Scenario: Returning a pattern comprehension with bound nodes.And having executed:
   passed - Scenario: Returning a pattern comprehension with bound nodes.When executing query:
   error - Scenario: Returning a pattern comprehension with bound nodes.Then the result should be:
   ignored - Scenario: Returning a pattern comprehension with bound nodes.And no side effects
  Scenario: Using a variable-length pattern comprehension in a WITH
   passed - Scenario: Using a variable-length pattern comprehension in a WITH.Given an empty graph
   passed - Scenario: Using a variable-length pattern comprehension in a WITH.And having executed:
   passed - Scenario: Using a variable-length pattern comprehension in a WITH.When executing query:
   error - Scenario: Using a variable-length pattern comprehension in a WITH.Then the result should be:
   ignored - Scenario: Using a variable-length pattern comprehension in a WITH.And no side effects
  Scenario: Using pattern comprehension in RETURN
   passed - Scenario: Using pattern comprehension in RETURN.Given an empty graph
   passed - Scenario: Using pattern comprehension in RETURN.And having executed:
   passed - Scenario: Using pattern comprehension in RETURN.When executing query:
   error - Scenario: Using pattern comprehension in RETURN.Then the result should be:
   ignored - Scenario: Using pattern comprehension in RETURN.And no side effects
  Scenario: Using pattern comprehension to test existence
   passed - Scenario: Using pattern comprehension to test existence.Given an empty graph
   passed - Scenario: Using pattern comprehension to test existence.And having executed:
   passed - Scenario: Using pattern comprehension to test existence.When executing query:
   error - Scenario: Using pattern comprehension to test existence.Then the result should be:
   ignored - Scenario: Using pattern comprehension to test existence.And no side effects
  Scenario: Pattern comprehension inside list comprehension
   passed - Scenario: Pattern comprehension inside list comprehension.Given an empty graph
   passed - Scenario: Pattern comprehension inside list comprehension.And having executed:
   passed - Scenario: Pattern comprehension inside list comprehension.When executing query:
   error - Scenario: Pattern comprehension inside list comprehension.Then the result should be:
   ignored - Scenario: Pattern comprehension inside list comprehension.And no side effects
  Scenario: Get node degree via size of pattern comprehension
   passed - Scenario: Get node degree via size of pattern comprehension.Given an empty graph
   passed - Scenario: Get node degree via size of pattern comprehension.And having executed:
   passed - Scenario: Get node degree via size of pattern comprehension.When executing query:
   error - Scenario: Get node degree via size of pattern comprehension.Then the result should be:
   ignored - Scenario: Get node degree via size of pattern comprehension.And no side effects
  Scenario: Get node degree via size of pattern comprehension that specifies a relationship type
   passed - Scenario: Get node degree via size of pattern comprehension that specifies a relationship type.Given an empty graph
   passed - Scenario: Get node degree via size of pattern comprehension that specifies a relationship type.And having executed:
   passed - Scenario: Get node degree via size of pattern comprehension that specifies a relationship type.When executing query:
   error - Scenario: Get node degree via size of pattern comprehension that specifies a relationship type.Then the result should be:
   ignored - Scenario: Get node degree via size of pattern comprehension that specifies a relationship type.And no side effects
  Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types
   passed - Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types.Given an empty graph
   passed - Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types.And having executed:
   passed - Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types.When executing query:
   error - Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types.Then the result should be:
   ignored - Scenario: Get node degree via size of pattern comprehension that specifies multiple relationship types.And no side effects
  Scenario: Introducing new node variable in pattern comprehension
   passed - Scenario: Introducing new node variable in pattern comprehension.Given an empty graph
   passed - Scenario: Introducing new node variable in pattern comprehension.And having executed:
   passed - Scenario: Introducing new node variable in pattern comprehension.When executing query:
   error - Scenario: Introducing new node variable in pattern comprehension.Then the result should be:
   ignored - Scenario: Introducing new node variable in pattern comprehension.And no side effects
  Scenario: Introducing new relationship variable in pattern comprehension
   passed - Scenario: Introducing new relationship variable in pattern comprehension.Given an empty graph
   passed - Scenario: Introducing new relationship variable in pattern comprehension.And having executed:
   passed - Scenario: Introducing new relationship variable in pattern comprehension.When executing query:
   error - Scenario: Introducing new relationship variable in pattern comprehension.Then the result should be:
   ignored - Scenario: Introducing new relationship variable in pattern comprehension.And no side effects
ProcedureCallAcceptanceTest
 Feature: ProcedureCallAcceptance
  Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly
   passed - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.When executing query:
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.Then a SyntaxError should be raised at compile time: InvalidArgumentPassingMode
  Scenario: Standalone call to procedure that takes no arguments
   passed - Scenario: Standalone call to procedure that takes no arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: Standalone call to procedure that takes no arguments.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure that takes no arguments.And no side effects
  Scenario: In-query call to procedure that takes no arguments
   passed - Scenario: In-query call to procedure that takes no arguments.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes no arguments.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: In-query call to procedure that takes no arguments.When executing query:
   ignored - Scenario: In-query call to procedure that takes no arguments.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure that takes no arguments.And no side effects
  Scenario: Calling the same procedure twice using the same outputs in each call
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.Given an empty graph
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call.When executing query:
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call.Then the result should be, in order:
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call.And no side effects
  Scenario: Standalone call to VOID procedure that takes no arguments
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.Given an empty graph
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments.When executing query:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments.Then the result should be empty
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments.And no side effects
  Scenario: In-query call to VOID procedure that takes no arguments
   passed - Scenario: In-query call to VOID procedure that takes no arguments.Given an empty graph
   ignored - Scenario: In-query call to VOID procedure that takes no arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments.When executing query:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments.Then the result should be:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments.And no side effects
  Scenario: In-query call to VOID procedure does not consume rows
   passed - Scenario: In-query call to VOID procedure does not consume rows.Given an empty graph
   ignored - Scenario: In-query call to VOID procedure does not consume rows.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: In-query call to VOID procedure does not consume rows.And having executed:
   ignored - Scenario: In-query call to VOID procedure does not consume rows.When executing query:
   ignored - Scenario: In-query call to VOID procedure does not consume rows.Then the result should be:
   ignored - Scenario: In-query call to VOID procedure does not consume rows.And no side effects
  Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.Then the result should be empty
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.And no side effects
  Scenario: In-query call to procedure that takes no arguments and yields no results
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results.When executing query:
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results.Then the result should be:
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results.And no side effects
  Scenario: Standalone call to procedure that takes no arguments and yields no results
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results.Then the result should be empty
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results.And no side effects
  Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.Then the result should be empty
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.And no side effects
  Scenario: In-query call to procedure with explicit arguments
   passed - Scenario: In-query call to procedure with explicit arguments.Given an empty graph
   ignored - Scenario: In-query call to procedure with explicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: In-query call to procedure with explicit arguments.When executing query:
   ignored - Scenario: In-query call to procedure with explicit arguments.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with explicit arguments.And no side effects
  Scenario: In-query call to procedure with explicit arguments that drops all result fields
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.Given an empty graph
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields.When executing query:
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields.And no side effects
  Scenario: Standalone call to procedure with explicit arguments
   passed - Scenario: Standalone call to procedure with explicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure with explicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: Standalone call to procedure with explicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure with explicit arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with explicit arguments.And no side effects
  Scenario: Standalone call to procedure with implicit arguments
   passed - Scenario: Standalone call to procedure with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure with implicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: Standalone call to procedure with implicit arguments.And parameters are:
   ignored - Scenario: Standalone call to procedure with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure with implicit arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with implicit arguments.And no side effects
  Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.And no side effects
  Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.And no side effects
  Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.And no side effects
  Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.And no side effects
  Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.And no side effects
  Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.And no side effects
  Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.And no side effects
  Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.And no side effects
  Scenario: Standalone call to procedure with null argument
   passed - Scenario: Standalone call to procedure with null argument.Given an empty graph
   ignored - Scenario: Standalone call to procedure with null argument.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with null argument.When executing query:
   ignored - Scenario: Standalone call to procedure with null argument.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with null argument.And no side effects
  Scenario: In-query call to procedure with null argument
   passed - Scenario: In-query call to procedure with null argument.Given an empty graph
   ignored - Scenario: In-query call to procedure with null argument.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with null argument.When executing query:
   ignored - Scenario: In-query call to procedure with null argument.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with null argument.And no side effects
  Scenario: Standalone call to procedure should fail if input type is wrong
   passed - Scenario: Standalone call to procedure should fail if input type is wrong.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: In-query call to procedure should fail if input type is wrong
   passed - Scenario: In-query call to procedure should fail if input type is wrong.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if input type is wrong.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if input type is wrong.When executing query:
   ignored - Scenario: In-query call to procedure should fail if input type is wrong.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Standalone call to procedure should fail if explicit argument is missing
   passed - Scenario: Standalone call to procedure should fail if explicit argument is missing.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
  Scenario: In-query call to procedure should fail if explicit argument is missing
   passed - Scenario: In-query call to procedure should fail if explicit argument is missing.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing.When executing query:
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
  Scenario: Standalone call to procedure should fail if too many explicit argument are given
   passed - Scenario: Standalone call to procedure should fail if too many explicit argument are given.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
  Scenario: In-query call to procedure should fail if too many explicit argument are given
   passed - Scenario: In-query call to procedure should fail if too many explicit argument are given.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given.When executing query:
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
  Scenario: Standalone call to procedure should fail if implicit argument is missing
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing.And parameters are:
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing.Then a ParameterMissing should be raised at compile time: MissingParameter
  Scenario: In-query call to procedure that has outputs fails if no outputs are yielded
   passed - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.Given an empty graph
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.When executing query:
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded
   passed - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.Given an empty graph
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.When executing query:
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Standalone call to unknown procedure should fail
   passed - Scenario: Standalone call to unknown procedure should fail.Given an empty graph
   passed - Scenario: Standalone call to unknown procedure should fail.When executing query:
   passed - Scenario: Standalone call to unknown procedure should fail.Then a ProcedureError should be raised at compile time: ProcedureNotFound
  Scenario: In-query call to unknown procedure should fail
   passed - Scenario: In-query call to unknown procedure should fail.Given an empty graph
   passed - Scenario: In-query call to unknown procedure should fail.When executing query:
   passed - Scenario: In-query call to unknown procedure should fail.Then a ProcedureError should be raised at compile time: ProcedureNotFound
  Scenario: In-query procedure call should fail if shadowing an already bound variable
   passed - Scenario: In-query procedure call should fail if shadowing an already bound variable.Given an empty graph
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable.When executing query:
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function
   passed - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.Given an empty graph
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.And there exists a procedure test.labels(in :: INTEGER?) :: (label :: STRING?):
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.When executing query:
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.Then a SyntaxError should be raised at compile time: InvalidAggregation
RemoveAcceptanceTest
 Feature: RemoveAcceptance
  Scenario: Should ignore nulls
   passed - Scenario: Should ignore nulls.Given an empty graph
   passed - Scenario: Should ignore nulls.And having executed:
   passed - Scenario: Should ignore nulls.When executing query:
   error - Scenario: Should ignore nulls.Then the result should be:
   ignored - Scenario: Should ignore nulls.And no side effects
  Scenario: Remove a single label
   passed - Scenario: Remove a single label.Given an empty graph
   passed - Scenario: Remove a single label.And having executed:
   passed - Scenario: Remove a single label.When executing query:
   passed - Scenario: Remove a single label.Then the result should be:
   passed - Scenario: Remove a single label.And the side effects should be:
  Scenario: Remove multiple labels
   passed - Scenario: Remove multiple labels.Given an empty graph
   passed - Scenario: Remove multiple labels.And having executed:
   passed - Scenario: Remove multiple labels.When executing query:
   passed - Scenario: Remove multiple labels.Then the result should be:
   passed - Scenario: Remove multiple labels.And the side effects should be:
  Scenario: Remove a single node property
   passed - Scenario: Remove a single node property.Given an empty graph
   passed - Scenario: Remove a single node property.And having executed:
   passed - Scenario: Remove a single node property.When executing query:
   error - Scenario: Remove a single node property.Then the result should be:
   ignored - Scenario: Remove a single node property.And the side effects should be:
  Scenario: Remove multiple node properties
   passed - Scenario: Remove multiple node properties.Given an empty graph
   passed - Scenario: Remove multiple node properties.And having executed:
   passed - Scenario: Remove multiple node properties.When executing query:
   error - Scenario: Remove multiple node properties.Then the result should be:
   ignored - Scenario: Remove multiple node properties.And the side effects should be:
  Scenario: Remove a single relationship property
   passed - Scenario: Remove a single relationship property.Given an empty graph
   passed - Scenario: Remove a single relationship property.And having executed:
   passed - Scenario: Remove a single relationship property.When executing query:
   error - Scenario: Remove a single relationship property.Then the result should be:
   ignored - Scenario: Remove a single relationship property.And the side effects should be:
  Scenario: Remove multiple relationship properties
   passed - Scenario: Remove multiple relationship properties.Given an empty graph
   error - Scenario: Remove multiple relationship properties.And having executed:
   ignored - Scenario: Remove multiple relationship properties.When executing query:
   ignored - Scenario: Remove multiple relationship properties.Then the result should be:
   ignored - Scenario: Remove multiple relationship properties.And the side effects should be:
  Scenario: Remove a missing property should be a valid operation
   passed - Scenario: Remove a missing property should be a valid operation.Given an empty graph
   passed - Scenario: Remove a missing property should be a valid operation.And having executed:
   passed - Scenario: Remove a missing property should be a valid operation.When executing query:
   error - Scenario: Remove a missing property should be a valid operation.Then the result should be:
   ignored - Scenario: Remove a missing property should be a valid operation.And no side effects
ReturnAcceptance2Test
 Feature: ReturnAcceptance2
  Scenario: Do not fail when returning type of deleted relationships
   passed - Scenario: Do not fail when returning type of deleted relationships.Given an empty graph
   passed - Scenario: Do not fail when returning type of deleted relationships.And having executed:
   passed - Scenario: Do not fail when returning type of deleted relationships.When executing query:
   passed - Scenario: Do not fail when returning type of deleted relationships.Then the result should be:
   passed - Scenario: Do not fail when returning type of deleted relationships.And the side effects should be:
  Scenario: Accept valid Unicode literal
   passed - Scenario: Accept valid Unicode literal.Given any graph
   passed - Scenario: Accept valid Unicode literal.When executing query:
   passed - Scenario: Accept valid Unicode literal.Then the result should be:
   passed - Scenario: Accept valid Unicode literal.And no side effects
  Scenario: LIMIT 0 should return an empty result
   passed - Scenario: LIMIT 0 should return an empty result.Given an empty graph
   passed - Scenario: LIMIT 0 should return an empty result.And having executed:
   passed - Scenario: LIMIT 0 should return an empty result.When executing query:
   passed - Scenario: LIMIT 0 should return an empty result.Then the result should be:
   passed - Scenario: LIMIT 0 should return an empty result.And no side effects
  Scenario: Fail when sorting on variable removed by DISTINCT
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.Given an empty graph
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.And having executed:
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.When executing query:
   ignored - Scenario: Fail when sorting on variable removed by DISTINCT.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Ordering with aggregation
   passed - Scenario: Ordering with aggregation.Given an empty graph
   passed - Scenario: Ordering with aggregation.And having executed:
   passed - Scenario: Ordering with aggregation.When executing query:
   passed - Scenario: Ordering with aggregation.Then the result should be:
   passed - Scenario: Ordering with aggregation.And no side effects
  Scenario: DISTINCT on nullable values
   passed - Scenario: DISTINCT on nullable values.Given an empty graph
   passed - Scenario: DISTINCT on nullable values.And having executed:
   passed - Scenario: DISTINCT on nullable values.When executing query:
   failed - Scenario: DISTINCT on nullable values.Then the result should be:
   ignored - Scenario: DISTINCT on nullable values.And no side effects
  Scenario: Return all variables
   passed - Scenario: Return all variables.Given an empty graph
   passed - Scenario: Return all variables.And having executed:
   passed - Scenario: Return all variables.When executing query:
   failed - Scenario: Return all variables.Then the result should be:
   ignored - Scenario: Return all variables.And no side effects
  Scenario: `sqrt()` returning float values
   passed - )` returning float values.Given any graph(Scenario: `sqrt
   passed - )` returning float values.When executing query:(Scenario: `sqrt
   passed - )` returning float values.Then the result should be:(Scenario: `sqrt
   passed - )` returning float values.And no side effects(Scenario: `sqrt
  Scenario: Matching and disregarding output, then matching again
   passed - Scenario: Matching and disregarding output, then matching again.Given an empty graph
   passed - Scenario: Matching and disregarding output, then matching again.And having executed:
   passed - Scenario: Matching and disregarding output, then matching again.When executing query:
   error - Scenario: Matching and disregarding output, then matching again.Then the result should be:
   ignored - Scenario: Matching and disregarding output, then matching again.And no side effects
  Scenario: Returning a list property
   passed - Scenario: Returning a list property.Given an empty graph
   passed - Scenario: Returning a list property.And having executed:
   passed - Scenario: Returning a list property.When executing query:
   failed - Scenario: Returning a list property.Then the result should be:
   ignored - Scenario: Returning a list property.And no side effects
  Scenario: Returning a projected map
   passed - Scenario: Returning a projected map.Given an empty graph
   passed - Scenario: Returning a projected map.And having executed:
   passed - Scenario: Returning a projected map.When executing query:
   passed - Scenario: Returning a projected map.Then the result should be:
   passed - Scenario: Returning a projected map.And no side effects
  Scenario: Returning an expression
   passed - Scenario: Returning an expression.Given an empty graph
   passed - Scenario: Returning an expression.And having executed:
   passed - Scenario: Returning an expression.When executing query:
   passed - Scenario: Returning an expression.Then the result should be:
   passed - Scenario: Returning an expression.And no side effects
  Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument
   passed - Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument.Given an empty graph
   passed - Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument.And having executed:
   passed - Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument.When executing query:
   failed - Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument.Then the result should be, in order:
   ignored - Scenario: Limiting amount of rows when there are fewer left than the LIMIT argument.And no side effects
  Scenario: `substring()` with default second argument
   passed - )` with default second argument.Given any graph(Scenario: `substring
   passed - )` with default second argument.When executing query:(Scenario: `substring
   error - )` with default second argument.Then the result should be:(Scenario: `substring
   ignored - )` with default second argument.And no side effects(Scenario: `substring
  Scenario: Returning all variables with ordering
   passed - Scenario: Returning all variables with ordering.Given an empty graph
   passed - Scenario: Returning all variables with ordering.And having executed:
   passed - Scenario: Returning all variables with ordering.When executing query:
   failed - Scenario: Returning all variables with ordering.Then the result should be, in order:
   ignored - Scenario: Returning all variables with ordering.And no side effects
  Scenario: Using aliased DISTINCT expression in ORDER BY
   passed - Scenario: Using aliased DISTINCT expression in ORDER BY.Given an empty graph
   passed - Scenario: Using aliased DISTINCT expression in ORDER BY.And having executed:
   passed - Scenario: Using aliased DISTINCT expression in ORDER BY.When executing query:
   passed - Scenario: Using aliased DISTINCT expression in ORDER BY.Then the result should be, in order:
   passed - Scenario: Using aliased DISTINCT expression in ORDER BY.And no side effects
  Scenario: Returned columns do not change from using ORDER BY
   passed - Scenario: Returned columns do not change from using ORDER BY.Given an empty graph
   passed - Scenario: Returned columns do not change from using ORDER BY.And having executed:
   passed - Scenario: Returned columns do not change from using ORDER BY.When executing query:
   passed - Scenario: Returned columns do not change from using ORDER BY.Then the result should be, in order:
   passed - Scenario: Returned columns do not change from using ORDER BY.And no side effects
  Scenario: Arithmetic expressions should propagate null values
   passed - Scenario: Arithmetic expressions should propagate null values.Given any graph
   passed - Scenario: Arithmetic expressions should propagate null values.When executing query:
   error - Scenario: Arithmetic expressions should propagate null values.Then the result should be:
   ignored - Scenario: Arithmetic expressions should propagate null values.And no side effects
  Scenario: Aliasing expressions
   passed - Scenario: Aliasing expressions.Given an empty graph
   passed - Scenario: Aliasing expressions.And having executed:
   passed - Scenario: Aliasing expressions.When executing query:
   error - Scenario: Aliasing expressions.Then the result should be:
   ignored - Scenario: Aliasing expressions.And no side effects
  Scenario: Projecting an arithmetic expression with aggregation
   passed - Scenario: Projecting an arithmetic expression with aggregation.Given an empty graph
   passed - Scenario: Projecting an arithmetic expression with aggregation.And having executed:
   passed - Scenario: Projecting an arithmetic expression with aggregation.When executing query:
   passed - Scenario: Projecting an arithmetic expression with aggregation.Then the result should be:
   passed - Scenario: Projecting an arithmetic expression with aggregation.And no side effects
  Scenario: Multiple aliasing and backreferencing
   passed - Scenario: Multiple aliasing and backreferencing.Given any graph
   passed - Scenario: Multiple aliasing and backreferencing.When executing query:
   passed - Scenario: Multiple aliasing and backreferencing.Then the result should be:
   passed - Scenario: Multiple aliasing and backreferencing.And the side effects should be:
  Scenario: Reusing variable names
   passed - Scenario: Reusing variable names.Given an empty graph
   passed - Scenario: Reusing variable names.And having executed:
   passed - Scenario: Reusing variable names.When executing query:
   passed - Scenario: Reusing variable names.Then the result should be, in order:
   passed - Scenario: Reusing variable names.And no side effects
  Scenario: DISTINCT inside aggregation should work with lists in maps
   passed - Scenario: DISTINCT inside aggregation should work with lists in maps.Given an empty graph
   passed - Scenario: DISTINCT inside aggregation should work with lists in maps.And having executed:
   passed - Scenario: DISTINCT inside aggregation should work with lists in maps.When executing query:
   failed - Scenario: DISTINCT inside aggregation should work with lists in maps.Then the result should be:
   ignored - Scenario: DISTINCT inside aggregation should work with lists in maps.And no side effects
  Scenario: DISTINCT inside aggregation should work with nested lists in maps
   passed - Scenario: DISTINCT inside aggregation should work with nested lists in maps.Given an empty graph
   passed - Scenario: DISTINCT inside aggregation should work with nested lists in maps.And having executed:
   passed - Scenario: DISTINCT inside aggregation should work with nested lists in maps.When executing query:
   failed - Scenario: DISTINCT inside aggregation should work with nested lists in maps.Then the result should be:
   ignored - Scenario: DISTINCT inside aggregation should work with nested lists in maps.And no side effects
  Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps
   passed - Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps.Given an empty graph
   passed - Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps.And having executed:
   passed - Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps.When executing query:
   failed - Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps.Then the result should be:
   ignored - Scenario: DISTINCT inside aggregation should work with nested lists of maps in maps.And no side effects
ReturnAcceptanceTest
 Feature: ReturnAcceptanceTest
  Scenario: Allow addition
   passed - Scenario: Allow addition.Given an empty graph
   passed - Scenario: Allow addition.And having executed:
   passed - Scenario: Allow addition.When executing query:
   passed - Scenario: Allow addition.Then the result should be:
   passed - Scenario: Allow addition.And no side effects
  Scenario: Limit to two hits
   passed - Scenario: Limit to two hits.Given an empty graph
   passed - Scenario: Limit to two hits.When executing query:
   passed - Scenario: Limit to two hits.Then the result should be:
   passed - Scenario: Limit to two hits.And no side effects
  Scenario: Limit to two hits with explicit order
   passed - Scenario: Limit to two hits with explicit order.Given an empty graph
   passed - Scenario: Limit to two hits with explicit order.And having executed:
   passed - Scenario: Limit to two hits with explicit order.When executing query:
   passed - Scenario: Limit to two hits with explicit order.Then the result should be:
   passed - Scenario: Limit to two hits with explicit order.And no side effects
  Scenario: Start the result from the second row
   passed - Scenario: Start the result from the second row.Given an empty graph
   passed - Scenario: Start the result from the second row.And having executed:
   passed - Scenario: Start the result from the second row.When executing query:
   failed - Scenario: Start the result from the second row.Then the result should be, in order:
   ignored - Scenario: Start the result from the second row.And no side effects
  Scenario: Start the result from the second row by param
   passed - Scenario: Start the result from the second row by param.Given an empty graph
   passed - Scenario: Start the result from the second row by param.And having executed:
   passed - Scenario: Start the result from the second row by param.And parameters are:
   passed - Scenario: Start the result from the second row by param.When executing query:
   failed - Scenario: Start the result from the second row by param.Then the result should be, in order:
   ignored - Scenario: Start the result from the second row by param.And no side effects
  Scenario: Get rows in the middle
   passed - Scenario: Get rows in the middle.Given an empty graph
   passed - Scenario: Get rows in the middle.And having executed:
   passed - Scenario: Get rows in the middle.When executing query:
   failed - Scenario: Get rows in the middle.Then the result should be, in order:
   ignored - Scenario: Get rows in the middle.And no side effects
  Scenario: Get rows in the middle by param
   passed - Scenario: Get rows in the middle by param.Given an empty graph
   passed - Scenario: Get rows in the middle by param.And having executed:
   passed - Scenario: Get rows in the middle by param.And parameters are:
   passed - Scenario: Get rows in the middle by param.When executing query:
   failed - Scenario: Get rows in the middle by param.Then the result should be, in order:
   ignored - Scenario: Get rows in the middle by param.And no side effects
  Scenario: Sort on aggregated function
   passed - Scenario: Sort on aggregated function.Given an empty graph
   passed - Scenario: Sort on aggregated function.And having executed:
   passed - Scenario: Sort on aggregated function.When executing query:
   failed - Scenario: Sort on aggregated function.Then the result should be, in order:
   ignored - Scenario: Sort on aggregated function.And no side effects
  Scenario: Support sort and distinct
   passed - Scenario: Support sort and distinct.Given an empty graph
   passed - Scenario: Support sort and distinct.And having executed:
   passed - Scenario: Support sort and distinct.When executing query:
   passed - Scenario: Support sort and distinct.Then the result should be, in order:
   passed - Scenario: Support sort and distinct.And no side effects
  Scenario: Support column renaming
   passed - Scenario: Support column renaming.Given an empty graph
   passed - Scenario: Support column renaming.And having executed:
   passed - Scenario: Support column renaming.When executing query:
   passed - Scenario: Support column renaming.Then the result should be:
   passed - Scenario: Support column renaming.And no side effects
  Scenario: Support ordering by a property after being distinct-ified
   passed - Scenario: Support ordering by a property after being distinct-ified.Given an empty graph
   passed - Scenario: Support ordering by a property after being distinct-ified.And having executed:
   passed - Scenario: Support ordering by a property after being distinct-ified.When executing query:
   passed - Scenario: Support ordering by a property after being distinct-ified.Then the result should be, in order:
   passed - Scenario: Support ordering by a property after being distinct-ified.And no side effects
  Scenario: Arithmetic precedence test
   passed - Scenario: Arithmetic precedence test.Given any graph
   passed - Scenario: Arithmetic precedence test.When executing query:
   passed - Scenario: Arithmetic precedence test.Then the result should be:
   passed - Scenario: Arithmetic precedence test.And no side effects
  Scenario: Arithmetic precedence with parenthesis test
   passed - Scenario: Arithmetic precedence with parenthesis test.Given any graph
   passed - Scenario: Arithmetic precedence with parenthesis test.When executing query:
   passed - Scenario: Arithmetic precedence with parenthesis test.Then the result should be:
   passed - Scenario: Arithmetic precedence with parenthesis test.And no side effects
  Scenario: Count star should count everything in scope
   passed - Scenario: Count star should count everything in scope.Given an empty graph
   passed - Scenario: Count star should count everything in scope.And having executed:
   passed - Scenario: Count star should count everything in scope.When executing query:
   failed - Scenario: Count star should count everything in scope.Then the result should be:
   ignored - Scenario: Count star should count everything in scope.And no side effects
  Scenario: Absolute function
   passed - Scenario: Absolute function.Given any graph
   passed - Scenario: Absolute function.When executing query:
   passed - Scenario: Absolute function.Then the result should be:
   passed - Scenario: Absolute function.And no side effects
SemanticErrorAcceptanceTest
 Feature: SemanticErrorAcceptance
  Scenario: Failing when returning an undefined variable
   passed - Scenario: Failing when returning an undefined variable.Given any graph
   passed - Scenario: Failing when returning an undefined variable.When executing query:
   ignored - Scenario: Failing when returning an undefined variable.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when comparing to an undefined variable
   passed - Scenario: Failing when comparing to an undefined variable.Given any graph
   passed - Scenario: Failing when comparing to an undefined variable.When executing query:
   ignored - Scenario: Failing when comparing to an undefined variable.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using IN on a string literal
   passed - Scenario: Failing when using IN on a string literal.Given any graph
   passed - Scenario: Failing when using IN on a string literal.When executing query:
   ignored - Scenario: Failing when using IN on a string literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when using IN on an integer literal
   passed - Scenario: Failing when using IN on an integer literal.Given any graph
   passed - Scenario: Failing when using IN on an integer literal.When executing query:
   ignored - Scenario: Failing when using IN on an integer literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when using IN on a float literal
   passed - Scenario: Failing when using IN on a float literal.Given any graph
   passed - Scenario: Failing when using IN on a float literal.When executing query:
   ignored - Scenario: Failing when using IN on a float literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when using IN on a boolean literal
   passed - Scenario: Failing when using IN on a boolean literal.Given any graph
   passed - Scenario: Failing when using IN on a boolean literal.When executing query:
   ignored - Scenario: Failing when using IN on a boolean literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when a node is used as a relationship
   passed - Scenario: Failing when a node is used as a relationship.Given any graph
   passed - Scenario: Failing when a node is used as a relationship.When executing query:
   ignored - Scenario: Failing when a node is used as a relationship.Then a SyntaxError should be raised at compile time: VariableTypeConflict
  Scenario: Failing when a relationship is used as a node
   passed - Scenario: Failing when a relationship is used as a node.Given any graph
   passed - Scenario: Failing when a relationship is used as a node.When executing query:
   ignored - Scenario: Failing when a relationship is used as a node.Then a SyntaxError should be raised at compile time: VariableTypeConflict
  Scenario: Failing when using `type()` on a node
   passed - )` on a node.Given any graph(Scenario: Failing when using `type
   passed - )` on a node.When executing query:(Scenario: Failing when using `type
   ignored - )` on a node.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `type
  Scenario: Failing when using `length()` on a node
   passed - )` on a node.Given any graph(Scenario: Failing when using `length
   passed - )` on a node.When executing query:(Scenario: Failing when using `length
   ignored - )` on a node.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `length
  Scenario: Failing when re-using a relationship in the same pattern
   passed - Scenario: Failing when re-using a relationship in the same pattern.Given any graph
   passed - Scenario: Failing when re-using a relationship in the same pattern.When executing query:
   ignored - Scenario: Failing when re-using a relationship in the same pattern.Then a SyntaxError should be raised at compile time: RelationshipUniquenessViolation
  Scenario: Failing when using NOT on string literal
   passed - Scenario: Failing when using NOT on string literal.Given any graph
   passed - Scenario: Failing when using NOT on string literal.When executing query:
   passed - Scenario: Failing when using NOT on string literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when using variable length relationship in CREATE
   passed - Scenario: Failing when using variable length relationship in CREATE.Given any graph
   passed - Scenario: Failing when using variable length relationship in CREATE.When executing query:
   ignored - Scenario: Failing when using variable length relationship in CREATE.Then a SyntaxError should be raised at compile time: CreatingVarLength
  Scenario: Failing when using variable length relationship in MERGE
   passed - Scenario: Failing when using variable length relationship in MERGE.Given any graph
   passed - Scenario: Failing when using variable length relationship in MERGE.When executing query:
   ignored - Scenario: Failing when using variable length relationship in MERGE.Then a SyntaxError should be raised at compile time: CreatingVarLength
  Scenario: Failing when using parameter as node predicate in MATCH
   passed - Scenario: Failing when using parameter as node predicate in MATCH.Given any graph
   passed - Scenario: Failing when using parameter as node predicate in MATCH.When executing query:
   passed - Scenario: Failing when using parameter as node predicate in MATCH.Then a SyntaxError should be raised at compile time: InvalidParameterUse
  Scenario: Failing when using parameter as relationship predicate in MATCH
   passed - Scenario: Failing when using parameter as relationship predicate in MATCH.Given any graph
   passed - Scenario: Failing when using parameter as relationship predicate in MATCH.When executing query:
   passed - Scenario: Failing when using parameter as relationship predicate in MATCH.Then a SyntaxError should be raised at compile time: InvalidParameterUse
  Scenario: Failing when using parameter as node predicate in MERGE
   passed - Scenario: Failing when using parameter as node predicate in MERGE.Given any graph
   passed - Scenario: Failing when using parameter as node predicate in MERGE.When executing query:
   passed - Scenario: Failing when using parameter as node predicate in MERGE.Then a SyntaxError should be raised at compile time: InvalidParameterUse
  Scenario: Failing when using parameter as relationship predicate in MERGE
   passed - Scenario: Failing when using parameter as relationship predicate in MERGE.Given any graph
   passed - Scenario: Failing when using parameter as relationship predicate in MERGE.When executing query:
   passed - Scenario: Failing when using parameter as relationship predicate in MERGE.Then a SyntaxError should be raised at compile time: InvalidParameterUse
  Scenario: Failing when deleting an integer expression
   passed - Scenario: Failing when deleting an integer expression.Given any graph
   passed - Scenario: Failing when deleting an integer expression.When executing query:
   ignored - Scenario: Failing when deleting an integer expression.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when using CREATE on a node that is already bound
   passed - Scenario: Failing when using CREATE on a node that is already bound.Given any graph
   passed - Scenario: Failing when using CREATE on a node that is already bound.When executing query:
   ignored - Scenario: Failing when using CREATE on a node that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using MERGE on a node that is already bound
   passed - Scenario: Failing when using MERGE on a node that is already bound.Given any graph
   passed - Scenario: Failing when using MERGE on a node that is already bound.When executing query:
   ignored - Scenario: Failing when using MERGE on a node that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using CREATE on a relationship that is already bound
   passed - Scenario: Failing when using CREATE on a relationship that is already bound.Given any graph
   passed - Scenario: Failing when using CREATE on a relationship that is already bound.When executing query:
   ignored - Scenario: Failing when using CREATE on a relationship that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using MERGE on a relationship that is already bound
   passed - Scenario: Failing when using MERGE on a relationship that is already bound.Given any graph
   passed - Scenario: Failing when using MERGE on a relationship that is already bound.When executing query:
   ignored - Scenario: Failing when using MERGE on a relationship that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
  Scenario: Failing when using undefined variable in ON CREATE
   passed - Scenario: Failing when using undefined variable in ON CREATE.Given any graph
   passed - Scenario: Failing when using undefined variable in ON CREATE.When executing query:
   ignored - Scenario: Failing when using undefined variable in ON CREATE.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using undefined variable in ON MATCH
   passed - Scenario: Failing when using undefined variable in ON MATCH.Given any graph
   passed - Scenario: Failing when using undefined variable in ON MATCH.When executing query:
   ignored - Scenario: Failing when using undefined variable in ON MATCH.Then a SyntaxError should be raised at compile time: UndefinedVariable
  Scenario: Failing when using MATCH after OPTIONAL MATCH
   passed - Scenario: Failing when using MATCH after OPTIONAL MATCH.Given any graph
   passed - Scenario: Failing when using MATCH after OPTIONAL MATCH.When executing query:
   passed - Scenario: Failing when using MATCH after OPTIONAL MATCH.Then a SyntaxError should be raised at compile time: InvalidClauseComposition
  Scenario: Failing when float value is too large
   passed - Scenario: Failing when float value is too large.Given any graph
   passed - Scenario: Failing when float value is too large.When executing query:
   ignored - Scenario: Failing when float value is too large.Then a SyntaxError should be raised at compile time: FloatingPointOverflow
  Scenario: Handling property access on the Any type
   passed - Scenario: Handling property access on the Any type.Given any graph
   passed - Scenario: Handling property access on the Any type.When executing query:
   passed - Scenario: Handling property access on the Any type.Then the result should be:
   passed - Scenario: Handling property access on the Any type.And no side effects
  Scenario: Failing when performing property access on a non-map 1
   passed - Scenario: Failing when performing property access on a non-map 1.Given any graph
   passed - Scenario: Failing when performing property access on a non-map 1.When executing query:
   passed - Scenario: Failing when performing property access on a non-map 1.Then a TypeError should be raised at runtime: PropertyAccessOnNonMap
  Scenario: Failing when performing property access on a non-map 2
   passed - Scenario: Failing when performing property access on a non-map 2.Given any graph
   passed - Scenario: Failing when performing property access on a non-map 2.When executing query:
   passed - Scenario: Failing when performing property access on a non-map 2.Then a TypeError should be raised at runtime: PropertyAccessOnNonMap
  Scenario: Failing when checking existence of a non-property and non-pattern
   passed - Scenario: Failing when checking existence of a non-property and non-pattern.Given any graph
   passed - Scenario: Failing when checking existence of a non-property and non-pattern.When executing query:
   ignored - Scenario: Failing when checking existence of a non-property and non-pattern.Then a SyntaxError should be raised at compile time: InvalidArgumentExpression
  Scenario: Bad arguments for `range()`
   passed - )`.Given any graph(Scenario: Bad arguments for `range
   passed - )`.When executing query:(Scenario: Bad arguments for `range
   passed - )`.Then a ArgumentError should be raised at runtime: NumberOutOfRange(Scenario: Bad arguments for `range
  Scenario: Fail for invalid Unicode hyphen in subtraction
   passed - Scenario: Fail for invalid Unicode hyphen in subtraction.Given any graph
   passed - Scenario: Fail for invalid Unicode hyphen in subtraction.When executing query:
   passed - Scenario: Fail for invalid Unicode hyphen in subtraction.Then a SyntaxError should be raised at compile time: InvalidUnicodeCharacter
  Scenario: Failing for `size()` on paths
   passed - )` on paths.Given any graph(Scenario: Failing for `size
   passed - )` on paths.When executing query:(Scenario: Failing for `size
   ignored - )` on paths.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing for `size
  Scenario: Failing when using aggregation in list comprehension
   passed - Scenario: Failing when using aggregation in list comprehension.Given any graph
   passed - Scenario: Failing when using aggregation in list comprehension.When executing query:
   ignored - Scenario: Failing when using aggregation in list comprehension.Then a SyntaxError should be raised at compile time: InvalidAggregation
  Scenario: Failing when using non-constants in SKIP
   passed - Scenario: Failing when using non-constants in SKIP.Given any graph
   passed - Scenario: Failing when using non-constants in SKIP.When executing query:
   ignored - Scenario: Failing when using non-constants in SKIP.Then a SyntaxError should be raised at compile time: NonConstantExpression
  Scenario: Failing when using negative value in SKIP
   passed - Scenario: Failing when using negative value in SKIP.Given any graph
   passed - Scenario: Failing when using negative value in SKIP.When executing query:
   ignored - Scenario: Failing when using negative value in SKIP.Then a SyntaxError should be raised at compile time: NegativeIntegerArgument
  Scenario: Failing when using non-constants in LIMIT
   passed - Scenario: Failing when using non-constants in LIMIT.Given any graph
   passed - Scenario: Failing when using non-constants in LIMIT.When executing query:
   ignored - Scenario: Failing when using non-constants in LIMIT.Then a SyntaxError should be raised at compile time: NonConstantExpression
  Scenario: Failing when using negative value in LIMIT
   passed - Scenario: Failing when using negative value in LIMIT.Given any graph
   passed - Scenario: Failing when using negative value in LIMIT.When executing query:
   passed - Scenario: Failing when using negative value in LIMIT.Then a SyntaxError should be raised at compile time: NegativeIntegerArgument
  Scenario: Failing when using floating point in LIMIT
   passed - Scenario: Failing when using floating point in LIMIT.Given any graph
   passed - Scenario: Failing when using floating point in LIMIT.When executing query:
   ignored - Scenario: Failing when using floating point in LIMIT.Then a SyntaxError should be raised at compile time: InvalidArgumentType
  Scenario: Failing when creating relationship without type
   passed - Scenario: Failing when creating relationship without type.Given any graph
   passed - Scenario: Failing when creating relationship without type.When executing query:
   ignored - Scenario: Failing when creating relationship without type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
  Scenario: Failing when merging relationship without type
   passed - Scenario: Failing when merging relationship without type.Given any graph
   passed - Scenario: Failing when merging relationship without type.When executing query:
   ignored - Scenario: Failing when merging relationship without type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
  Scenario: Failing when merging relationship without type, no colon
   passed - Scenario: Failing when merging relationship without type, no colon.Given any graph
   passed - Scenario: Failing when merging relationship without type, no colon.When executing query:
   ignored - Scenario: Failing when merging relationship without type, no colon.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
  Scenario: Failing when creating relationship with more than one type
   passed - Scenario: Failing when creating relationship with more than one type.Given any graph
   passed - Scenario: Failing when creating relationship with more than one type.When executing query:
   passed - Scenario: Failing when creating relationship with more than one type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
  Scenario: Failing when merging relationship with more than one type
   passed - Scenario: Failing when merging relationship with more than one type.Given any graph
   passed - Scenario: Failing when merging relationship with more than one type.When executing query:
   passed - Scenario: Failing when merging relationship with more than one type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
SetAcceptanceTest
 Feature: SetAcceptance
  Scenario: Setting a node property to null removes the existing property
   passed - Scenario: Setting a node property to null removes the existing property.Given an empty graph
   passed - Scenario: Setting a node property to null removes the existing property.And having executed:
   passed - Scenario: Setting a node property to null removes the existing property.When executing query:
   passed - Scenario: Setting a node property to null removes the existing property.Then the result should be:
   passed - Scenario: Setting a node property to null removes the existing property.And the side effects should be:
  Scenario: Setting a relationship property to null removes the existing property
   passed - Scenario: Setting a relationship property to null removes the existing property.Given an empty graph
   passed - Scenario: Setting a relationship property to null removes the existing property.And having executed:
   passed - Scenario: Setting a relationship property to null removes the existing property.When executing query:
   passed - Scenario: Setting a relationship property to null removes the existing property.Then the result should be:
   passed - Scenario: Setting a relationship property to null removes the existing property.And the side effects should be:
  Scenario: Set a property by selecting the node using a simple expression
   passed - Scenario: Set a property by selecting the node using a simple expression.Given an empty graph
   passed - Scenario: Set a property by selecting the node using a simple expression.And having executed:
   passed - Scenario: Set a property by selecting the node using a simple expression.When executing query:
   passed - Scenario: Set a property by selecting the node using a simple expression.Then the result should be:
   passed - Scenario: Set a property by selecting the node using a simple expression.And the side effects should be:
  Scenario: Set a property by selecting the relationship using a simple expression
   passed - Scenario: Set a property by selecting the relationship using a simple expression.Given an empty graph
   passed - Scenario: Set a property by selecting the relationship using a simple expression.And having executed:
   passed - Scenario: Set a property by selecting the relationship using a simple expression.When executing query:
   passed - Scenario: Set a property by selecting the relationship using a simple expression.Then the result should be:
   passed - Scenario: Set a property by selecting the relationship using a simple expression.And the side effects should be:
  Scenario: Setting a property to null removes the property
   passed - Scenario: Setting a property to null removes the property.Given an empty graph
   passed - Scenario: Setting a property to null removes the property.And having executed:
   passed - Scenario: Setting a property to null removes the property.When executing query:
   passed - Scenario: Setting a property to null removes the property.Then the result should be:
   passed - Scenario: Setting a property to null removes the property.And the side effects should be:
  Scenario: Add a label to a node
   passed - Scenario: Add a label to a node.Given an empty graph
   passed - Scenario: Add a label to a node.And having executed:
   passed - Scenario: Add a label to a node.When executing query:
   passed - Scenario: Add a label to a node.Then the result should be:
   passed - Scenario: Add a label to a node.And the side effects should be:
  Scenario: Adding a list property
   passed - Scenario: Adding a list property.Given an empty graph
   passed - Scenario: Adding a list property.And having executed:
   passed - Scenario: Adding a list property.When executing query:
   passed - Scenario: Adding a list property.Then the result should be:
   passed - Scenario: Adding a list property.And the side effects should be:
  Scenario: Retain old values when using +=
   passed - Scenario: Retain old values when using +=.Given an empty graph
   passed - Scenario: Retain old values when using +=.And having executed:
   passed - Scenario: Retain old values when using +=.When executing query:
   passed - Scenario: Retain old values when using +=.Then the result should be:
   passed - Scenario: Retain old values when using +=.And the side effects should be:
  Scenario: Explicit null values in a map remove old values
   passed - Scenario: Explicit null values in a map remove old values.Given an empty graph
   passed - Scenario: Explicit null values in a map remove old values.And having executed:
   passed - Scenario: Explicit null values in a map remove old values.When executing query:
   passed - Scenario: Explicit null values in a map remove old values.Then the result should be:
   passed - Scenario: Explicit null values in a map remove old values.And the side effects should be:
SkipLimitAcceptanceTest
 Feature: SkipLimitAcceptanceTest
  Scenario: SKIP with an expression that depends on variables should fail
   passed - Scenario: SKIP with an expression that depends on variables should fail.Given any graph
   passed - Scenario: SKIP with an expression that depends on variables should fail.When executing query:
   ignored - Scenario: SKIP with an expression that depends on variables should fail.Then a SyntaxError should be raised at compile time: NonConstantExpression
  Scenario: LIMIT with an expression that depends on variables should fail
   passed - Scenario: LIMIT with an expression that depends on variables should fail.Given any graph
   passed - Scenario: LIMIT with an expression that depends on variables should fail.When executing query:
   ignored - Scenario: LIMIT with an expression that depends on variables should fail.Then a SyntaxError should be raised at compile time: NonConstantExpression
  Scenario: SKIP with an expression that does not depend on variables
   passed - Scenario: SKIP with an expression that does not depend on variables.Given any graph
   passed - Scenario: SKIP with an expression that does not depend on variables.And having executed:
   passed - Scenario: SKIP with an expression that does not depend on variables.When executing query:
   passed - Scenario: SKIP with an expression that does not depend on variables.Then the result should be:
   passed - Scenario: SKIP with an expression that does not depend on variables.And no side effects
  Scenario: LIMIT with an expression that does not depend on variables
   passed - Scenario: LIMIT with an expression that does not depend on variables.Given any graph
   passed - Scenario: LIMIT with an expression that does not depend on variables.And having executed:
   passed - Scenario: LIMIT with an expression that does not depend on variables.When executing query:
   passed - Scenario: LIMIT with an expression that does not depend on variables.Then the result should be:
   passed - Scenario: LIMIT with an expression that does not depend on variables.And no side effects
StartingPointAcceptanceTest
 Feature: StartingPointAcceptance
  Scenario: Find all nodes
   passed - Scenario: Find all nodes.Given an empty graph
   passed - Scenario: Find all nodes.And having executed:
   passed - Scenario: Find all nodes.When executing query:
   passed - Scenario: Find all nodes.Then the result should be:
   passed - Scenario: Find all nodes.And no side effects
  Scenario: Find labelled nodes
   passed - Scenario: Find labelled nodes.Given an empty graph
   passed - Scenario: Find labelled nodes.And having executed:
   passed - Scenario: Find labelled nodes.When executing query:
   passed - Scenario: Find labelled nodes.Then the result should be:
   passed - Scenario: Find labelled nodes.And no side effects
  Scenario: Find nodes by property
   passed - Scenario: Find nodes by property.Given an empty graph
   passed - Scenario: Find nodes by property.And having executed:
   passed - Scenario: Find nodes by property.When executing query:
   passed - Scenario: Find nodes by property.Then the result should be:
   passed - Scenario: Find nodes by property.And no side effects
StartsWithAcceptanceTest
 Feature: StartsWithAcceptance
  Scenario: Finding exact matches
   passed - Scenario: Finding exact matches.Given an empty graph
   passed - Scenario: Finding exact matches.And having executed:
   passed - Scenario: Finding exact matches.When executing query:
   passed - Scenario: Finding exact matches.Then the result should be:
   passed - Scenario: Finding exact matches.And no side effects
  Scenario: Finding beginning of string
   passed - Scenario: Finding beginning of string.Given an empty graph
   passed - Scenario: Finding beginning of string.And having executed:
   passed - Scenario: Finding beginning of string.When executing query:
   passed - Scenario: Finding beginning of string.Then the result should be:
   passed - Scenario: Finding beginning of string.And no side effects
  Scenario: Finding end of string 1
   passed - Scenario: Finding end of string 1.Given an empty graph
   passed - Scenario: Finding end of string 1.And having executed:
   passed - Scenario: Finding end of string 1.When executing query:
   passed - Scenario: Finding end of string 1.Then the result should be:
   passed - Scenario: Finding end of string 1.And no side effects
  Scenario: Finding end of string 2
   passed - Scenario: Finding end of string 2.Given an empty graph
   passed - Scenario: Finding end of string 2.And having executed:
   passed - Scenario: Finding end of string 2.When executing query:
   passed - Scenario: Finding end of string 2.Then the result should be:
   passed - Scenario: Finding end of string 2.And no side effects
  Scenario: Finding middle of string
   passed - Scenario: Finding middle of string.Given an empty graph
   passed - Scenario: Finding middle of string.And having executed:
   passed - Scenario: Finding middle of string.When executing query:
   passed - Scenario: Finding middle of string.Then the result should be:
   passed - Scenario: Finding middle of string.And no side effects
  Scenario: Finding the empty string
   passed - Scenario: Finding the empty string.Given an empty graph
   passed - Scenario: Finding the empty string.And having executed:
   passed - Scenario: Finding the empty string.When executing query:
   passed - Scenario: Finding the empty string.Then the result should be:
   passed - Scenario: Finding the empty string.And no side effects
  Scenario: Finding when the middle is known
   passed - Scenario: Finding when the middle is known.Given an empty graph
   passed - Scenario: Finding when the middle is known.And having executed:
   passed - Scenario: Finding when the middle is known.When executing query:
   passed - Scenario: Finding when the middle is known.Then the result should be:
   passed - Scenario: Finding when the middle is known.And no side effects
  Scenario: Finding strings starting with whitespace
   passed - Scenario: Finding strings starting with whitespace.Given an empty graph
   passed - Scenario: Finding strings starting with whitespace.And having executed:
   passed - Scenario: Finding strings starting with whitespace.And having executed:
   passed - Scenario: Finding strings starting with whitespace.When executing query:
   passed - Scenario: Finding strings starting with whitespace.Then the result should be:
   passed - Scenario: Finding strings starting with whitespace.And no side effects
  Scenario: Finding strings starting with newline
   passed - Scenario: Finding strings starting with newline.Given an empty graph
   passed - Scenario: Finding strings starting with newline.And having executed:
   passed - Scenario: Finding strings starting with newline.And having executed:
   passed - Scenario: Finding strings starting with newline.When executing query:
   passed - Scenario: Finding strings starting with newline.Then the result should be:
   passed - Scenario: Finding strings starting with newline.And no side effects
  Scenario: Finding strings ending with newline
   passed - Scenario: Finding strings ending with newline.Given an empty graph
   passed - Scenario: Finding strings ending with newline.And having executed:
   passed - Scenario: Finding strings ending with newline.And having executed:
   passed - Scenario: Finding strings ending with newline.When executing query:
   passed - Scenario: Finding strings ending with newline.Then the result should be:
   passed - Scenario: Finding strings ending with newline.And no side effects
  Scenario: Finding strings ending with whitespace
   passed - Scenario: Finding strings ending with whitespace.Given an empty graph
   passed - Scenario: Finding strings ending with whitespace.And having executed:
   passed - Scenario: Finding strings ending with whitespace.And having executed:
   passed - Scenario: Finding strings ending with whitespace.When executing query:
   passed - Scenario: Finding strings ending with whitespace.Then the result should be:
   passed - Scenario: Finding strings ending with whitespace.And no side effects
  Scenario: Finding strings containing whitespace
   passed - Scenario: Finding strings containing whitespace.Given an empty graph
   passed - Scenario: Finding strings containing whitespace.And having executed:
   passed - Scenario: Finding strings containing whitespace.And having executed:
   passed - Scenario: Finding strings containing whitespace.When executing query:
   passed - Scenario: Finding strings containing whitespace.Then the result should be:
   passed - Scenario: Finding strings containing whitespace.And no side effects
  Scenario: Finding strings containing newline
   passed - Scenario: Finding strings containing newline.Given an empty graph
   passed - Scenario: Finding strings containing newline.And having executed:
   passed - Scenario: Finding strings containing newline.And having executed:
   passed - Scenario: Finding strings containing newline.When executing query:
   passed - Scenario: Finding strings containing newline.Then the result should be:
   passed - Scenario: Finding strings containing newline.And no side effects
  Scenario: No string starts with null
   passed - Scenario: No string starts with null.Given an empty graph
   passed - Scenario: No string starts with null.And having executed:
   passed - Scenario: No string starts with null.When executing query:
   passed - Scenario: No string starts with null.Then the result should be:
   passed - Scenario: No string starts with null.And no side effects
  Scenario: No string does not start with null
   passed - Scenario: No string does not start with null.Given an empty graph
   passed - Scenario: No string does not start with null.And having executed:
   passed - Scenario: No string does not start with null.When executing query:
   passed - Scenario: No string does not start with null.Then the result should be:
   passed - Scenario: No string does not start with null.And no side effects
  Scenario: No string ends with null
   passed - Scenario: No string ends with null.Given an empty graph
   passed - Scenario: No string ends with null.And having executed:
   passed - Scenario: No string ends with null.When executing query:
   passed - Scenario: No string ends with null.Then the result should be:
   passed - Scenario: No string ends with null.And no side effects
  Scenario: No string does not end with null
   passed - Scenario: No string does not end with null.Given an empty graph
   passed - Scenario: No string does not end with null.And having executed:
   passed - Scenario: No string does not end with null.When executing query:
   passed - Scenario: No string does not end with null.Then the result should be:
   passed - Scenario: No string does not end with null.And no side effects
  Scenario: No string contains null
   passed - Scenario: No string contains null.Given an empty graph
   passed - Scenario: No string contains null.And having executed:
   passed - Scenario: No string contains null.When executing query:
   passed - Scenario: No string contains null.Then the result should be:
   passed - Scenario: No string contains null.And no side effects
  Scenario: No string does not contain null
   passed - Scenario: No string does not contain null.Given an empty graph
   passed - Scenario: No string does not contain null.And having executed:
   passed - Scenario: No string does not contain null.When executing query:
   passed - Scenario: No string does not contain null.Then the result should be:
   passed - Scenario: No string does not contain null.And no side effects
  Scenario: Combining string operators
   passed - Scenario: Combining string operators.Given an empty graph
   passed - Scenario: Combining string operators.And having executed:
   passed - Scenario: Combining string operators.When executing query:
   passed - Scenario: Combining string operators.Then the result should be:
   passed - Scenario: Combining string operators.And no side effects
  Scenario: NOT with CONTAINS
   passed - Scenario: NOT with CONTAINS.Given an empty graph
   passed - Scenario: NOT with CONTAINS.And having executed:
   passed - Scenario: NOT with CONTAINS.When executing query:
   passed - Scenario: NOT with CONTAINS.Then the result should be:
   passed - Scenario: NOT with CONTAINS.And no side effects
  Scenario: Handling non-string operands for STARTS WITH
   passed - Scenario: Handling non-string operands for STARTS WITH.Given an empty graph
   passed - Scenario: Handling non-string operands for STARTS WITH.And having executed:
   passed - Scenario: Handling non-string operands for STARTS WITH.When executing query:
   passed - Scenario: Handling non-string operands for STARTS WITH.Then the result should be:
   passed - Scenario: Handling non-string operands for STARTS WITH.And no side effects
  Scenario: Handling non-string operands for CONTAINS
   passed - Scenario: Handling non-string operands for CONTAINS.Given an empty graph
   passed - Scenario: Handling non-string operands for CONTAINS.And having executed:
   passed - Scenario: Handling non-string operands for CONTAINS.When executing query:
   passed - Scenario: Handling non-string operands for CONTAINS.Then the result should be:
   passed - Scenario: Handling non-string operands for CONTAINS.And no side effects
  Scenario: Handling non-string operands for ENDS WITH
   passed - Scenario: Handling non-string operands for ENDS WITH.Given an empty graph
   passed - Scenario: Handling non-string operands for ENDS WITH.And having executed:
   passed - Scenario: Handling non-string operands for ENDS WITH.When executing query:
   passed - Scenario: Handling non-string operands for ENDS WITH.Then the result should be:
   passed - Scenario: Handling non-string operands for ENDS WITH.And no side effects
SyntaxErrorAcceptanceTest
 Feature: SyntaxErrorAcceptance
  Scenario: Using a non-existent function
   passed - Scenario: Using a non-existent function.Given any graph
   passed - Scenario: Using a non-existent function.When executing query:
   passed - Scenario: Using a non-existent function.Then a SyntaxError should be raised at compile time: UnknownFunction
  Scenario: Using `rand()` in aggregations
   passed - )` in aggregations.Given any graph(Scenario: Using `rand
   passed - )` in aggregations.When executing query:(Scenario: Using `rand
   ignored - )` in aggregations.Then a SyntaxError should be raised at compile time: NonConstantExpression(Scenario: Using `rand
  Scenario: Supplying invalid hexadecimal literal 1
   passed - Scenario: Supplying invalid hexadecimal literal 1.Given any graph
   passed - Scenario: Supplying invalid hexadecimal literal 1.When executing query:
   passed - Scenario: Supplying invalid hexadecimal literal 1.Then a SyntaxError should be raised at compile time: InvalidNumberLiteral
  Scenario: Supplying invalid hexadecimal literal 2
   passed - Scenario: Supplying invalid hexadecimal literal 2.Given any graph
   passed - Scenario: Supplying invalid hexadecimal literal 2.When executing query:
   passed - Scenario: Supplying invalid hexadecimal literal 2.Then a SyntaxError should be raised at compile time: InvalidNumberLiteral
TernaryLogicAcceptanceTest
 Feature: TernaryLogicAcceptanceTest
  Scenario: The inverse of a null is a null
   passed - Scenario: The inverse of a null is a null.Given any graph
   passed - Scenario: The inverse of a null is a null.When executing query:
   passed - Scenario: The inverse of a null is a null.Then the result should be:
   passed - Scenario: The inverse of a null is a null.And no side effects
  Scenario: A literal null IS null
   passed - Scenario: A literal null IS null.Given any graph
   passed - Scenario: A literal null IS null.When executing query:
   passed - Scenario: A literal null IS null.Then the result should be:
   passed - Scenario: A literal null IS null.And no side effects
  Scenario: A literal null is not IS NOT null
   passed - Scenario: A literal null is not IS NOT null.Given any graph
   passed - Scenario: A literal null is not IS NOT null.When executing query:
   passed - Scenario: A literal null is not IS NOT null.Then the result should be:
   passed - Scenario: A literal null is not IS NOT null.And no side effects
   null - if a null is equal to a null
   passed -  null - if a null is equal to a null.Given any graph
   passed -  null - if a null is equal to a null.When executing query:
   passed -  null - if a null is equal to a null.Then the result should be:
   passed -  null - if a null is equal to a null.And no side effects
   null - if a null is not equal to a null
   passed -  null - if a null is not equal to a null.Given any graph
   passed -  null - if a null is not equal to a null.When executing query:
   passed -  null - if a null is not equal to a null.Then the result should be:
   passed -  null - if a null is not equal to a null.And no side effects
  Scenario Outline: Using null in AND
   Examples: 
    | null | null | null |
   passed - | null | null | null |.Given any graph
   passed - | null | null | null |.And parameters are:
   passed - | null | null | null |.When executing query:
   passed - | null | null | null |.Then the result should be:
   passed - | null | null | null |.And no side effects
    | null | true | null |
   passed - | null | true | null |.Given any graph
   passed - | null | true | null |.And parameters are:
   passed - | null | true | null |.When executing query:
   passed - | null | true | null |.Then the result should be:
   passed - | null | true | null |.And no side effects
    | true | null | null |
   passed - | true | null | null |.Given any graph
   passed - | true | null | null |.And parameters are:
   passed - | true | null | null |.When executing query:
   passed - | true | null | null |.Then the result should be:
   passed - | true | null | null |.And no side effects
    | null | false | false |
   passed - | null | false | false |.Given any graph
   passed - | null | false | false |.And parameters are:
   passed - | null | false | false |.When executing query:
   passed - | null | false | false |.Then the result should be:
   passed - | null | false | false |.And no side effects
    | false | null | false |
   passed - | false | null | false |.Given any graph
   passed - | false | null | false |.And parameters are:
   passed - | false | null | false |.When executing query:
   passed - | false | null | false |.Then the result should be:
   passed - | false | null | false |.And no side effects
  Scenario Outline: Using null in OR
   Examples: 
    | null | null | null |
   passed - | null | null | null |.Given any graph
   passed - | null | null | null |.And parameters are:
   passed - | null | null | null |.When executing query:
   passed - | null | null | null |.Then the result should be:
   passed - | null | null | null |.And no side effects
    | null | true | true |
   passed - | null | true | true |.Given any graph
   passed - | null | true | true |.And parameters are:
   passed - | null | true | true |.When executing query:
   passed - | null | true | true |.Then the result should be:
   passed - | null | true | true |.And no side effects
    | true | null | true |
   passed - | true | null | true |.Given any graph
   passed - | true | null | true |.And parameters are:
   passed - | true | null | true |.When executing query:
   passed - | true | null | true |.Then the result should be:
   passed - | true | null | true |.And no side effects
    | null | false | null |
   passed - | null | false | null |.Given any graph
   passed - | null | false | null |.And parameters are:
   passed - | null | false | null |.When executing query:
   passed - | null | false | null |.Then the result should be:
   passed - | null | false | null |.And no side effects
    | false | null | null |
   passed - | false | null | null |.Given any graph
   passed - | false | null | null |.And parameters are:
   passed - | false | null | null |.When executing query:
   passed - | false | null | null |.Then the result should be:
   passed - | false | null | null |.And no side effects
  Scenario Outline: Using null in XOR
   Examples: 
    | null | null | null |
   passed - | null | null | null |.Given any graph
   passed - | null | null | null |.And parameters are:
   passed - | null | null | null |.When executing query:
   passed - | null | null | null |.Then the result should be:
   passed - | null | null | null |.And no side effects
    | null | true | null |
   passed - | null | true | null |.Given any graph
   passed - | null | true | null |.And parameters are:
   passed - | null | true | null |.When executing query:
   passed - | null | true | null |.Then the result should be:
   passed - | null | true | null |.And no side effects
    | true | null | null |
   passed - | true | null | null |.Given any graph
   passed - | true | null | null |.And parameters are:
   passed - | true | null | null |.When executing query:
   passed - | true | null | null |.Then the result should be:
   passed - | true | null | null |.And no side effects
    | null | false | null |
   passed - | null | false | null |.Given any graph
   passed - | null | false | null |.And parameters are:
   passed - | null | false | null |.When executing query:
   passed - | null | false | null |.Then the result should be:
   passed - | null | false | null |.And no side effects
    | false | null | null |
   passed - | false | null | null |.Given any graph
   passed - | false | null | null |.And parameters are:
   passed - | false | null | null |.When executing query:
   passed - | false | null | null |.Then the result should be:
   passed - | false | null | null |.And no side effects
  Scenario Outline: Using null in IN
   Examples: 
    | null | null | null |
   passed - | null | null | null |.Given any graph
   passed - | null | null | null |.And parameters are:
   passed - | null | null | null |.When executing query:
   passed - | null | null | null |.Then the result should be:
   passed - | null | null | null |.And no side effects
    | null | [1, 2, 3] | null |
   passed - | null | [1, 2, 3] | null |.Given any graph
   passed - | null | [1, 2, 3] | null |.And parameters are:
   passed - | null | [1, 2, 3] | null |.When executing query:
   passed - | null | [1, 2, 3] | null |.Then the result should be:
   passed - | null | [1, 2, 3] | null |.And no side effects
    | null | [1, 2, 3, null] | null |
   passed - | null | [1, 2, 3, null] | null |.Given any graph
   passed - | null | [1, 2, 3, null] | null |.And parameters are:
   passed - | null | [1, 2, 3, null] | null |.When executing query:
   passed - | null | [1, 2, 3, null] | null |.Then the result should be:
   passed - | null | [1, 2, 3, null] | null |.And no side effects
    | null | [] | false |
   passed - | null | [] | false |.Given any graph
   passed - | null | [] | false |.And parameters are:
   passed - | null | [] | false |.When executing query:
   passed - | null | [] | false |.Then the result should be:
   passed - | null | [] | false |.And no side effects
    | 1 | [1, 2, 3, null] | true |
   passed - | 1 | [1, 2, 3, null] | true |.Given any graph
   passed - | 1 | [1, 2, 3, null] | true |.And parameters are:
   passed - | 1 | [1, 2, 3, null] | true |.When executing query:
   passed - | 1 | [1, 2, 3, null] | true |.Then the result should be:
   passed - | 1 | [1, 2, 3, null] | true |.And no side effects
    | 1 | [null, 1] | true |
   passed - | 1 | [null, 1] | true |.Given any graph
   passed - | 1 | [null, 1] | true |.And parameters are:
   passed - | 1 | [null, 1] | true |.When executing query:
   passed - | 1 | [null, 1] | true |.Then the result should be:
   passed - | 1 | [null, 1] | true |.And no side effects
    | 5 | [1, 2, 3, null] | null |
   passed - | 5 | [1, 2, 3, null] | null |.Given any graph
   passed - | 5 | [1, 2, 3, null] | null |.And parameters are:
   passed - | 5 | [1, 2, 3, null] | null |.When executing query:
   passed - | 5 | [1, 2, 3, null] | null |.Then the result should be:
   passed - | 5 | [1, 2, 3, null] | null |.And no side effects
TriadicSelectionTest
 Feature: TriadicSelection
  Scenario: Handling triadic friend of a friend
   passed - Scenario: Handling triadic friend of a friend.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend.When executing query:
   passed - Scenario: Handling triadic friend of a friend.Then the result should be:
   passed - Scenario: Handling triadic friend of a friend.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend
   passed - Scenario: Handling triadic friend of a friend that is not a friend.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with different relationship type
   passed - Scenario: Handling triadic friend of a friend that is not a friend with different relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with different relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with different relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with different relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with superset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is not a friend with superset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with superset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with superset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with superset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with explicit subset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is not a friend with explicit subset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with explicit subset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with explicit subset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with explicit subset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with same labels
   passed - Scenario: Handling triadic friend of a friend that is not a friend with same labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with same labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with same labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with same labels.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with different labels
   passed - Scenario: Handling triadic friend of a friend that is not a friend with different labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with different labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with different labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with different labels.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of labels
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with implicit subset of labels.And no side effects
  Scenario: Handling triadic friend of a friend that is not a friend with implicit superset of labels
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit superset of labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is not a friend with implicit superset of labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is not a friend with implicit superset of labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is not a friend with implicit superset of labels.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend
   passed - Scenario: Handling triadic friend of a friend that is a friend.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with different relationship type
   passed - Scenario: Handling triadic friend of a friend that is a friend with different relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with different relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with different relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with different relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with superset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is a friend with superset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with superset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with superset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with superset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with implicit subset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with explicit subset of relationship type
   passed - Scenario: Handling triadic friend of a friend that is a friend with explicit subset of relationship type.Given the binary-tree-1 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with explicit subset of relationship type.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with explicit subset of relationship type.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with explicit subset of relationship type.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with same labels
   passed - Scenario: Handling triadic friend of a friend that is a friend with same labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with same labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with same labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with same labels.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with different labels
   passed - Scenario: Handling triadic friend of a friend that is a friend with different labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with different labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with different labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with different labels.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with implicit subset of labels
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with implicit subset of labels.And no side effects
  Scenario: Handling triadic friend of a friend that is a friend with implicit superset of labels
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit superset of labels.Given the binary-tree-2 graph
   passed - Scenario: Handling triadic friend of a friend that is a friend with implicit superset of labels.When executing query:
   failed - Scenario: Handling triadic friend of a friend that is a friend with implicit superset of labels.Then the result should be:
   ignored - Scenario: Handling triadic friend of a friend that is a friend with implicit superset of labels.And no side effects
TypeConversionFunctionsTest
 Feature: TypeConversionFunctions
  Scenario: `toBoolean()` on valid literal string
   passed - )` on valid literal string.Given any graph(Scenario: `toBoolean
   passed - )` on valid literal string.When executing query:(Scenario: `toBoolean
   passed - )` on valid literal string.Then the result should be:(Scenario: `toBoolean
   passed - )` on valid literal string.And no side effects(Scenario: `toBoolean
  Scenario: `toBoolean()` on booleans
   passed - )` on booleans.Given any graph(Scenario: `toBoolean
   passed - )` on booleans.When executing query:(Scenario: `toBoolean
   passed - )` on booleans.Then the result should be:(Scenario: `toBoolean
   passed - )` on booleans.And no side effects(Scenario: `toBoolean
  Scenario: `toBoolean()` on variables with valid string values
   passed - )` on variables with valid string values.Given any graph(Scenario: `toBoolean
   passed - )` on variables with valid string values.When executing query:(Scenario: `toBoolean
   passed - )` on variables with valid string values.Then the result should be:(Scenario: `toBoolean
   passed - )` on variables with valid string values.And no side effects(Scenario: `toBoolean
  Scenario: `toBoolean()` on invalid strings
   passed - )` on invalid strings.Given any graph(Scenario: `toBoolean
   passed - )` on invalid strings.When executing query:(Scenario: `toBoolean
   passed - )` on invalid strings.Then the result should be:(Scenario: `toBoolean
   passed - )` on invalid strings.And no side effects(Scenario: `toBoolean
  Scenario Outline: `toBoolean()` on invalid types
   Examples: 
    | [] |
   passed - | [] |.Given any graph
   passed - | [] |.When executing query:
   passed - | [] |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | {} |
   passed - | {} |.Given any graph
   passed - | {} |.When executing query:
   passed - | {} |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | 1 |
   passed - | 1 |.Given any graph
   passed - | 1 |.When executing query:
   passed - | 1 |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    0 |
   passed - 0 |.Given any graph
   passed - 0 |.When executing query:
   passed - 0 |.Then a TypeError should be raised at runtime: InvalidArgumentValue
  Scenario: `toInteger()`
   passed - )`.Given an empty graph(Scenario: `toInteger
   passed - )`.And having executed:(Scenario: `toInteger
   passed - )`.When executing query:(Scenario: `toInteger
   passed - )`.Then the result should be:(Scenario: `toInteger
   passed - )`.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` on float
   passed - )` on float.Given any graph(Scenario: `toInteger
   passed - )` on float.When executing query:(Scenario: `toInteger
   passed - )` on float.Then the result should be:(Scenario: `toInteger
   passed - )` on float.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` returning null on non-numerical string
   passed - )` returning null on non-numerical string.Given any graph(Scenario: `toInteger
   passed - )` returning null on non-numerical string.When executing query:(Scenario: `toInteger
   passed - )` returning null on non-numerical string.Then the result should be:(Scenario: `toInteger
   passed - )` returning null on non-numerical string.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` handling mixed number types
   passed - )` handling mixed number types.Given any graph(Scenario: `toInteger
   passed - )` handling mixed number types.When executing query:(Scenario: `toInteger
   passed - )` handling mixed number types.Then the result should be:(Scenario: `toInteger
   passed - )` handling mixed number types.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` handling Any type
   passed - )` handling Any type.Given any graph(Scenario: `toInteger
   passed - )` handling Any type.When executing query:(Scenario: `toInteger
   passed - )` handling Any type.Then the result should be:(Scenario: `toInteger
   passed - )` handling Any type.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` on a list of strings
   passed - )` on a list of strings.Given any graph(Scenario: `toInteger
   passed - )` on a list of strings.When executing query:(Scenario: `toInteger
   passed - )` on a list of strings.Then the result should be:(Scenario: `toInteger
   passed - )` on a list of strings.And no side effects(Scenario: `toInteger
  Scenario: `toInteger()` on a complex-typed expression
   passed - )` on a complex-typed expression.Given any graph(Scenario: `toInteger
   passed - )` on a complex-typed expression.And parameters are:(Scenario: `toInteger
   passed - )` on a complex-typed expression.When executing query:(Scenario: `toInteger
   passed - )` on a complex-typed expression.Then the result should be:(Scenario: `toInteger
   passed - )` on a complex-typed expression.And no side effects(Scenario: `toInteger
  Scenario Outline: `toInteger()` failing on invalid arguments
   Examples: 
    | true |
   passed - | true |.Given an empty graph
   passed - | true |.And having executed:
   passed - | true |.When executing query:
   passed - | true |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | [] |
   passed - | [] |.Given an empty graph
   passed - | [] |.And having executed:
   passed - | [] |.When executing query:
   passed - | [] |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | {} |
   passed - | {} |.Given an empty graph
   passed - | {} |.And having executed:
   passed - | {} |.When executing query:
   passed - | {} |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | n |
   passed - | n |.Given an empty graph
   passed - | n |.And having executed:
   passed - | n |.When executing query:
   passed - | n |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | r |
   passed - | r |.Given an empty graph
   passed - | r |.And having executed:
   passed - | r |.When executing query:
   passed - | r |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | p |
   passed - | p |.Given an empty graph
   passed - | p |.And having executed:
   passed - | p |.When executing query:
   passed - | p |.Then a TypeError should be raised at runtime: InvalidArgumentValue
  Scenario: `toFloat()`
   passed - )`.Given an empty graph(Scenario: `toFloat
   passed - )`.And having executed:(Scenario: `toFloat
   passed - )`.When executing query:(Scenario: `toFloat
   passed - )`.Then the result should be:(Scenario: `toFloat
   passed - )`.And no side effects(Scenario: `toFloat
  Scenario: `toFloat()` on mixed number types
   passed - )` on mixed number types.Given any graph(Scenario: `toFloat
   passed - )` on mixed number types.When executing query:(Scenario: `toFloat
   passed - )` on mixed number types.Then the result should be:(Scenario: `toFloat
   passed - )` on mixed number types.And no side effects(Scenario: `toFloat
  Scenario: `toFloat()` returning null on non-numerical string
   passed - )` returning null on non-numerical string.Given any graph(Scenario: `toFloat
   passed - )` returning null on non-numerical string.When executing query:(Scenario: `toFloat
   passed - )` returning null on non-numerical string.Then the result should be:(Scenario: `toFloat
   passed - )` returning null on non-numerical string.And no side effects(Scenario: `toFloat
  Scenario: `toFloat()` handling Any type
   passed - )` handling Any type.Given any graph(Scenario: `toFloat
   passed - )` handling Any type.When executing query:(Scenario: `toFloat
   passed - )` handling Any type.Then the result should be:(Scenario: `toFloat
   passed - )` handling Any type.And no side effects(Scenario: `toFloat
  Scenario: `toFloat()` on a list of strings
   passed - )` on a list of strings.Given any graph(Scenario: `toFloat
   passed - )` on a list of strings.When executing query:(Scenario: `toFloat
   passed - )` on a list of strings.Then the result should be:(Scenario: `toFloat
   passed - )` on a list of strings.And no side effects(Scenario: `toFloat
  Scenario Outline: `toFloat()` failing on invalid arguments
   Examples: 
    | true |
   passed - | true |.Given an empty graph
   passed - | true |.And having executed:
   passed - | true |.When executing query:
   passed - | true |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | [] |
   passed - | [] |.Given an empty graph
   passed - | [] |.And having executed:
   passed - | [] |.When executing query:
   passed - | [] |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | {} |
   passed - | {} |.Given an empty graph
   passed - | {} |.And having executed:
   passed - | {} |.When executing query:
   passed - | {} |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | n |
   passed - | n |.Given an empty graph
   passed - | n |.And having executed:
   passed - | n |.When executing query:
   passed - | n |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | r |
   passed - | r |.Given an empty graph
   passed - | r |.And having executed:
   passed - | r |.When executing query:
   passed - | r |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | p |
   passed - | p |.Given an empty graph
   passed - | p |.And having executed:
   passed - | p |.When executing query:
   passed - | p |.Then a TypeError should be raised at runtime: InvalidArgumentValue
  Scenario: `toString()`
   passed - )`.Given an empty graph(Scenario: `toString
   passed - )`.And having executed:(Scenario: `toString
   passed - )`.When executing query:(Scenario: `toString
   passed - )`.Then the result should be:(Scenario: `toString
   passed - )`.And no side effects(Scenario: `toString
  Scenario: `toString()` handling boolean properties
   passed - )` handling boolean properties.Given an empty graph(Scenario: `toString
   passed - )` handling boolean properties.And having executed:(Scenario: `toString
   passed - )` handling boolean properties.When executing query:(Scenario: `toString
   passed - )` handling boolean properties.Then the result should be:(Scenario: `toString
   passed - )` handling boolean properties.And no side effects(Scenario: `toString
  Scenario: `toString()` handling inlined boolean
   passed - )` handling inlined boolean.Given any graph(Scenario: `toString
   passed - )` handling inlined boolean.When executing query:(Scenario: `toString
   passed - )` handling inlined boolean.Then the result should be:(Scenario: `toString
   passed - )` handling inlined boolean.And no side effects(Scenario: `toString
  Scenario: `toString()` handling boolean literal
   passed - )` handling boolean literal.Given any graph(Scenario: `toString
   passed - )` handling boolean literal.When executing query:(Scenario: `toString
   passed - )` handling boolean literal.Then the result should be:(Scenario: `toString
   passed - )` handling boolean literal.And no side effects(Scenario: `toString
  Scenario: `toString()` should work on Any type
   passed - )` should work on Any type.Given any graph(Scenario: `toString
   passed - )` should work on Any type.When executing query:(Scenario: `toString
   passed - )` should work on Any type.Then the result should be:(Scenario: `toString
   passed - )` should work on Any type.And no side effects(Scenario: `toString
  Scenario: `toString()` on a list of integers
   passed - )` on a list of integers.Given any graph(Scenario: `toString
   passed - )` on a list of integers.When executing query:(Scenario: `toString
   passed - )` on a list of integers.Then the result should be:(Scenario: `toString
   passed - )` on a list of integers.And no side effects(Scenario: `toString
  Scenario Outline: `toString()` failing on invalid arguments
   Examples: 
    | [] |
   passed - | [] |.Given an empty graph
   passed - | [] |.And having executed:
   passed - | [] |.When executing query:
   passed - | [] |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | {} |
   passed - | {} |.Given an empty graph
   passed - | {} |.And having executed:
   passed - | {} |.When executing query:
   passed - | {} |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | n |
   passed - | n |.Given an empty graph
   passed - | n |.And having executed:
   passed - | n |.When executing query:
   passed - | n |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | r |
   passed - | r |.Given an empty graph
   passed - | r |.And having executed:
   passed - | r |.When executing query:
   passed - | r |.Then a TypeError should be raised at runtime: InvalidArgumentValue
    | p |
   passed - | p |.Given an empty graph
   passed - | p |.And having executed:
   passed - | p |.When executing query:
   passed - | p |.Then a TypeError should be raised at runtime: InvalidArgumentValue
  Scenario: `toString()` should accept potentially correct types 1
   passed - )` should accept potentially correct types 1.Given any graph(Scenario: `toString
   passed - )` should accept potentially correct types 1.When executing query:(Scenario: `toString
   passed - )` should accept potentially correct types 1.Then the result should be:(Scenario: `toString
   passed - )` should accept potentially correct types 1.And no side effects(Scenario: `toString
  Scenario: `toString()` should accept potentially correct types 2
   passed - )` should accept potentially correct types 2.Given any graph(Scenario: `toString
   passed - )` should accept potentially correct types 2.When executing query:(Scenario: `toString
   passed - )` should accept potentially correct types 2.Then the result should be:(Scenario: `toString
   passed - )` should accept potentially correct types 2.And no side effects(Scenario: `toString
UnionAcceptanceTest
 Feature: UnionAcceptance
  Scenario: Should be able to create text output from union queries
   passed - Scenario: Should be able to create text output from union queries.Given an empty graph
   passed - Scenario: Should be able to create text output from union queries.And having executed:
   passed - Scenario: Should be able to create text output from union queries.When executing query:
   passed - Scenario: Should be able to create text output from union queries.Then the result should be:
   passed - Scenario: Should be able to create text output from union queries.And no side effects
  Scenario: Two elements, both unique, not distinct
   passed - Scenario: Two elements, both unique, not distinct.Given an empty graph
   passed - Scenario: Two elements, both unique, not distinct.When executing query:
   passed - Scenario: Two elements, both unique, not distinct.Then the result should be:
   passed - Scenario: Two elements, both unique, not distinct.And no side effects
  Scenario: Two elements, both unique, distinct
   passed - Scenario: Two elements, both unique, distinct.Given an empty graph
   passed - Scenario: Two elements, both unique, distinct.When executing query:
   passed - Scenario: Two elements, both unique, distinct.Then the result should be:
   passed - Scenario: Two elements, both unique, distinct.And no side effects
  Scenario: Three elements, two unique, distinct
   passed - Scenario: Three elements, two unique, distinct.Given an empty graph
   passed - Scenario: Three elements, two unique, distinct.When executing query:
   passed - Scenario: Three elements, two unique, distinct.Then the result should be:
   passed - Scenario: Three elements, two unique, distinct.And no side effects
  Scenario: Three elements, two unique, not distinct
   passed - Scenario: Three elements, two unique, not distinct.Given an empty graph
   passed - Scenario: Three elements, two unique, not distinct.When executing query:
   passed - Scenario: Three elements, two unique, not distinct.Then the result should be:
   passed - Scenario: Three elements, two unique, not distinct.And no side effects
UnwindAcceptanceTest
 Feature: UnwindAcceptance
  Scenario: Unwinding a list
   passed - Scenario: Unwinding a list.Given any graph
   passed - Scenario: Unwinding a list.When executing query:
   passed - Scenario: Unwinding a list.Then the result should be:
   passed - Scenario: Unwinding a list.And no side effects
  Scenario: Unwinding a range
   passed - Scenario: Unwinding a range.Given any graph
   passed - Scenario: Unwinding a range.When executing query:
   passed - Scenario: Unwinding a range.Then the result should be:
   passed - Scenario: Unwinding a range.And no side effects
  Scenario: Unwinding a concatenation of lists
   passed - Scenario: Unwinding a concatenation of lists.Given any graph
   passed - Scenario: Unwinding a concatenation of lists.When executing query:
   passed - Scenario: Unwinding a concatenation of lists.Then the result should be:
   passed - Scenario: Unwinding a concatenation of lists.And no side effects
  Scenario: Unwinding a collected unwound expression
   passed - Scenario: Unwinding a collected unwound expression.Given any graph
   passed - Scenario: Unwinding a collected unwound expression.When executing query:
   passed - Scenario: Unwinding a collected unwound expression.Then the result should be:
   passed - Scenario: Unwinding a collected unwound expression.And no side effects
  Scenario: Unwinding a collected expression
   passed - Scenario: Unwinding a collected expression.Given an empty graph
   passed - Scenario: Unwinding a collected expression.And having executed:
   passed - Scenario: Unwinding a collected expression.When executing query:
   passed - Scenario: Unwinding a collected expression.Then the result should be:
   passed - Scenario: Unwinding a collected expression.And no side effects
  Scenario: Creating nodes from an unwound parameter list
   passed - Scenario: Creating nodes from an unwound parameter list.Given an empty graph
   passed - Scenario: Creating nodes from an unwound parameter list.And having executed:
   passed - Scenario: Creating nodes from an unwound parameter list.And parameters are:
   passed - Scenario: Creating nodes from an unwound parameter list.When executing query:
   passed - Scenario: Creating nodes from an unwound parameter list.Then the result should be, in order:
   failed - Scenario: Creating nodes from an unwound parameter list.And the side effects should be:
  Scenario: Double unwinding a list of lists
   passed - Scenario: Double unwinding a list of lists.Given any graph
   passed - Scenario: Double unwinding a list of lists.When executing query:
   passed - Scenario: Double unwinding a list of lists.Then the result should be:
   passed - Scenario: Double unwinding a list of lists.And no side effects
  Scenario: Unwinding the empty list
   passed - Scenario: Unwinding the empty list.Given any graph
   passed - Scenario: Unwinding the empty list.When executing query:
   passed - Scenario: Unwinding the empty list.Then the result should be:
   passed - Scenario: Unwinding the empty list.And no side effects
  Scenario: Unwinding null
   passed - Scenario: Unwinding null.Given any graph
   passed - Scenario: Unwinding null.When executing query:
   error - Scenario: Unwinding null.Then the result should be:
   ignored - Scenario: Unwinding null.And no side effects
  Scenario: Unwinding list with duplicates
   passed - Scenario: Unwinding list with duplicates.Given any graph
   passed - Scenario: Unwinding list with duplicates.When executing query:
   passed - Scenario: Unwinding list with duplicates.Then the result should be:
   passed - Scenario: Unwinding list with duplicates.And no side effects
  Scenario: Unwind does not prune context
   passed - Scenario: Unwind does not prune context.Given any graph
   passed - Scenario: Unwind does not prune context.When executing query:
   failed - Scenario: Unwind does not prune context.Then the result should be:
   ignored - Scenario: Unwind does not prune context.And no side effects
  Scenario: Unwind does not remove variables from scope
   passed - Scenario: Unwind does not remove variables from scope.Given an empty graph
   passed - Scenario: Unwind does not remove variables from scope.And having executed:
   passed - Scenario: Unwind does not remove variables from scope.When executing query:
   failed - Scenario: Unwind does not remove variables from scope.Then the result should be:
   ignored - Scenario: Unwind does not remove variables from scope.And no side effects
  Scenario: Multiple unwinds after each other
   passed - Scenario: Multiple unwinds after each other.Given any graph
   passed - Scenario: Multiple unwinds after each other.When executing query:
   failed - Scenario: Multiple unwinds after each other.Then the result should be:
   ignored - Scenario: Multiple unwinds after each other.And no side effects
  Scenario: Unwind with merge
   passed - Scenario: Unwind with merge.Given an empty graph
   passed - Scenario: Unwind with merge.And parameters are:
   passed - Scenario: Unwind with merge.When executing query:
   passed - Scenario: Unwind with merge.Then the result should be:
   passed - Scenario: Unwind with merge.And the side effects should be:
VarLengthAcceptanceTest
 Feature: VarLengthAcceptance
  Scenario: Handling unbounded variable length match
   passed - Scenario: Handling unbounded variable length match.Given an empty graph
   passed - Scenario: Handling unbounded variable length match.And having executed:
   passed - Scenario: Handling unbounded variable length match.When executing query:
   error - Scenario: Handling unbounded variable length match.Then the result should be:
   ignored - Scenario: Handling unbounded variable length match.And no side effects
  Scenario: Handling explicitly unbounded variable length match
   passed - Scenario: Handling explicitly unbounded variable length match.Given an empty graph
   passed - Scenario: Handling explicitly unbounded variable length match.And having executed:
   passed - Scenario: Handling explicitly unbounded variable length match.When executing query:
   error - Scenario: Handling explicitly unbounded variable length match.Then the result should be:
   ignored - Scenario: Handling explicitly unbounded variable length match.And no side effects
  Scenario: Fail when asterisk operator is missing
   passed - Scenario: Fail when asterisk operator is missing.Given an empty graph
   passed - Scenario: Fail when asterisk operator is missing.And having executed:
   passed - Scenario: Fail when asterisk operator is missing.When executing query:
   passed - Scenario: Fail when asterisk operator is missing.Then a SyntaxError should be raised at compile time: InvalidRelationshipPattern
  Scenario: Handling single bounded variable length match 1
   passed - Scenario: Handling single bounded variable length match 1.Given an empty graph
   passed - Scenario: Handling single bounded variable length match 1.And having executed:
   passed - Scenario: Handling single bounded variable length match 1.When executing query:
   error - Scenario: Handling single bounded variable length match 1.Then the result should be:
   ignored - Scenario: Handling single bounded variable length match 1.And no side effects
  Scenario: Handling single bounded variable length match 2
   passed - Scenario: Handling single bounded variable length match 2.Given an empty graph
   passed - Scenario: Handling single bounded variable length match 2.And having executed:
   passed - Scenario: Handling single bounded variable length match 2.When executing query:
   error - Scenario: Handling single bounded variable length match 2.Then the result should be:
   ignored - Scenario: Handling single bounded variable length match 2.And no side effects
  Scenario: Handling single bounded variable length match 3
   passed - Scenario: Handling single bounded variable length match 3.Given an empty graph
   passed - Scenario: Handling single bounded variable length match 3.And having executed:
   passed - Scenario: Handling single bounded variable length match 3.When executing query:
   error - Scenario: Handling single bounded variable length match 3.Then the result should be:
   ignored - Scenario: Handling single bounded variable length match 3.And no side effects
  Scenario: Handling upper and lower bounded variable length match 1
   passed - Scenario: Handling upper and lower bounded variable length match 1.Given an empty graph
   passed - Scenario: Handling upper and lower bounded variable length match 1.And having executed:
   passed - Scenario: Handling upper and lower bounded variable length match 1.When executing query:
   error - Scenario: Handling upper and lower bounded variable length match 1.Then the result should be:
   ignored - Scenario: Handling upper and lower bounded variable length match 1.And no side effects
  Scenario: Handling upper and lower bounded variable length match 2
   passed - Scenario: Handling upper and lower bounded variable length match 2.Given an empty graph
   passed - Scenario: Handling upper and lower bounded variable length match 2.And having executed:
   passed - Scenario: Handling upper and lower bounded variable length match 2.When executing query:
   error - Scenario: Handling upper and lower bounded variable length match 2.Then the result should be:
   ignored - Scenario: Handling upper and lower bounded variable length match 2.And no side effects
  Scenario: Handling symmetrically bounded variable length match, bounds are zero
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are zero.Given an empty graph
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are zero.And having executed:
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are zero.When executing query:
   error - Scenario: Handling symmetrically bounded variable length match, bounds are zero.Then the result should be:
   ignored - Scenario: Handling symmetrically bounded variable length match, bounds are zero.And no side effects
  Scenario: Handling symmetrically bounded variable length match, bounds are one
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are one.Given an empty graph
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are one.And having executed:
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are one.When executing query:
   error - Scenario: Handling symmetrically bounded variable length match, bounds are one.Then the result should be:
   ignored - Scenario: Handling symmetrically bounded variable length match, bounds are one.And no side effects
  Scenario: Handling symmetrically bounded variable length match, bounds are two
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are two.Given an empty graph
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are two.And having executed:
   passed - Scenario: Handling symmetrically bounded variable length match, bounds are two.When executing query:
   error - Scenario: Handling symmetrically bounded variable length match, bounds are two.Then the result should be:
   ignored - Scenario: Handling symmetrically bounded variable length match, bounds are two.And no side effects
  Scenario: Fail on negative bound
   passed - Scenario: Fail on negative bound.Given an empty graph
   passed - Scenario: Fail on negative bound.And having executed:
   passed - Scenario: Fail on negative bound.When executing query:
   passed - Scenario: Fail on negative bound.Then a SyntaxError should be raised at compile time: InvalidRelationshipPattern
  Scenario: Handling upper and lower bounded variable length match, empty interval 1
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 1.Given an empty graph
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 1.And having executed:
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 1.When executing query:
   error - Scenario: Handling upper and lower bounded variable length match, empty interval 1.Then the result should be:
   ignored - Scenario: Handling upper and lower bounded variable length match, empty interval 1.And no side effects
  Scenario: Handling upper and lower bounded variable length match, empty interval 2
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 2.Given an empty graph
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 2.And having executed:
   passed - Scenario: Handling upper and lower bounded variable length match, empty interval 2.When executing query:
   error - Scenario: Handling upper and lower bounded variable length match, empty interval 2.Then the result should be:
   ignored - Scenario: Handling upper and lower bounded variable length match, empty interval 2.And no side effects
  Scenario: Handling upper bounded variable length match, empty interval
   passed - Scenario: Handling upper bounded variable length match, empty interval.Given an empty graph
   passed - Scenario: Handling upper bounded variable length match, empty interval.And having executed:
   passed - Scenario: Handling upper bounded variable length match, empty interval.When executing query:
   error - Scenario: Handling upper bounded variable length match, empty interval.Then the result should be:
   ignored - Scenario: Handling upper bounded variable length match, empty interval.And no side effects
  Scenario: Handling upper bounded variable length match 1
   passed - Scenario: Handling upper bounded variable length match 1.Given an empty graph
   passed - Scenario: Handling upper bounded variable length match 1.And having executed:
   passed - Scenario: Handling upper bounded variable length match 1.When executing query:
   error - Scenario: Handling upper bounded variable length match 1.Then the result should be:
   ignored - Scenario: Handling upper bounded variable length match 1.And no side effects
  Scenario: Handling upper bounded variable length match 2
   passed - Scenario: Handling upper bounded variable length match 2.Given an empty graph
   passed - Scenario: Handling upper bounded variable length match 2.And having executed:
   passed - Scenario: Handling upper bounded variable length match 2.When executing query:
   error - Scenario: Handling upper bounded variable length match 2.Then the result should be:
   ignored - Scenario: Handling upper bounded variable length match 2.And no side effects
  Scenario: Handling lower bounded variable length match 1
   passed - Scenario: Handling lower bounded variable length match 1.Given an empty graph
   passed - Scenario: Handling lower bounded variable length match 1.And having executed:
   passed - Scenario: Handling lower bounded variable length match 1.When executing query:
   error - Scenario: Handling lower bounded variable length match 1.Then the result should be:
   ignored - Scenario: Handling lower bounded variable length match 1.And no side effects
  Scenario: Handling lower bounded variable length match 2
   passed - Scenario: Handling lower bounded variable length match 2.Given an empty graph
   passed - Scenario: Handling lower bounded variable length match 2.And having executed:
   passed - Scenario: Handling lower bounded variable length match 2.When executing query:
   error - Scenario: Handling lower bounded variable length match 2.Then the result should be:
   ignored - Scenario: Handling lower bounded variable length match 2.And no side effects
  Scenario: Handling lower bounded variable length match 3
   passed - Scenario: Handling lower bounded variable length match 3.Given an empty graph
   passed - Scenario: Handling lower bounded variable length match 3.And having executed:
   passed - Scenario: Handling lower bounded variable length match 3.When executing query:
   error - Scenario: Handling lower bounded variable length match 3.Then the result should be:
   ignored - Scenario: Handling lower bounded variable length match 3.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 1.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, zero length 2.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 1.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, single length 2.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 1.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 2.And no side effects
  Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.Given an empty graph
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.And having executed:
   passed - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.When executing query:
   error - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.Then the result should be:
   ignored - Scenario: Handling a variable length relationship and a standard relationship in chain, longer 3.And no side effects
  Scenario: Handling mixed relationship patterns and directions 1
   passed - Scenario: Handling mixed relationship patterns and directions 1.Given an empty graph
   passed - Scenario: Handling mixed relationship patterns and directions 1.And having executed:
   passed - Scenario: Handling mixed relationship patterns and directions 1.And having executed:
   passed - Scenario: Handling mixed relationship patterns and directions 1.And having executed:
   passed - Scenario: Handling mixed relationship patterns and directions 1.When executing query:
   error - Scenario: Handling mixed relationship patterns and directions 1.Then the result should be:
   ignored - Scenario: Handling mixed relationship patterns and directions 1.And no side effects
  Scenario: Handling mixed relationship patterns and directions 2
   passed - Scenario: Handling mixed relationship patterns and directions 2.Given an empty graph
   passed - Scenario: Handling mixed relationship patterns and directions 2.And having executed:
   error - Scenario: Handling mixed relationship patterns and directions 2.And having executed:
   ignored - Scenario: Handling mixed relationship patterns and directions 2.And having executed:
   ignored - Scenario: Handling mixed relationship patterns and directions 2.When executing query:
   ignored - Scenario: Handling mixed relationship patterns and directions 2.Then the result should be:
   ignored - Scenario: Handling mixed relationship patterns and directions 2.And no side effects
  Scenario: Handling mixed relationship patterns 1
   passed - Scenario: Handling mixed relationship patterns 1.Given an empty graph
   passed - Scenario: Handling mixed relationship patterns 1.And having executed:
   passed - Scenario: Handling mixed relationship patterns 1.And having executed:
   passed - Scenario: Handling mixed relationship patterns 1.When executing query:
   error - Scenario: Handling mixed relationship patterns 1.Then the result should be:
   ignored - Scenario: Handling mixed relationship patterns 1.And no side effects
  Scenario: Handling mixed relationship patterns 2
   passed - Scenario: Handling mixed relationship patterns 2.Given an empty graph
   passed - Scenario: Handling mixed relationship patterns 2.And having executed:
   passed - Scenario: Handling mixed relationship patterns 2.And having executed:
   passed - Scenario: Handling mixed relationship patterns 2.When executing query:
   error - Scenario: Handling mixed relationship patterns 2.Then the result should be:
   ignored - Scenario: Handling mixed relationship patterns 2.And no side effects
WhereAcceptanceTest
 Feature: WhereAcceptance
  Scenario: NOT and false
   passed - Scenario: NOT and false.Given an empty graph
   passed - Scenario: NOT and false.And having executed:
   passed - Scenario: NOT and false.When executing query:
   passed - Scenario: NOT and false.Then the result should be:
   passed - Scenario: NOT and false.And no side effects
WithAcceptanceTest
 Feature: WithAcceptance
  Scenario: Passing on pattern nodes
   passed - Scenario: Passing on pattern nodes.Given an empty graph
   passed - Scenario: Passing on pattern nodes.And having executed:
   passed - Scenario: Passing on pattern nodes.When executing query:
   failed - Scenario: Passing on pattern nodes.Then the result should be:
   ignored - Scenario: Passing on pattern nodes.And no side effects
  Scenario: ORDER BY and LIMIT can be used
   passed - Scenario: ORDER BY and LIMIT can be used.Given an empty graph
   passed - Scenario: ORDER BY and LIMIT can be used.And having executed:
   passed - Scenario: ORDER BY and LIMIT can be used.When executing query:
   passed - Scenario: ORDER BY and LIMIT can be used.Then the result should be:
   passed - Scenario: ORDER BY and LIMIT can be used.And no side effects
  Scenario: No dependencies between the query parts
   passed - Scenario: No dependencies between the query parts.Given an empty graph
   passed - Scenario: No dependencies between the query parts.And having executed:
   passed - Scenario: No dependencies between the query parts.When executing query:
   passed - Scenario: No dependencies between the query parts.Then the result should be:
   passed - Scenario: No dependencies between the query parts.And no side effects
  Scenario: Aliasing
   passed - Scenario: Aliasing.Given an empty graph
   passed - Scenario: Aliasing.And having executed:
   passed - Scenario: Aliasing.When executing query:
   passed - Scenario: Aliasing.Then the result should be:
   passed - Scenario: Aliasing.And no side effects
  Scenario: Handle dependencies across WITH
   passed - Scenario: Handle dependencies across WITH.Given an empty graph
   passed - Scenario: Handle dependencies across WITH.And having executed:
   passed - Scenario: Handle dependencies across WITH.When executing query:
   passed - Scenario: Handle dependencies across WITH.Then the result should be:
   passed - Scenario: Handle dependencies across WITH.And no side effects
  Scenario: Handle dependencies across WITH with SKIP
   passed - Scenario: Handle dependencies across WITH with SKIP.Given an empty graph
   passed - Scenario: Handle dependencies across WITH with SKIP.And having executed:
   passed - Scenario: Handle dependencies across WITH with SKIP.When executing query:
   passed - Scenario: Handle dependencies across WITH with SKIP.Then the result should be:
   passed - Scenario: Handle dependencies across WITH with SKIP.And no side effects
  Scenario: WHERE after WITH should filter results
   passed - Scenario: WHERE after WITH should filter results.Given an empty graph
   passed - Scenario: WHERE after WITH should filter results.And having executed:
   passed - Scenario: WHERE after WITH should filter results.When executing query:
   passed - Scenario: WHERE after WITH should filter results.Then the result should be:
   passed - Scenario: WHERE after WITH should filter results.And no side effects
  Scenario: WHERE after WITH can filter on top of an aggregation
   passed - Scenario: WHERE after WITH can filter on top of an aggregation.Given an empty graph
   passed - Scenario: WHERE after WITH can filter on top of an aggregation.And having executed:
   passed - Scenario: WHERE after WITH can filter on top of an aggregation.When executing query:
   passed - Scenario: WHERE after WITH can filter on top of an aggregation.Then the result should be:
   passed - Scenario: WHERE after WITH can filter on top of an aggregation.And no side effects
  Scenario: ORDER BY a DISTINCT column
   passed - Scenario: ORDER BY a DISTINCT column.Given an empty graph
   passed - Scenario: ORDER BY a DISTINCT column.And having executed:
   passed - Scenario: ORDER BY a DISTINCT column.When executing query:
   failed - Scenario: ORDER BY a DISTINCT column.Then the result should be:
   ignored - Scenario: ORDER BY a DISTINCT column.And no side effects
  Scenario: WHERE on a DISTINCT column
   passed - Scenario: WHERE on a DISTINCT column.Given an empty graph
   passed - Scenario: WHERE on a DISTINCT column.And having executed:
   passed - Scenario: WHERE on a DISTINCT column.When executing query:
   failed - Scenario: WHERE on a DISTINCT column.Then the result should be:
   ignored - Scenario: WHERE on a DISTINCT column.And no side effects
  Scenario: A simple pattern with one bound endpoint
   passed - Scenario: A simple pattern with one bound endpoint.Given an empty graph
   passed - Scenario: A simple pattern with one bound endpoint.And having executed:
   passed - Scenario: A simple pattern with one bound endpoint.When executing query:
   failed - Scenario: A simple pattern with one bound endpoint.Then the result should be:
   ignored - Scenario: A simple pattern with one bound endpoint.And no side effects
  Scenario: Null handling
   passed - Scenario: Null handling.Given an empty graph
   passed - Scenario: Null handling.When executing query:
   error - Scenario: Null handling.Then the result should be:
   ignored - Scenario: Null handling.And no side effects
  Scenario: Nested maps
   passed - Scenario: Nested maps.Given an empty graph
   passed - Scenario: Nested maps.When executing query:
   passed - Scenario: Nested maps.Then the result should be:
   passed - Scenario: Nested maps.And no side effects
  Scenario: Connected components succeeding WITH
   passed - Scenario: Connected components succeeding WITH.Given an empty graph
   passed - Scenario: Connected components succeeding WITH.And having executed:
   passed - Scenario: Connected components succeeding WITH.When executing query:
   failed - Scenario: Connected components succeeding WITH.Then the result should be:
   ignored - Scenario: Connected components succeeding WITH.And no side effects
  Scenario: Single WITH using a predicate and aggregation
   passed - Scenario: Single WITH using a predicate and aggregation.Given an empty graph
   passed - Scenario: Single WITH using a predicate and aggregation.And having executed:
   passed - Scenario: Single WITH using a predicate and aggregation.When executing query:
   passed - Scenario: Single WITH using a predicate and aggregation.Then the result should be:
   passed - Scenario: Single WITH using a predicate and aggregation.And no side effects
  Scenario: Multiple WITHs using a predicate and aggregation
   passed - Scenario: Multiple WITHs using a predicate and aggregation.Given an empty graph
   passed - Scenario: Multiple WITHs using a predicate and aggregation.And having executed:
   passed - Scenario: Multiple WITHs using a predicate and aggregation.When executing query:
   passed - Scenario: Multiple WITHs using a predicate and aggregation.Then the result should be:
   passed - Scenario: Multiple WITHs using a predicate and aggregation.And no side effects
ObjectUtilsTest
   passed - ObjectUtilsTest.testCompare
Scenario: Aggregates in aggregates
   passed - Scenario: Aggregates in aggregates.Given any graph
   ignored - Scenario: Aggregates in aggregates/Given any graph
   passed - Scenario: Aggregates in aggregates.When executing query:
   ignored - Scenario: Aggregates in aggregates/When executing query:
   passed - Scenario: Aggregates in aggregates.Then a SyntaxError should be raised at compile time: NestedAggregation
   ignored - Scenario: Aggregates in aggregates/Then a SyntaxError should be raised at compile time: NestedAggregation
Scenario: Fail when adding a new label predicate on a node that is already bound 1
   passed - Scenario: Fail when adding a new label predicate on a node that is already bound 1.Given an empty graph
   ignored - Scenario: Fail when adding a new label predicate on a node that is already bound 1/Given an empty graph
   passed - Scenario: Fail when adding a new label predicate on a node that is already bound 1.When executing query:
   ignored - Scenario: Fail when adding a new label predicate on a node that is already bound 1/When executing query:
   passed - Scenario: Fail when adding a new label predicate on a node that is already bound 1.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when adding a new label predicate on a node that is already bound 1/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Fail when adding new label predicate on a node that is already bound 2
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 2.Given an empty graph
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 2/Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 2.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 2/When executing query:
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 2.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 2/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Fail when adding new label predicate on a node that is already bound 3
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 3.Given an empty graph
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 3/Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 3.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 3/When executing query:
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 3.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 3/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Fail when adding new label predicate on a node that is already bound 4
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 4.Given an empty graph
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 4/Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 4.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 4/When executing query:
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 4.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 4/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Fail when adding new label predicate on a node that is already bound 5
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 5.Given an empty graph
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 5/Given an empty graph
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 5.When executing query:
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 5/When executing query:
   passed - Scenario: Fail when adding new label predicate on a node that is already bound 5.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when adding new label predicate on a node that is already bound 5/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Fail when imposing new predicates on a variable that is already bound
   passed - Scenario: Fail when imposing new predicates on a variable that is already bound.Given any graph
   ignored - Scenario: Fail when imposing new predicates on a variable that is already bound/Given any graph
   passed - Scenario: Fail when imposing new predicates on a variable that is already bound.When executing query:
   ignored - Scenario: Fail when imposing new predicates on a variable that is already bound/When executing query:
   passed - Scenario: Fail when imposing new predicates on a variable that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Fail when imposing new predicates on a variable that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing on merging relationship with null property
   passed - Scenario: Failing on merging relationship with null property.Given any graph
   ignored - Scenario: Failing on merging relationship with null property/Given any graph
   passed - Scenario: Failing on merging relationship with null property.When executing query:
   ignored - Scenario: Failing on merging relationship with null property/When executing query:
   passed - Scenario: Failing on merging relationship with null property.Then a SemanticError should be raised at compile time: MergeReadOwnWrites
   ignored - Scenario: Failing on merging relationship with null property/Then a SemanticError should be raised at compile time: MergeReadOwnWrites
Scenario: Failing on aggregation in WHERE
   passed - Scenario: Failing on aggregation in WHERE.Given any graph
   ignored - Scenario: Failing on aggregation in WHERE/Given any graph
   passed - Scenario: Failing on aggregation in WHERE.When executing query:
   ignored - Scenario: Failing on aggregation in WHERE/When executing query:
   passed - Scenario: Failing on aggregation in WHERE.Then a SyntaxError should be raised at compile time: InvalidAggregation
   ignored - Scenario: Failing on aggregation in WHERE/Then a SyntaxError should be raised at compile time: InvalidAggregation
Scenario: Failing on aggregation in ORDER BY after RETURN
   passed - Scenario: Failing on aggregation in ORDER BY after RETURN.Given any graph
   ignored - Scenario: Failing on aggregation in ORDER BY after RETURN/Given any graph
   passed - Scenario: Failing on aggregation in ORDER BY after RETURN.When executing query:
   ignored - Scenario: Failing on aggregation in ORDER BY after RETURN/When executing query:
   passed - Scenario: Failing on aggregation in ORDER BY after RETURN.Then a SyntaxError should be raised at compile time: InvalidAggregation
   ignored - Scenario: Failing on aggregation in ORDER BY after RETURN/Then a SyntaxError should be raised at compile time: InvalidAggregation
Scenario: Failing on aggregation in ORDER BY after WITH
   passed - Scenario: Failing on aggregation in ORDER BY after WITH.Given any graph
   ignored - Scenario: Failing on aggregation in ORDER BY after WITH/Given any graph
   passed - Scenario: Failing on aggregation in ORDER BY after WITH.When executing query:
   ignored - Scenario: Failing on aggregation in ORDER BY after WITH/When executing query:
   passed - Scenario: Failing on aggregation in ORDER BY after WITH.Then a SyntaxError should be raised at compile time: InvalidAggregation
   ignored - Scenario: Failing on aggregation in ORDER BY after WITH/Then a SyntaxError should be raised at compile time: InvalidAggregation
Scenario: Failing when not aliasing expressions in WITH
   passed - Scenario: Failing when not aliasing expressions in WITH.Given any graph
   ignored - Scenario: Failing when not aliasing expressions in WITH/Given any graph
   passed - Scenario: Failing when not aliasing expressions in WITH.When executing query:
   ignored - Scenario: Failing when not aliasing expressions in WITH/When executing query:
   passed - Scenario: Failing when not aliasing expressions in WITH.Then a SyntaxError should be raised at compile time: NoExpressionAlias
   ignored - Scenario: Failing when not aliasing expressions in WITH/Then a SyntaxError should be raised at compile time: NoExpressionAlias
Scenario: Failing when using undefined variable in pattern
   passed - Scenario: Failing when using undefined variable in pattern.Given any graph
   ignored - Scenario: Failing when using undefined variable in pattern/Given any graph
   passed - Scenario: Failing when using undefined variable in pattern.When executing query:
   ignored - Scenario: Failing when using undefined variable in pattern/When executing query:
   passed - Scenario: Failing when using undefined variable in pattern.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when using undefined variable in pattern/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when using undefined variable in SET
   passed - Scenario: Failing when using undefined variable in SET.Given any graph
   ignored - Scenario: Failing when using undefined variable in SET/Given any graph
   passed - Scenario: Failing when using undefined variable in SET.When executing query:
   ignored - Scenario: Failing when using undefined variable in SET/When executing query:
   passed - Scenario: Failing when using undefined variable in SET.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when using undefined variable in SET/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when using undefined variable in DELETE
   passed - Scenario: Failing when using undefined variable in DELETE.Given any graph
   ignored - Scenario: Failing when using undefined variable in DELETE/Given any graph
   passed - Scenario: Failing when using undefined variable in DELETE.When executing query:
   ignored - Scenario: Failing when using undefined variable in DELETE/When executing query:
   passed - Scenario: Failing when using undefined variable in DELETE.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when using undefined variable in DELETE/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when using a variable that is already bound in CREATE
   passed - Scenario: Failing when using a variable that is already bound in CREATE.Given any graph
   ignored - Scenario: Failing when using a variable that is already bound in CREATE/Given any graph
   passed - Scenario: Failing when using a variable that is already bound in CREATE.When executing query:
   ignored - Scenario: Failing when using a variable that is already bound in CREATE/When executing query:
   passed - Scenario: Failing when using a variable that is already bound in CREATE.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using a variable that is already bound in CREATE/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using a path variable that is already bound
   passed - Scenario: Failing when using a path variable that is already bound.Given any graph
   ignored - Scenario: Failing when using a path variable that is already bound/Given any graph
   passed - Scenario: Failing when using a path variable that is already bound.When executing query:
   ignored - Scenario: Failing when using a path variable that is already bound/When executing query:
   passed - Scenario: Failing when using a path variable that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using a path variable that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using a list as a node
   passed - Scenario: Failing when using a list as a node.Given any graph
   ignored - Scenario: Failing when using a list as a node/Given any graph
   passed - Scenario: Failing when using a list as a node.When executing query:
   ignored - Scenario: Failing when using a list as a node/When executing query:
   passed - Scenario: Failing when using a list as a node.Then a SyntaxError should be raised at compile time: VariableTypeConflict
   ignored - Scenario: Failing when using a list as a node/Then a SyntaxError should be raised at compile time: VariableTypeConflict
Scenario: Failing when using a variable length relationship as a single relationship
   passed - Scenario: Failing when using a variable length relationship as a single relationship.Given any graph
   ignored - Scenario: Failing when using a variable length relationship as a single relationship/Given any graph
   passed - Scenario: Failing when using a variable length relationship as a single relationship.When executing query:
   ignored - Scenario: Failing when using a variable length relationship as a single relationship/When executing query:
   passed - Scenario: Failing when using a variable length relationship as a single relationship.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using a variable length relationship as a single relationship/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when UNION has different columns
   passed - Scenario: Failing when UNION has different columns.Given any graph
   ignored - Scenario: Failing when UNION has different columns/Given any graph
   passed - Scenario: Failing when UNION has different columns.When executing query:
   ignored - Scenario: Failing when UNION has different columns/When executing query:
   passed - Scenario: Failing when UNION has different columns.Then a SyntaxError should be raised at compile time: DifferentColumnsInUnion
   ignored - Scenario: Failing when UNION has different columns/Then a SyntaxError should be raised at compile time: DifferentColumnsInUnion
Scenario: Failing when mixing UNION and UNION ALL
   passed - Scenario: Failing when mixing UNION and UNION ALL.Given any graph
   ignored - Scenario: Failing when mixing UNION and UNION ALL/Given any graph
   passed - Scenario: Failing when mixing UNION and UNION ALL.When executing query:
   ignored - Scenario: Failing when mixing UNION and UNION ALL/When executing query:
   passed - Scenario: Failing when mixing UNION and UNION ALL.Then a SyntaxError should be raised at compile time: InvalidClauseComposition
   ignored - Scenario: Failing when mixing UNION and UNION ALL/Then a SyntaxError should be raised at compile time: InvalidClauseComposition
Scenario: Failing when deleting a label
   passed - Scenario: Failing when deleting a label.Given any graph
   ignored - Scenario: Failing when deleting a label/Given any graph
   passed - Scenario: Failing when deleting a label.When executing query:
   ignored - Scenario: Failing when deleting a label/When executing query:
   passed - Scenario: Failing when deleting a label.Then a SyntaxError should be raised at compile time: InvalidDelete
   ignored - Scenario: Failing when deleting a label/Then a SyntaxError should be raised at compile time: InvalidDelete
Scenario: Failing when setting a list of maps as a property
   passed - Scenario: Failing when setting a list of maps as a property.Given any graph
   ignored - Scenario: Failing when setting a list of maps as a property/Given any graph
   passed - Scenario: Failing when setting a list of maps as a property.When executing query:
   ignored - Scenario: Failing when setting a list of maps as a property/When executing query:
   passed - Scenario: Failing when setting a list of maps as a property.Then a TypeError should be raised at compile time: InvalidPropertyType
   ignored - Scenario: Failing when setting a list of maps as a property/Then a TypeError should be raised at compile time: InvalidPropertyType
Scenario: Failing when multiple columns have the same name
   passed - Scenario: Failing when multiple columns have the same name.Given any graph
   ignored - Scenario: Failing when multiple columns have the same name/Given any graph
   passed - Scenario: Failing when multiple columns have the same name.When executing query:
   ignored - Scenario: Failing when multiple columns have the same name/When executing query:
   passed - Scenario: Failing when multiple columns have the same name.Then a SyntaxError should be raised at compile time: ColumnNameConflict
   ignored - Scenario: Failing when multiple columns have the same name/Then a SyntaxError should be raised at compile time: ColumnNameConflict
Scenario: Failing when using RETURN * without variables in scope
   passed - Scenario: Failing when using RETURN * without variables in scope.Given any graph
   ignored - Scenario: Failing when using RETURN * without variables in scope/Given any graph
   passed - Scenario: Failing when using RETURN * without variables in scope.When executing query:
   ignored - Scenario: Failing when using RETURN * without variables in scope/When executing query:
   passed - Scenario: Failing when using RETURN * without variables in scope.Then a SyntaxError should be raised at compile time: NoVariablesInScope
   ignored - Scenario: Failing when using RETURN * without variables in scope/Then a SyntaxError should be raised at compile time: NoVariablesInScope
Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly
   passed - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly/Given an empty graph
   passed - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.When executing query:
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly/When executing query:
   passed - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly.Then a SyntaxError should be raised at compile time: InvalidArgumentPassingMode
   ignored - Scenario: In-query call to procedure that takes arguments fails when trying to pass them implicitly/Then a SyntaxError should be raised at compile time: InvalidArgumentPassingMode
Scenario: Standalone call to procedure that takes no arguments
   passed - Scenario: Standalone call to procedure that takes no arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments/Given an empty graph
   passed - Scenario: Standalone call to procedure that takes no arguments.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: Standalone call to procedure that takes no arguments/And there exists a procedure test.labels() :: (label :: STRING?):
   passed - Scenario: Standalone call to procedure that takes no arguments.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments/When executing query:
   passed - Scenario: Standalone call to procedure that takes no arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure that takes no arguments/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure that takes no arguments.And no side effects
   ignored - Scenario: Standalone call to procedure that takes no arguments/And no side effects
Scenario: In-query call to procedure that takes no arguments
   passed - Scenario: In-query call to procedure that takes no arguments.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes no arguments/Given an empty graph
   passed - Scenario: In-query call to procedure that takes no arguments.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: In-query call to procedure that takes no arguments/And there exists a procedure test.labels() :: (label :: STRING?):
   passed - Scenario: In-query call to procedure that takes no arguments.When executing query:
   ignored - Scenario: In-query call to procedure that takes no arguments/When executing query:
   passed - Scenario: In-query call to procedure that takes no arguments.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure that takes no arguments/Then the result should be, in order:
   passed - Scenario: In-query call to procedure that takes no arguments.And no side effects
   ignored - Scenario: In-query call to procedure that takes no arguments/And no side effects
Scenario: Calling the same procedure twice using the same outputs in each call
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.Given an empty graph
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call/Given an empty graph
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call/And there exists a procedure test.labels() :: (label :: STRING?):
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.When executing query:
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call/When executing query:
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.Then the result should be, in order:
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call/Then the result should be, in order:
   passed - Scenario: Calling the same procedure twice using the same outputs in each call.And no side effects
   ignored - Scenario: Calling the same procedure twice using the same outputs in each call/And no side effects
Scenario: Standalone call to VOID procedure that takes no arguments
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.Given an empty graph
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments/Given an empty graph
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments/And there exists a procedure test.doNothing() :: VOID:
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.When executing query:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments/When executing query:
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.Then the result should be empty
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments/Then the result should be empty
   passed - Scenario: Standalone call to VOID procedure that takes no arguments.And no side effects
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments/And no side effects
Scenario: In-query call to VOID procedure that takes no arguments
   passed - Scenario: In-query call to VOID procedure that takes no arguments.Given an empty graph
   ignored - Scenario: In-query call to VOID procedure that takes no arguments/Given an empty graph
   passed - Scenario: In-query call to VOID procedure that takes no arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments/And there exists a procedure test.doNothing() :: VOID:
   passed - Scenario: In-query call to VOID procedure that takes no arguments.When executing query:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments/When executing query:
   passed - Scenario: In-query call to VOID procedure that takes no arguments.Then the result should be:
   ignored - Scenario: In-query call to VOID procedure that takes no arguments/Then the result should be:
   passed - Scenario: In-query call to VOID procedure that takes no arguments.And no side effects
   ignored - Scenario: In-query call to VOID procedure that takes no arguments/And no side effects
Scenario: In-query call to VOID procedure does not consume rows
   passed - Scenario: In-query call to VOID procedure does not consume rows.Given an empty graph
   ignored - Scenario: In-query call to VOID procedure does not consume rows/Given an empty graph
   passed - Scenario: In-query call to VOID procedure does not consume rows.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: In-query call to VOID procedure does not consume rows/And there exists a procedure test.doNothing() :: VOID:
   passed - Scenario: In-query call to VOID procedure does not consume rows.And having executed:
   ignored - Scenario: In-query call to VOID procedure does not consume rows/And having executed:
   passed - Scenario: In-query call to VOID procedure does not consume rows.When executing query:
   ignored - Scenario: In-query call to VOID procedure does not consume rows/When executing query:
   passed - Scenario: In-query call to VOID procedure does not consume rows.Then the result should be:
   ignored - Scenario: In-query call to VOID procedure does not consume rows/Then the result should be:
   passed - Scenario: In-query call to VOID procedure does not consume rows.And no side effects
   ignored - Scenario: In-query call to VOID procedure does not consume rows/And no side effects
Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments/Given an empty graph
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.And there exists a procedure test.doNothing() :: VOID:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments/And there exists a procedure test.doNothing() :: VOID:
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments/When executing query:
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.Then the result should be empty
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments/Then the result should be empty
   passed - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments.And no side effects
   ignored - Scenario: Standalone call to VOID procedure that takes no arguments, called with implicit arguments/And no side effects
Scenario: In-query call to procedure that takes no arguments and yields no results
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.Given an empty graph
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results/Given an empty graph
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results/And there exists a procedure test.doNothing() :: ():
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.When executing query:
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results/When executing query:
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.Then the result should be:
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results/Then the result should be:
   passed - Scenario: In-query call to procedure that takes no arguments and yields no results.And no side effects
   ignored - Scenario: In-query call to procedure that takes no arguments and yields no results/And no side effects
Scenario: Standalone call to procedure that takes no arguments and yields no results
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results/Given an empty graph
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results/And there exists a procedure test.doNothing() :: ():
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results/When executing query:
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.Then the result should be empty
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results/Then the result should be empty
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results.And no side effects
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results/And no side effects
Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments/Given an empty graph
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.And there exists a procedure test.doNothing() :: ():
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments/And there exists a procedure test.doNothing() :: ():
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments/When executing query:
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.Then the result should be empty
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments/Then the result should be empty
   passed - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments.And no side effects
   ignored - Scenario: Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments/And no side effects
Scenario: In-query call to procedure with explicit arguments
   passed - Scenario: In-query call to procedure with explicit arguments.Given an empty graph
   ignored - Scenario: In-query call to procedure with explicit arguments/Given an empty graph
   passed - Scenario: In-query call to procedure with explicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: In-query call to procedure with explicit arguments/And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   passed - Scenario: In-query call to procedure with explicit arguments.When executing query:
   ignored - Scenario: In-query call to procedure with explicit arguments/When executing query:
   passed - Scenario: In-query call to procedure with explicit arguments.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with explicit arguments/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with explicit arguments.And no side effects
   ignored - Scenario: In-query call to procedure with explicit arguments/And no side effects
Scenario: In-query call to procedure with explicit arguments that drops all result fields
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.Given an empty graph
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields/Given an empty graph
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields/And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.When executing query:
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields/When executing query:
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with explicit arguments that drops all result fields.And no side effects
   ignored - Scenario: In-query call to procedure with explicit arguments that drops all result fields/And no side effects
Scenario: Standalone call to procedure with explicit arguments
   passed - Scenario: Standalone call to procedure with explicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure with explicit arguments/Given an empty graph
   passed - Scenario: Standalone call to procedure with explicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: Standalone call to procedure with explicit arguments/And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   passed - Scenario: Standalone call to procedure with explicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure with explicit arguments/When executing query:
   passed - Scenario: Standalone call to procedure with explicit arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with explicit arguments/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with explicit arguments.And no side effects
   ignored - Scenario: Standalone call to procedure with explicit arguments/And no side effects
Scenario: Standalone call to procedure with implicit arguments
   passed - Scenario: Standalone call to procedure with implicit arguments.Given an empty graph
   ignored - Scenario: Standalone call to procedure with implicit arguments/Given an empty graph
   passed - Scenario: Standalone call to procedure with implicit arguments.And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   ignored - Scenario: Standalone call to procedure with implicit arguments/And there exists a procedure test.my.proc(name :: STRING?, id :: INTEGER?) :: (city :: STRING?, country_code :: INTEGER?):
   passed - Scenario: Standalone call to procedure with implicit arguments.And parameters are:
   ignored - Scenario: Standalone call to procedure with implicit arguments/And parameters are:
   passed - Scenario: Standalone call to procedure with implicit arguments.When executing query:
   ignored - Scenario: Standalone call to procedure with implicit arguments/When executing query:
   passed - Scenario: Standalone call to procedure with implicit arguments.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with implicit arguments/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with implicit arguments.And no side effects
   ignored - Scenario: Standalone call to procedure with implicit arguments/And no side effects
Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER/Given an empty graph
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER/And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER/When executing query:
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER.And no side effects
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER/And no side effects
Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER/Given an empty graph
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER/And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER/When executing query:
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER.And no side effects
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type INTEGER/And no side effects
Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT/Given an empty graph
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT/And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT/When executing query:
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT.And no side effects
   ignored - Scenario: Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT/And no side effects
Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT/Given an empty graph
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT/And there exists a procedure test.my.proc(in :: NUMBER?) :: (out :: STRING?):
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT/When executing query:
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT.And no side effects
   ignored - Scenario: In-query call to procedure with argument of type NUMBER accepts value of type FLOAT/And no side effects
Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER/Given an empty graph
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER/And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER/When executing query:
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER.And no side effects
   ignored - Scenario: Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER/And no side effects
Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER/Given an empty graph
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER/And there exists a procedure test.my.proc(in :: FLOAT?) :: (out :: STRING?):
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER/When executing query:
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER.And no side effects
   ignored - Scenario: In-query call to procedure with argument of type FLOAT accepts value of type INTEGER/And no side effects
Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT/Given an empty graph
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.When executing query:
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT/When executing query:
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT.And no side effects
   ignored - Scenario: Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT/And no side effects
Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.Given an empty graph
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT/Given an empty graph
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.When executing query:
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT/When executing query:
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT.And no side effects
   ignored - Scenario: In-query call to procedure with argument of type INTEGER accepts value of type FLOAT/And no side effects
Scenario: Standalone call to procedure with null argument
   passed - Scenario: Standalone call to procedure with null argument.Given an empty graph
   ignored - Scenario: Standalone call to procedure with null argument/Given an empty graph
   passed - Scenario: Standalone call to procedure with null argument.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: Standalone call to procedure with null argument/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   passed - Scenario: Standalone call to procedure with null argument.When executing query:
   ignored - Scenario: Standalone call to procedure with null argument/When executing query:
   passed - Scenario: Standalone call to procedure with null argument.Then the result should be, in order:
   ignored - Scenario: Standalone call to procedure with null argument/Then the result should be, in order:
   passed - Scenario: Standalone call to procedure with null argument.And no side effects
   ignored - Scenario: Standalone call to procedure with null argument/And no side effects
Scenario: In-query call to procedure with null argument
   passed - Scenario: In-query call to procedure with null argument.Given an empty graph
   ignored - Scenario: In-query call to procedure with null argument/Given an empty graph
   passed - Scenario: In-query call to procedure with null argument.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   ignored - Scenario: In-query call to procedure with null argument/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: STRING?):
   passed - Scenario: In-query call to procedure with null argument.When executing query:
   ignored - Scenario: In-query call to procedure with null argument/When executing query:
   passed - Scenario: In-query call to procedure with null argument.Then the result should be, in order:
   ignored - Scenario: In-query call to procedure with null argument/Then the result should be, in order:
   passed - Scenario: In-query call to procedure with null argument.And no side effects
   ignored - Scenario: In-query call to procedure with null argument/And no side effects
Scenario: Standalone call to procedure should fail if input type is wrong
   passed - Scenario: Standalone call to procedure should fail if input type is wrong.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong/Given an empty graph
   passed - Scenario: Standalone call to procedure should fail if input type is wrong.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: Standalone call to procedure should fail if input type is wrong.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong/When executing query:
   passed - Scenario: Standalone call to procedure should fail if input type is wrong.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Standalone call to procedure should fail if input type is wrong/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: In-query call to procedure should fail if input type is wrong
   passed - Scenario: In-query call to procedure should fail if input type is wrong.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if input type is wrong/Given an empty graph
   passed - Scenario: In-query call to procedure should fail if input type is wrong.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if input type is wrong/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure should fail if input type is wrong.When executing query:
   ignored - Scenario: In-query call to procedure should fail if input type is wrong/When executing query:
   passed - Scenario: In-query call to procedure should fail if input type is wrong.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: In-query call to procedure should fail if input type is wrong/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Standalone call to procedure should fail if explicit argument is missing
   passed - Scenario: Standalone call to procedure should fail if explicit argument is missing.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing/Given an empty graph
   passed - Scenario: Standalone call to procedure should fail if explicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing/And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: Standalone call to procedure should fail if explicit argument is missing.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing/When executing query:
   passed - Scenario: Standalone call to procedure should fail if explicit argument is missing.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
   ignored - Scenario: Standalone call to procedure should fail if explicit argument is missing/Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
Scenario: In-query call to procedure should fail if explicit argument is missing
   passed - Scenario: In-query call to procedure should fail if explicit argument is missing.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing/Given an empty graph
   passed - Scenario: In-query call to procedure should fail if explicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing/And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure should fail if explicit argument is missing.When executing query:
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing/When executing query:
   passed - Scenario: In-query call to procedure should fail if explicit argument is missing.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
   ignored - Scenario: In-query call to procedure should fail if explicit argument is missing/Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
Scenario: Standalone call to procedure should fail if too many explicit argument are given
   passed - Scenario: Standalone call to procedure should fail if too many explicit argument are given.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given/Given an empty graph
   passed - Scenario: Standalone call to procedure should fail if too many explicit argument are given.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: Standalone call to procedure should fail if too many explicit argument are given.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given/When executing query:
   passed - Scenario: Standalone call to procedure should fail if too many explicit argument are given.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
   ignored - Scenario: Standalone call to procedure should fail if too many explicit argument are given/Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
Scenario: In-query call to procedure should fail if too many explicit argument are given
   passed - Scenario: In-query call to procedure should fail if too many explicit argument are given.Given an empty graph
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given/Given an empty graph
   passed - Scenario: In-query call to procedure should fail if too many explicit argument are given.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure should fail if too many explicit argument are given.When executing query:
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given/When executing query:
   passed - Scenario: In-query call to procedure should fail if too many explicit argument are given.Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
   ignored - Scenario: In-query call to procedure should fail if too many explicit argument are given/Then a SyntaxError should be raised at compile time: InvalidNumberOfArguments
Scenario: Standalone call to procedure should fail if implicit argument is missing
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.Given an empty graph
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing/Given an empty graph
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing/And there exists a procedure test.my.proc(name :: STRING?, in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.And parameters are:
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing/And parameters are:
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.When executing query:
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing/When executing query:
   passed - Scenario: Standalone call to procedure should fail if implicit argument is missing.Then a ParameterMissing should be raised at compile time: MissingParameter
   ignored - Scenario: Standalone call to procedure should fail if implicit argument is missing/Then a ParameterMissing should be raised at compile time: MissingParameter
Scenario: In-query call to procedure that has outputs fails if no outputs are yielded
   passed - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.Given an empty graph
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded/Given an empty graph
   passed - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.When executing query:
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded/When executing query:
   passed - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: In-query call to procedure that has outputs fails if no outputs are yielded/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded
   passed - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.Given an empty graph
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded/Given an empty graph
   passed - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded/And there exists a procedure test.my.proc(in :: INTEGER?) :: (out :: INTEGER?):
   passed - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.When executing query:
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded/When executing query:
   passed - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: In-query procedure call should fail if shadowing an already bound variable
   passed - Scenario: In-query procedure call should fail if shadowing an already bound variable.Given an empty graph
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable/Given an empty graph
   passed - Scenario: In-query procedure call should fail if shadowing an already bound variable.And there exists a procedure test.labels() :: (label :: STRING?):
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable/And there exists a procedure test.labels() :: (label :: STRING?):
   passed - Scenario: In-query procedure call should fail if shadowing an already bound variable.When executing query:
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable/When executing query:
   passed - Scenario: In-query procedure call should fail if shadowing an already bound variable.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: In-query procedure call should fail if shadowing an already bound variable/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function
   passed - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.Given an empty graph
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function/Given an empty graph
   passed - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.And there exists a procedure test.labels(in :: INTEGER?) :: (label :: STRING?):
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function/And there exists a procedure test.labels(in :: INTEGER?) :: (label :: STRING?):
   passed - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.When executing query:
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function/When executing query:
   passed - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function.Then a SyntaxError should be raised at compile time: InvalidAggregation
   ignored - Scenario: In-query procedure call should fail if one of the argument expressions uses an aggregation function/Then a SyntaxError should be raised at compile time: InvalidAggregation
Scenario: Fail when sorting on variable removed by DISTINCT
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.Given an empty graph
   ignored - Scenario: Fail when sorting on variable removed by DISTINCT/Given an empty graph
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.And having executed:
   ignored - Scenario: Fail when sorting on variable removed by DISTINCT/And having executed:
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.When executing query:
   ignored - Scenario: Fail when sorting on variable removed by DISTINCT/When executing query:
   passed - Scenario: Fail when sorting on variable removed by DISTINCT.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Fail when sorting on variable removed by DISTINCT/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when returning an undefined variable
   passed - Scenario: Failing when returning an undefined variable.Given any graph
   ignored - Scenario: Failing when returning an undefined variable/Given any graph
   passed - Scenario: Failing when returning an undefined variable.When executing query:
   ignored - Scenario: Failing when returning an undefined variable/When executing query:
   passed - Scenario: Failing when returning an undefined variable.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when returning an undefined variable/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when comparing to an undefined variable
   passed - Scenario: Failing when comparing to an undefined variable.Given any graph
   ignored - Scenario: Failing when comparing to an undefined variable/Given any graph
   passed - Scenario: Failing when comparing to an undefined variable.When executing query:
   ignored - Scenario: Failing when comparing to an undefined variable/When executing query:
   passed - Scenario: Failing when comparing to an undefined variable.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when comparing to an undefined variable/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when using IN on a string literal
   passed - Scenario: Failing when using IN on a string literal.Given any graph
   ignored - Scenario: Failing when using IN on a string literal/Given any graph
   passed - Scenario: Failing when using IN on a string literal.When executing query:
   ignored - Scenario: Failing when using IN on a string literal/When executing query:
   passed - Scenario: Failing when using IN on a string literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using IN on a string literal/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when using IN on an integer literal
   passed - Scenario: Failing when using IN on an integer literal.Given any graph
   ignored - Scenario: Failing when using IN on an integer literal/Given any graph
   passed - Scenario: Failing when using IN on an integer literal.When executing query:
   ignored - Scenario: Failing when using IN on an integer literal/When executing query:
   passed - Scenario: Failing when using IN on an integer literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using IN on an integer literal/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when using IN on a float literal
   passed - Scenario: Failing when using IN on a float literal.Given any graph
   ignored - Scenario: Failing when using IN on a float literal/Given any graph
   passed - Scenario: Failing when using IN on a float literal.When executing query:
   ignored - Scenario: Failing when using IN on a float literal/When executing query:
   passed - Scenario: Failing when using IN on a float literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using IN on a float literal/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when using IN on a boolean literal
   passed - Scenario: Failing when using IN on a boolean literal.Given any graph
   ignored - Scenario: Failing when using IN on a boolean literal/Given any graph
   passed - Scenario: Failing when using IN on a boolean literal.When executing query:
   ignored - Scenario: Failing when using IN on a boolean literal/When executing query:
   passed - Scenario: Failing when using IN on a boolean literal.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using IN on a boolean literal/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when a node is used as a relationship
   passed - Scenario: Failing when a node is used as a relationship.Given any graph
   ignored - Scenario: Failing when a node is used as a relationship/Given any graph
   passed - Scenario: Failing when a node is used as a relationship.When executing query:
   ignored - Scenario: Failing when a node is used as a relationship/When executing query:
   passed - Scenario: Failing when a node is used as a relationship.Then a SyntaxError should be raised at compile time: VariableTypeConflict
   ignored - Scenario: Failing when a node is used as a relationship/Then a SyntaxError should be raised at compile time: VariableTypeConflict
Scenario: Failing when a relationship is used as a node
   passed - Scenario: Failing when a relationship is used as a node.Given any graph
   ignored - Scenario: Failing when a relationship is used as a node/Given any graph
   passed - Scenario: Failing when a relationship is used as a node.When executing query:
   ignored - Scenario: Failing when a relationship is used as a node/When executing query:
   passed - Scenario: Failing when a relationship is used as a node.Then a SyntaxError should be raised at compile time: VariableTypeConflict
   ignored - Scenario: Failing when a relationship is used as a node/Then a SyntaxError should be raised at compile time: VariableTypeConflict
)` on a node
   passed - )` on a node.Given any graph(Scenario: Failing when using `type
   ignored - )` on a node/Given any graph(Scenario: Failing when using `type
   passed - )` on a node.When executing query:(Scenario: Failing when using `type
   ignored - )` on a node/When executing query:(Scenario: Failing when using `type
   passed - )` on a node.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `type
   ignored - )` on a node/Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `type
   passed - )` on a node.Given any graph(Scenario: Failing when using `length
   ignored - )` on a node/Given any graph(Scenario: Failing when using `length
   passed - )` on a node.When executing query:(Scenario: Failing when using `length
   ignored - )` on a node/When executing query:(Scenario: Failing when using `length
   passed - )` on a node.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `length
   ignored - )` on a node/Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing when using `length
Scenario: Failing when re-using a relationship in the same pattern
   passed - Scenario: Failing when re-using a relationship in the same pattern.Given any graph
   ignored - Scenario: Failing when re-using a relationship in the same pattern/Given any graph
   passed - Scenario: Failing when re-using a relationship in the same pattern.When executing query:
   ignored - Scenario: Failing when re-using a relationship in the same pattern/When executing query:
   passed - Scenario: Failing when re-using a relationship in the same pattern.Then a SyntaxError should be raised at compile time: RelationshipUniquenessViolation
   ignored - Scenario: Failing when re-using a relationship in the same pattern/Then a SyntaxError should be raised at compile time: RelationshipUniquenessViolation
Scenario: Failing when using variable length relationship in CREATE
   passed - Scenario: Failing when using variable length relationship in CREATE.Given any graph
   ignored - Scenario: Failing when using variable length relationship in CREATE/Given any graph
   passed - Scenario: Failing when using variable length relationship in CREATE.When executing query:
   ignored - Scenario: Failing when using variable length relationship in CREATE/When executing query:
   passed - Scenario: Failing when using variable length relationship in CREATE.Then a SyntaxError should be raised at compile time: CreatingVarLength
   ignored - Scenario: Failing when using variable length relationship in CREATE/Then a SyntaxError should be raised at compile time: CreatingVarLength
Scenario: Failing when using variable length relationship in MERGE
   passed - Scenario: Failing when using variable length relationship in MERGE.Given any graph
   ignored - Scenario: Failing when using variable length relationship in MERGE/Given any graph
   passed - Scenario: Failing when using variable length relationship in MERGE.When executing query:
   ignored - Scenario: Failing when using variable length relationship in MERGE/When executing query:
   passed - Scenario: Failing when using variable length relationship in MERGE.Then a SyntaxError should be raised at compile time: CreatingVarLength
   ignored - Scenario: Failing when using variable length relationship in MERGE/Then a SyntaxError should be raised at compile time: CreatingVarLength
Scenario: Failing when deleting an integer expression
   passed - Scenario: Failing when deleting an integer expression.Given any graph
   ignored - Scenario: Failing when deleting an integer expression/Given any graph
   passed - Scenario: Failing when deleting an integer expression.When executing query:
   ignored - Scenario: Failing when deleting an integer expression/When executing query:
   passed - Scenario: Failing when deleting an integer expression.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when deleting an integer expression/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when using CREATE on a node that is already bound
   passed - Scenario: Failing when using CREATE on a node that is already bound.Given any graph
   ignored - Scenario: Failing when using CREATE on a node that is already bound/Given any graph
   passed - Scenario: Failing when using CREATE on a node that is already bound.When executing query:
   ignored - Scenario: Failing when using CREATE on a node that is already bound/When executing query:
   passed - Scenario: Failing when using CREATE on a node that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using CREATE on a node that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using MERGE on a node that is already bound
   passed - Scenario: Failing when using MERGE on a node that is already bound.Given any graph
   ignored - Scenario: Failing when using MERGE on a node that is already bound/Given any graph
   passed - Scenario: Failing when using MERGE on a node that is already bound.When executing query:
   ignored - Scenario: Failing when using MERGE on a node that is already bound/When executing query:
   passed - Scenario: Failing when using MERGE on a node that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using MERGE on a node that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using CREATE on a relationship that is already bound
   passed - Scenario: Failing when using CREATE on a relationship that is already bound.Given any graph
   ignored - Scenario: Failing when using CREATE on a relationship that is already bound/Given any graph
   passed - Scenario: Failing when using CREATE on a relationship that is already bound.When executing query:
   ignored - Scenario: Failing when using CREATE on a relationship that is already bound/When executing query:
   passed - Scenario: Failing when using CREATE on a relationship that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using CREATE on a relationship that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using MERGE on a relationship that is already bound
   passed - Scenario: Failing when using MERGE on a relationship that is already bound.Given any graph
   ignored - Scenario: Failing when using MERGE on a relationship that is already bound/Given any graph
   passed - Scenario: Failing when using MERGE on a relationship that is already bound.When executing query:
   ignored - Scenario: Failing when using MERGE on a relationship that is already bound/When executing query:
   passed - Scenario: Failing when using MERGE on a relationship that is already bound.Then a SyntaxError should be raised at compile time: VariableAlreadyBound
   ignored - Scenario: Failing when using MERGE on a relationship that is already bound/Then a SyntaxError should be raised at compile time: VariableAlreadyBound
Scenario: Failing when using undefined variable in ON CREATE
   passed - Scenario: Failing when using undefined variable in ON CREATE.Given any graph
   ignored - Scenario: Failing when using undefined variable in ON CREATE/Given any graph
   passed - Scenario: Failing when using undefined variable in ON CREATE.When executing query:
   ignored - Scenario: Failing when using undefined variable in ON CREATE/When executing query:
   passed - Scenario: Failing when using undefined variable in ON CREATE.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when using undefined variable in ON CREATE/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when using undefined variable in ON MATCH
   passed - Scenario: Failing when using undefined variable in ON MATCH.Given any graph
   ignored - Scenario: Failing when using undefined variable in ON MATCH/Given any graph
   passed - Scenario: Failing when using undefined variable in ON MATCH.When executing query:
   ignored - Scenario: Failing when using undefined variable in ON MATCH/When executing query:
   passed - Scenario: Failing when using undefined variable in ON MATCH.Then a SyntaxError should be raised at compile time: UndefinedVariable
   ignored - Scenario: Failing when using undefined variable in ON MATCH/Then a SyntaxError should be raised at compile time: UndefinedVariable
Scenario: Failing when float value is too large
   passed - Scenario: Failing when float value is too large.Given any graph
   ignored - Scenario: Failing when float value is too large/Given any graph
   passed - Scenario: Failing when float value is too large.When executing query:
   ignored - Scenario: Failing when float value is too large/When executing query:
   passed - Scenario: Failing when float value is too large.Then a SyntaxError should be raised at compile time: FloatingPointOverflow
   ignored - Scenario: Failing when float value is too large/Then a SyntaxError should be raised at compile time: FloatingPointOverflow
Scenario: Failing when checking existence of a non-property and non-pattern
   passed - Scenario: Failing when checking existence of a non-property and non-pattern.Given any graph
   ignored - Scenario: Failing when checking existence of a non-property and non-pattern/Given any graph
   passed - Scenario: Failing when checking existence of a non-property and non-pattern.When executing query:
   ignored - Scenario: Failing when checking existence of a non-property and non-pattern/When executing query:
   passed - Scenario: Failing when checking existence of a non-property and non-pattern.Then a SyntaxError should be raised at compile time: InvalidArgumentExpression
   ignored - Scenario: Failing when checking existence of a non-property and non-pattern/Then a SyntaxError should be raised at compile time: InvalidArgumentExpression
)` on paths
   passed - )` on paths.Given any graph(Scenario: Failing for `size
   ignored - )` on paths/Given any graph(Scenario: Failing for `size
   passed - )` on paths.When executing query:(Scenario: Failing for `size
   ignored - )` on paths/When executing query:(Scenario: Failing for `size
   passed - )` on paths.Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing for `size
   ignored - )` on paths/Then a SyntaxError should be raised at compile time: InvalidArgumentType(Scenario: Failing for `size
Scenario: Failing when using aggregation in list comprehension
   passed - Scenario: Failing when using aggregation in list comprehension.Given any graph
   ignored - Scenario: Failing when using aggregation in list comprehension/Given any graph
   passed - Scenario: Failing when using aggregation in list comprehension.When executing query:
   ignored - Scenario: Failing when using aggregation in list comprehension/When executing query:
   passed - Scenario: Failing when using aggregation in list comprehension.Then a SyntaxError should be raised at compile time: InvalidAggregation
   ignored - Scenario: Failing when using aggregation in list comprehension/Then a SyntaxError should be raised at compile time: InvalidAggregation
Scenario: Failing when using non-constants in SKIP
   passed - Scenario: Failing when using non-constants in SKIP.Given any graph
   ignored - Scenario: Failing when using non-constants in SKIP/Given any graph
   passed - Scenario: Failing when using non-constants in SKIP.When executing query:
   ignored - Scenario: Failing when using non-constants in SKIP/When executing query:
   passed - Scenario: Failing when using non-constants in SKIP.Then a SyntaxError should be raised at compile time: NonConstantExpression
   ignored - Scenario: Failing when using non-constants in SKIP/Then a SyntaxError should be raised at compile time: NonConstantExpression
Scenario: Failing when using negative value in SKIP
   passed - Scenario: Failing when using negative value in SKIP.Given any graph
   ignored - Scenario: Failing when using negative value in SKIP/Given any graph
   passed - Scenario: Failing when using negative value in SKIP.When executing query:
   ignored - Scenario: Failing when using negative value in SKIP/When executing query:
   passed - Scenario: Failing when using negative value in SKIP.Then a SyntaxError should be raised at compile time: NegativeIntegerArgument
   ignored - Scenario: Failing when using negative value in SKIP/Then a SyntaxError should be raised at compile time: NegativeIntegerArgument
Scenario: Failing when using non-constants in LIMIT
   passed - Scenario: Failing when using non-constants in LIMIT.Given any graph
   ignored - Scenario: Failing when using non-constants in LIMIT/Given any graph
   passed - Scenario: Failing when using non-constants in LIMIT.When executing query:
   ignored - Scenario: Failing when using non-constants in LIMIT/When executing query:
   passed - Scenario: Failing when using non-constants in LIMIT.Then a SyntaxError should be raised at compile time: NonConstantExpression
   ignored - Scenario: Failing when using non-constants in LIMIT/Then a SyntaxError should be raised at compile time: NonConstantExpression
Scenario: Failing when using floating point in LIMIT
   passed - Scenario: Failing when using floating point in LIMIT.Given any graph
   ignored - Scenario: Failing when using floating point in LIMIT/Given any graph
   passed - Scenario: Failing when using floating point in LIMIT.When executing query:
   ignored - Scenario: Failing when using floating point in LIMIT/When executing query:
   passed - Scenario: Failing when using floating point in LIMIT.Then a SyntaxError should be raised at compile time: InvalidArgumentType
   ignored - Scenario: Failing when using floating point in LIMIT/Then a SyntaxError should be raised at compile time: InvalidArgumentType
Scenario: Failing when creating relationship without type
   passed - Scenario: Failing when creating relationship without type.Given any graph
   ignored - Scenario: Failing when creating relationship without type/Given any graph
   passed - Scenario: Failing when creating relationship without type.When executing query:
   ignored - Scenario: Failing when creating relationship without type/When executing query:
   passed - Scenario: Failing when creating relationship without type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
   ignored - Scenario: Failing when creating relationship without type/Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
Scenario: Failing when merging relationship without type
   passed - Scenario: Failing when merging relationship without type.Given any graph
   ignored - Scenario: Failing when merging relationship without type/Given any graph
   passed - Scenario: Failing when merging relationship without type.When executing query:
   ignored - Scenario: Failing when merging relationship without type/When executing query:
   passed - Scenario: Failing when merging relationship without type.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
   ignored - Scenario: Failing when merging relationship without type/Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
Scenario: Failing when merging relationship without type, no colon
   passed - Scenario: Failing when merging relationship without type, no colon.Given any graph
   ignored - Scenario: Failing when merging relationship without type, no colon/Given any graph
   passed - Scenario: Failing when merging relationship without type, no colon.When executing query:
   ignored - Scenario: Failing when merging relationship without type, no colon/When executing query:
   passed - Scenario: Failing when merging relationship without type, no colon.Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
   ignored - Scenario: Failing when merging relationship without type, no colon/Then a SyntaxError should be raised at compile time: NoSingleRelationshipType
Scenario: SKIP with an expression that depends on variables should fail
   passed - Scenario: SKIP with an expression that depends on variables should fail.Given any graph
   ignored - Scenario: SKIP with an expression that depends on variables should fail/Given any graph
   passed - Scenario: SKIP with an expression that depends on variables should fail.When executing query:
   ignored - Scenario: SKIP with an expression that depends on variables should fail/When executing query:
   passed - Scenario: SKIP with an expression that depends on variables should fail.Then a SyntaxError should be raised at compile time: NonConstantExpression
   ignored - Scenario: SKIP with an expression that depends on variables should fail/Then a SyntaxError should be raised at compile time: NonConstantExpression
Scenario: LIMIT with an expression that depends on variables should fail
   passed - Scenario: LIMIT with an expression that depends on variables should fail.Given any graph
   ignored - Scenario: LIMIT with an expression that depends on variables should fail/Given any graph
   passed - Scenario: LIMIT with an expression that depends on variables should fail.When executing query:
   ignored - Scenario: LIMIT with an expression that depends on variables should fail/When executing query:
   passed - Scenario: LIMIT with an expression that depends on variables should fail.Then a SyntaxError should be raised at compile time: NonConstantExpression
   ignored - Scenario: LIMIT with an expression that depends on variables should fail/Then a SyntaxError should be raised at compile time: NonConstantExpression
)` in aggregations
   passed - )` in aggregations.Given any graph(Scenario: Using `rand
   ignored - )` in aggregations/Given any graph(Scenario: Using `rand
   passed - )` in aggregations.When executing query:(Scenario: Using `rand
   ignored - )` in aggregations/When executing query:(Scenario: Using `rand
   passed - )` in aggregations.Then a SyntaxError should be raised at compile time: NonConstantExpression(Scenario: Using `rand
   ignored - )` in aggregations/Then a SyntaxError should be raised at compile time: NonConstantExpression(Scenario: Using `rand
