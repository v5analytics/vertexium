--- AccumuloMultiTableBatchWriter.java	2020-01-14 22:19:08.923353972 -0500
+++ VertexiumMultiTableBatchWriter.java	2020-01-14 22:59:08.986709746 -0500
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.accumulo.core.client.impl;
+package org.vertexium.accumulo.accumulo;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -29,15 +29,17 @@
 import org.apache.accumulo.core.client.MutationsRejectedException;
 import org.apache.accumulo.core.client.TableNotFoundException;
 import org.apache.accumulo.core.client.TableOfflineException;
+import org.apache.accumulo.core.client.impl.ClientContext;
+import org.apache.accumulo.core.client.impl.Tables;
 import org.apache.accumulo.core.data.Mutation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.google.common.util.concurrent.UncheckedExecutionException;
 
-public class MultiTableBatchWriterImpl implements MultiTableBatchWriter {
+public class VertexiumMultiTableBatchWriter implements MultiTableBatchWriter {
 
-  private static final Logger log = LoggerFactory.getLogger(MultiTableBatchWriterImpl.class);
+  private static final Logger log = LoggerFactory.getLogger(VertexiumMultiTableBatchWriter.class);
   private AtomicBoolean closed;
 
   private class TableBatchWriter implements BatchWriter {
@@ -73,15 +75,15 @@
 
   }
 
-  private TabletServerBatchWriter bw;
+  private VertexiumTabletServerBatchWriter bw;
   private ConcurrentHashMap<String,BatchWriter> tableWriters;
   private final ClientContext context;
 
-  public MultiTableBatchWriterImpl(ClientContext context, BatchWriterConfig config) {
+  public VertexiumMultiTableBatchWriter(ClientContext context, BatchWriterConfig config) {
     checkArgument(context != null, "context is null");
     checkArgument(config != null, "config is null");
     this.context = context;
-    this.bw = new TabletServerBatchWriter(context, config);
+    this.bw = new VertexiumTabletServerBatchWriter(context, config);
     tableWriters = new ConcurrentHashMap<>();
     this.closed = new AtomicBoolean(false);
   }
@@ -102,14 +104,14 @@
   @Override
   protected void finalize() {
     if (!closed.get()) {
-      log.warn(MultiTableBatchWriterImpl.class.getSimpleName()
+      log.warn(VertexiumMultiTableBatchWriter.class.getSimpleName()
           + " not shutdown; did you forget to call close()?");
       try {
         close();
       } catch (MutationsRejectedException mre) {
-        log.error(MultiTableBatchWriterImpl.class.getSimpleName() + " internal error.", mre);
+        log.error(VertexiumMultiTableBatchWriter.class.getSimpleName() + " internal error.", mre);
         throw new RuntimeException(
-            "Exception when closing " + MultiTableBatchWriterImpl.class.getSimpleName(), mre);
+            "Exception when closing " + VertexiumMultiTableBatchWriter.class.getSimpleName(), mre);
       }
     }
   }
@@ -123,7 +125,7 @@
    */
   private String getId(String tableName) throws TableNotFoundException {
     try {
-      return Tables.getTableId(context.inst, tableName);
+      return Tables.getTableId(context.getInstance(), tableName);
     } catch (UncheckedExecutionException e) {
       Throwable cause = e.getCause();
 
